<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>spring面试-事务</title>
      <link href="/2023/03/31/spring-mian-shi-shi-wu/"/>
      <url>/2023/03/31/spring-mian-shi-shi-wu/</url>
      
        <content type="html"><![CDATA[<p>spring 能否支持事务，取决去使用的数据库是否支持事务，比如对于MySQL来说，如果采用MyISAM，由于Myisam自身不支持事务，那么无论是否开启spring自身的事务，都是不能实现的。</p><h1 id="Spring事务"><a href="#Spring事务" class="headerlink" title="Spring事务"></a>Spring事务</h1><h2 id="1-spring支持的两种事务管理方式"><a href="#1-spring支持的两种事务管理方式" class="headerlink" title="1. spring支持的两种事务管理方式"></a>1. spring支持的两种事务管理方式</h2><h3 id="1-1-编程式事务管理"><a href="#1-1-编程式事务管理" class="headerlink" title="1.1 编程式事务管理"></a>1.1 编程式事务管理</h3><p>通过TransactionTemplate或者TransactionManager手动管理事务，实际中很少使用。<br>使用TransactionTrmplate进行编程式事务管理的实例代码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Autowired</span><span class="token keyword">private</span> <span class="token class-name">TransactionTemplate</span> transactionTemplate<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testTransaction</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        transactionTemplate<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">TransactionCallbackWithoutResult</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">doInTransactionWithoutResult</span><span class="token punctuation">(</span><span class="token class-name">TransactionStatus</span> transactionStatus<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>                    <span class="token comment">// ....  业务代码</span>                <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                    <span class="token comment">//回滚</span>                    transactionStatus<span class="token punctuation">.</span><span class="token function">setRollbackOnly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用 TransactionManager 进行编程式事务管理的示例代码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Autowired</span><span class="token keyword">private</span> <span class="token class-name">PlatformTransactionManager</span> transactionManager<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testTransaction</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token class-name">TransactionStatus</span> status <span class="token operator">=</span> transactionManager<span class="token punctuation">.</span><span class="token function">getTransaction</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">DefaultTransactionDefinition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>               <span class="token comment">// ....  业务代码</span>              transactionManager<span class="token punctuation">.</span><span class="token function">commit</span><span class="token punctuation">(</span>status<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>              transactionManager<span class="token punctuation">.</span><span class="token function">rollback</span><span class="token punctuation">(</span>status<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-2-声明式事务"><a href="#1-2-声明式事务" class="headerlink" title="1.2 声明式事务"></a>1.2 声明式事务</h3><p>实际是通过AOP实现的，这种方式对代码的侵入性比较小。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Transactional</span><span class="token punctuation">(</span>propagation <span class="token operator">=</span> <span class="token class-name">Propagation</span><span class="token punctuation">.</span><span class="token constant">REQUIRED</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">void</span> aMethod <span class="token punctuation">&#123;</span>  <span class="token comment">//do something</span>  <span class="token class-name">B</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token class-name">C</span> c <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">C</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  b<span class="token punctuation">.</span><span class="token function">bMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  c<span class="token punctuation">.</span><span class="token function">cMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-3-Spring事务管理接口介绍"><a href="#1-3-Spring事务管理接口介绍" class="headerlink" title="1.3 Spring事务管理接口介绍"></a>1.3 Spring事务管理接口介绍</h3><ul><li>PlatformTransactionManager: 事务管理器，Spring事务策略的核心</li><li>TransactionDefination： 事务定义信息（事务的回滚，隔离级别，传播行为，只读，超时）</li><li>TransactionalStatus： 事务运行的状态</li></ul><h4 id="1-3-1-PlatformTransactionManager"><a href="#1-3-1-PlatformTransactionManager" class="headerlink" title="1.3.1 PlatformTransactionManager"></a>1.3.1 PlatformTransactionManager</h4><p>Spring并不直接管理实务而是提供了许多的事务管理器。PlatformTransactionManager就是spring的重要管理器。通过这个接口，spring为各个平台：JDBC，JPA等等，都提供了对应的事务管理器，但是具体的实现就是各个平台自己的事情了。<br>PlatformTransactionManager接口中定义的方法:</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>transaction</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>lang<span class="token punctuation">.</span></span><span class="token class-name">Nullable</span></span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">PlatformTransactionManager</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//获得事务</span>    <span class="token class-name">TransactionStatus</span> <span class="token function">getTransaction</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Nullable</span> <span class="token class-name">TransactionDefinition</span> var1<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">TransactionException</span><span class="token punctuation">;</span>    <span class="token comment">//提交事务</span>    <span class="token keyword">void</span> <span class="token function">commit</span><span class="token punctuation">(</span><span class="token class-name">TransactionStatus</span> var1<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">TransactionException</span><span class="token punctuation">;</span>    <span class="token comment">//回滚事务</span>    <span class="token keyword">void</span> <span class="token function">rollback</span><span class="token punctuation">(</span><span class="token class-name">TransactionStatus</span> var1<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">TransactionException</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-3-2为什么要定义或者抽象出来这个接口"><a href="#1-3-2为什么要定义或者抽象出来这个接口" class="headerlink" title="1.3.2为什么要定义或者抽象出来这个接口"></a>1.3.2为什么要定义或者抽象出来这个接口</h3><p>主要是为了方便扩展，因为这样一来，不同平台的实现就可以自行设计，但是暴露给外部的接口是不变的，也就是说，提供给外部的行为是不变的，方便扩展。</p><blockquote><p>就如同我们为什么使用接口一样，比如我们要实现一个发送短信的代码，我们抽象出来一个接口，接口中有两个方法，发送短信，处理发送结果。如果我们刚开始是使用的阿里云发送，而后我们要改成其他的短信服务平台实现发送的功能，那么很显然，如果我们没有定义接口，那么需要重构调用发送代码的代码，而采用接口则只需要修改具体的短息发送代码。</p></blockquote><h3 id="1-3-3-事务属性"><a href="#1-3-3-事务属性" class="headerlink" title="1.3.3 事务属性"></a>1.3.3 事务属性</h3><p>事务管理器接口PlatformTransactionManager通过getTransaction(TransactionDefinition definition)方法来得到一个事务，而TransactionDefinition就是一个定义事务的基本属性的类。</p><p><strong>什么是事务属性？</strong></p><ul><li>隔离级别</li><li>传播行为</li><li>回滚规则</li><li>是否只读</li><li>是否超时</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>transaction</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>lang<span class="token punctuation">.</span></span><span class="token class-name">Nullable</span></span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">TransactionDefinition</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> <span class="token constant">PROPAGATION_REQUIRED</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token constant">PROPAGATION_SUPPORTS</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token constant">PROPAGATION_MANDATORY</span> <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token constant">PROPAGATION_REQUIRES_NEW</span> <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token constant">PROPAGATION_NOT_SUPPORTED</span> <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token constant">PROPAGATION_NEVER</span> <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token constant">PROPAGATION_NESTED</span> <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token constant">ISOLATION_DEFAULT</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token constant">ISOLATION_READ_UNCOMMITTED</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token constant">ISOLATION_READ_COMMITTED</span> <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token constant">ISOLATION_REPEATABLE_READ</span> <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token constant">ISOLATION_SERIALIZABLE</span> <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token constant">TIMEOUT_DEFAULT</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment">// 返回事务的传播行为，默认值为 REQUIRED。</span>    <span class="token keyword">int</span> <span class="token function">getPropagationBehavior</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//返回事务的隔离级别，默认值是 DEFAULT</span>    <span class="token keyword">int</span> <span class="token function">getIsolationLevel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 返回事务的超时时间，默认值为-1。如果超过该时间限制但事务还没有完成，则自动回滚事务。</span>    <span class="token keyword">int</span> <span class="token function">getTimeout</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 返回是否为只读事务，默认值为 false</span>    <span class="token keyword">boolean</span> <span class="token function">isReadOnly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Nullable</span>    <span class="token class-name">String</span> <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-3-4-事务状态"><a href="#1-3-4-事务状态" class="headerlink" title="1.3.4 事务状态"></a>1.3.4 事务状态</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">TransactionStatus</span><span class="token punctuation">&#123;</span>    <span class="token keyword">boolean</span> <span class="token function">isNewTransaction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 是否是新的事务</span>    <span class="token keyword">boolean</span> <span class="token function">hasSavepoint</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 是否有恢复点</span>    <span class="token keyword">void</span> <span class="token function">setRollbackOnly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 设置为只回滚</span>    <span class="token keyword">boolean</span> <span class="token function">isRollbackOnly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 是否为只回滚</span>    <span class="token keyword">boolean</span> isCompleted<span class="token punctuation">;</span> <span class="token comment">// 是否已完成</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="Spring事务详解"><a href="#Spring事务详解" class="headerlink" title="Spring事务详解"></a>Spring事务详解</h1><h2 id="2-事务传播行为"><a href="#2-事务传播行为" class="headerlink" title="2. 事务传播行为"></a>2. 事务传播行为</h2><p>事务传播行为是为了解决业务层方法之间相互调用的事务问题。<br>比如非事务方法去调用事务方法，那么事务方法会发生事务失效的问题。</p><p>当事务方法被另一个事务方法调用的时候我们必须指定事务该如何传播，比如如何回滚的问题。</p><h3 id="2-1-正确的事务传播行为可能的值"><a href="#2-1-正确的事务传播行为可能的值" class="headerlink" title="2.1 正确的事务传播行为可能的值"></a>2.1 正确的事务传播行为可能的值</h3><h4 id="1-TransactionDefinition-PROPAGATION-REQUIRED"><a href="#1-TransactionDefinition-PROPAGATION-REQUIRED" class="headerlink" title="1. TransactionDefinition.PROPAGATION_REQUIRED"></a>1. TransactionDefinition.PROPAGATION_REQUIRED</h4><p>使用最多的事务传播行为，也是<font style="background: violet"> 默认</font>的传播行为。</p><ul><li>如果当前外部方法没有开启事务，则当前事务会开启一个自己的新的事务，而且事务之间相互独立，不干扰</li><li>如果当前事务的外部事物开启了事务，并且被Progation.Required修饰的话，，那么当前的事务因为也开启了同样的Progation.Required，所以会被视为一个事务，只要一个方法发生了回滚，那么就会发生整体的回滚</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Service</span><span class="token class-name">Class</span> <span class="token class-name">A</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token class-name">B</span> b<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Transactional</span><span class="token punctuation">(</span>propagation <span class="token operator">=</span> <span class="token class-name">Propagation</span><span class="token punctuation">.</span><span class="token constant">REQUIRED</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> aMethod <span class="token punctuation">&#123;</span>        <span class="token comment">//do something</span>        b<span class="token punctuation">.</span><span class="token function">bMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token annotation punctuation">@Service</span><span class="token class-name">Class</span> <span class="token class-name">B</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Transactional</span><span class="token punctuation">(</span>propagation <span class="token operator">=</span> <span class="token class-name">Propagation</span><span class="token punctuation">.</span><span class="token constant">REQUIRED</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> bMethod <span class="token punctuation">&#123;</span>       <span class="token comment">//do something</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>只要B发生了回滚，那么因为A开启了Progation.REQUIRED，所以A也会回滚</p><h4 id="2-TransactionDefinanition-PROPAGATION-RTEQUIRES-NEW"><a href="#2-TransactionDefinanition-PROPAGATION-RTEQUIRES-NEW" class="headerlink" title="2. TransactionDefinanition.PROPAGATION_RTEQUIRES_NEW"></a>2. TransactionDefinanition.PROPAGATION_RTEQUIRES_NEW</h4><p>创建一个新的事务，如果当前存在事务，则会把当前的事务挂起，就是说不管外部是否存在事务，都会自行创建一个新的事务。且开启的事务相互独立，不户型干扰。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"> <span class="token annotation punctuation">@Service</span><span class="token class-name">Class</span> <span class="token class-name">A</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token class-name">B</span> b<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Transactional</span><span class="token punctuation">(</span>propagation <span class="token operator">=</span> <span class="token class-name">Propagation</span><span class="token punctuation">.</span><span class="token constant">REQUIRED</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> aMethod <span class="token punctuation">&#123;</span>        <span class="token comment">//do something</span>        b<span class="token punctuation">.</span><span class="token function">bMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token annotation punctuation">@Service</span><span class="token class-name">Class</span> <span class="token class-name">B</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Transactional</span><span class="token punctuation">(</span>propagation <span class="token operator">=</span> <span class="token class-name">Propagation</span><span class="token punctuation">.</span><span class="token constant">REQUIRES_NEW</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> bMethod <span class="token punctuation">&#123;</span>       <span class="token comment">//do something</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>如果A发生异常回滚，那么B不会回滚，因为B开启的是独立的事务，不会加入到A的事务之中</li><li>如果B发生异常回滚，<font style="background: violet"> A会回滚！</font>因为A是REQUIRED级别的事务，他会将上下文的事务统一成一个来看，所以一旦其中一个事务出现回滚，他也会回滚。</li></ul><h4 id="3-TransactioDefinition-PROPAGATION-NESTED"><a href="#3-TransactioDefinition-PROPAGATION-NESTED" class="headerlink" title="3. TransactioDefinition.PROPAGATION_NESTED:"></a>3. TransactioDefinition.PROPAGATION_NESTED:</h4><p>如果当前存在事务就在当前的事务内部嵌套执行事务，如果当前没有事务，就执行与 REQUIRED类似的事务。</p><ul><li><p>在外部方法开启事务的情况下，在内部开启一个新的事务，作为嵌套的存在。</p></li><li><p>在外部事物无方法的情况下，则单独开启一个事务。</p></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Service</span><span class="token class-name">Class</span> <span class="token class-name">A</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token class-name">B</span> b<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Transactional</span><span class="token punctuation">(</span>propagation <span class="token operator">=</span> <span class="token class-name">Propagation</span><span class="token punctuation">.</span><span class="token constant">REQUIRED</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> aMethod <span class="token punctuation">&#123;</span>        <span class="token comment">//do something</span>        b<span class="token punctuation">.</span><span class="token function">bMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token annotation punctuation">@Service</span><span class="token class-name">Class</span> <span class="token class-name">B</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Transactional</span><span class="token punctuation">(</span>propagation <span class="token operator">=</span> <span class="token class-name">Propagation</span><span class="token punctuation">.</span><span class="token constant">NESTED</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> bMethod <span class="token punctuation">&#123;</span>       <span class="token comment">//do something</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>B回滚，跟着回滚</p><h4 id="4-TransactionDefinition-PROPAGATION-MANDATORY"><a href="#4-TransactionDefinition-PROPAGATION-MANDATORY" class="headerlink" title="4. TransactionDefinition.PROPAGATION_MANDATORY"></a>4. TransactionDefinition.PROPAGATION_MANDATORY</h4><p>如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。（mandatory：强制性）这个使用的很少，就不举例子来说了</p><h3 id="2-2-事务的隔离级别"><a href="#2-2-事务的隔离级别" class="headerlink" title="2.2 事务的隔离级别"></a>2.2 事务的隔离级别</h3><p>一共5个隔离级别</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">TransactionDefinition</span> <span class="token punctuation">&#123;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">int</span> <span class="token constant">ISOLATION_DEFAULT</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token constant">ISOLATION_READ_UNCOMMITTED</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token constant">ISOLATION_READ_COMMITTED</span> <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token constant">ISOLATION_REPEATABLE_READ</span> <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token constant">ISOLATION_SERIALIZABLE</span> <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>逐一介绍（和MySQL类似。。。）</p><ul><li><p>TransactionDefinition.ISOLATION_DEFAULT：使用后端数据库默认的隔离级别，Mysql默认的级别是RR（可重复读），Oracle默认的是RC（读取已提交）</p></li><li><p>TransactionDefinition.ISOLATION_READ_UNCOMMITTED：读取未提交，会有脏读，幻读，不可重复读</p></li><li><p>TransactionDefinition.ISOLATION_READ_COMMITTED : 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生</p></li><li><p>TransactionDefinition.ISOLATION_REPEATABLE_READ : 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。</p></li><li><p>TransactionDefinition.ISOLATION_SERIALIZABLE : 最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。但是这将严重影响程序的性能。通常情况下也不会用到该级别。</p></li></ul><h3 id="2-3-事务超时属性"><a href="#2-3-事务超时属性" class="headerlink" title="2.3 事务超时属性"></a>2.3 事务超时属性</h3><p>如果超过最长执行时限，还没有完成，则自动回滚，在TransDefination中以init的值来表示超时时间。默认是-1；</p><h3 id="2-4-事务的只读属性"><a href="#2-4-事务的只读属性" class="headerlink" title="2.4 事务的只读属性"></a>2.4 事务的只读属性</h3><p>对于只要读取数据的事务，可以开启readonly，数据库会去优化。为什么数据查询操作还要开启事务支持？</p><blockquote><p>因为MySQL默认对每一个新建立的链接都启用了autocomit模式，在这个模式下，每一个发送到Mysql的sql语句都会在一个单独的事务中进行处理，执行结束后会自动提交事务，并开启一个新的事务。所欲我们可以看到，如果我们给方法加上了Transactional注解的话，这个方法的全部sql会被放入到一个事务之中，如果声明了只读事物的话数据库同样会去优化她的执行过程。缩短了执行时间。如果不加Transactional，那么每条sql会单独开启一个独立事务，这样耗时长，但是也会在实时的读取到最新的值。</p></blockquote><h3 id="2-5-事务回滚原则"><a href="#2-5-事务回滚原则" class="headerlink" title="2.5 事务回滚原则"></a>2.5 事务回滚原则</h3><p>可以自定义事务回滚的特定异常类型</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Transactional</span><span class="token punctuation">(</span>rollbackFor<span class="token operator">=</span> <span class="token class-name">MyException</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="3-Transactional-注解使用详解"><a href="#3-Transactional-注解使用详解" class="headerlink" title="3. @Transactional 注解使用详解"></a>3. @Transactional 注解使用详解</h2><h3 id="3-1-Transactional-的作用范围"><a href="#3-1-Transactional-的作用范围" class="headerlink" title="3.1 @Transactional 的作用范围"></a>3.1 @Transactional 的作用范围</h3><ol><li>方法：推荐使用在方法上，不过需要注意的是这个注解只能用到public方法上，否则不生效。</li><li>类： 如果这个注解使用在类上，表明该注解对类上的所有public方法都有效。</li><li>接口：不推荐在接口上使用</li></ol><p>@Transactional 的常用配置参数总结（只列出了 5 个平时比较常用的）：</p><p><img src="https://raw.githubusercontent.com/guduxingzheplus/blogPic/main/imgs/20230401093008.png" alt="20230401093008"></p><p>@Transactional 事务注解原理：<br>AOP实现的，AOP基于动态代理，如果目标实现了接口，默认情况下会采用jdk动态代理，否则采用cglib的代理。<br>createAopProxy（）方法决定了使用什么代理</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DefaultAopProxyFactory</span> <span class="token keyword">implements</span> <span class="token class-name">AopProxyFactory</span><span class="token punctuation">,</span> <span class="token class-name">Serializable</span> <span class="token punctuation">&#123;</span><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token class-name">AopProxy</span> <span class="token function">createAopProxy</span><span class="token punctuation">(</span><span class="token class-name">AdvisedSupport</span> config<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">AopConfigException</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>config<span class="token punctuation">.</span><span class="token function">isOptimize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> config<span class="token punctuation">.</span><span class="token function">isProxyTargetClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token function">hasNoUserSuppliedProxyInterfaces</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> targetClass <span class="token operator">=</span> config<span class="token punctuation">.</span><span class="token function">getTargetClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>targetClass <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">AopConfigException</span><span class="token punctuation">(</span><span class="token string">"TargetSource cannot determine target class: "</span> <span class="token operator">+</span><span class="token string">"Either an interface or a target is required for proxy creation."</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>targetClass<span class="token punctuation">.</span><span class="token function">isInterface</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token class-name">Proxy</span><span class="token punctuation">.</span><span class="token function">isProxyClass</span><span class="token punctuation">(</span>targetClass<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">JdkDynamicAopProxy</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ObjenesisCglibAopProxy</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">JdkDynamicAopProxy</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果一个类或者一个类中的public方法被标注了@Transactional注解，那么spring容器在启动的时候会为其创建一个代理类，在调用@Transactional注解的public方法的时候，实际调用的是TransactionInterceptor 类中的 invoke()方法。这个方法的作用就是在目标方法之前开启事务，方法执行过程中如果遇到异常的时候回滚事务，方法调用完成之后提交事务。</p><h3 id="3-2-Transactional-的使用注意事项总结"><a href="#3-2-Transactional-的使用注意事项总结" class="headerlink" title="3.2 @Transactional 的使用注意事项总结"></a>3.2 @Transactional 的使用注意事项总结</h3><ul><li>@Transactional 注解只有作用到 public 方法上事务才生效，不推荐在接口上使用；避免同一个类中调用 </li><li>@Transactional 注解的方法，这样会导致事务失效；</li><li>正确的设置 @Transactional 的 rollbackFor 和 propagation 属性，否则事务可能会回滚失败;</li><li>被 @Transactional 注解的方法所在的类必须被 Spring 管理，否则不生效；底层使用的数据库必须支持事务机制，否则不生效</li></ul>]]></content>
      
      
      <categories>
          
          <category> spring面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
            <tag> 事务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring面试--IoC/Aop</title>
      <link href="/2023/03/30/spring-mian-shi-ioc-aop/"/>
      <url>/2023/03/30/spring-mian-shi-ioc-aop/</url>
      
        <content type="html"><![CDATA[<h1 id="Spring-IoC"><a href="#Spring-IoC" class="headerlink" title="Spring IoC"></a>Spring IoC</h1><h2 id="1-谈谈对SpringIoc的理解"><a href="#1-谈谈对SpringIoc的理解" class="headerlink" title="1.谈谈对SpringIoc的理解"></a>1.谈谈对SpringIoc的理解</h2><h3 id="1-1-控制反转来源"><a href="#1-1-控制反转来源" class="headerlink" title="1.1 控制反转来源"></a>1.1 控制反转来源</h3><p>-控制指的是对象创建（实例化，管理的权利）<br>-反转：指的是将控制权交给外部环境（Spring框架，Ioc容器）<br><img src="https://raw.githubusercontent.com/guduxingzheplus/blogPic/main/imgs/20230330101109.png"></p><p>将对象之间的相互依赖关系交给IoC容器来管理，并由容器完成对象的注入，这样可以很大程度上简化应用的开发过程。<br>这样的好处是两方之间（调用方和被调用方）之间不再相互依赖</p><ul><li>降低对象之间的耦合度  </li><li>资源变得容易管理，比如用Spring容器提供的话，很容易实现一个单例。</li></ul><p><strong>IoC最常见的最合理的实践方式是依赖注入（DI）</strong></p><h3 id="1-2-DI"><a href="#1-2-DI" class="headerlink" title="1.2 DI"></a>1.2 DI</h3><p>DI即依赖注入：组件之间依赖关系由容器在运行时决定，形象的说，即由容器动态的将某个依赖注入到组件之中，依赖注入的目的并非为软件带来更多的功能，而是为了提升组件重用的频率，并未系统搭建一个灵活，可扩展的平台。</p><p>理解DI的关键是理解如下四个点：</p><ul><li>谁依赖谁 当然是程序依赖于IOC容器</li><li>为什么需要依赖：需要容器提供对象需要的外部资源</li><li>谁注入了谁： 很明显是IoC容器注入应用程序某个对象，应用程序依赖的对象。</li><li>注入了什么：就是注入某个对象所需要的外部资源</li></ul><h4 id="1-2-1-对于IoC的理解"><a href="#1-2-1-对于IoC的理解" class="headerlink" title="1.2.1 对于IoC的理解"></a>1.2.1 对于IoC的理解</h4><p>Spring所倡导的开发方式就是如此，所有的类都会在spring容器中登记，告诉spring你是个什么东西，你需要什么东西，然后spring会在系统运行到适当的时候，把你要的东西主动给你，同时也把你交给其他需要你的东西。所有的类的创建、销毁都由 spring来控制，也就是说控制对象生存周期的不再是引用它的对象，而是spring。对于某个具体的对象而言，以前是它控制其他对象，现在是所有对象都被spring控制，所以这叫控制反转。</p><h4 id="1-2-2-对于DI的理解"><a href="#1-2-2-对于DI的理解" class="headerlink" title="1.2.2 对于DI的理解"></a>1.2.2 对于DI的理解</h4><p>IoC的一个重点是在运行的时候，动态的向某个对象提供他所需要的对象，这一点是通过DI来实现的。</p><p>比如A对象需要操作数据库，他会向spring报告这个需求，而spring会在合适的时候创建这个数据库驱动，具体怎么创建A不知道，创建完毕之后注入A中，这就是DI。DI通常通过使用反射实现，他允许程序在运行的时候动态的生成对象，执行对象的方法，改变对象的属性。</p><h3 id="1-3-什么是AOP"><a href="#1-3-什么是AOP" class="headerlink" title="1.3 什么是AOP"></a>1.3 什么是AOP</h3><p>传统的OPP编程是不能解决横切逻辑代码的，所谓横切逻辑代码指的是代码在多个纵向顺序流程中出现的相同子流程代码，我们称之为横切逻辑代码。</p><p>例如：现有三个类，Horse、Pig、Dog，这三个类中都有 eat 和 run 两个方法。</p><p>通过 OOP 思想中的继承，我们可以提取出一个 Animal 的父类，然后将 eat 和 run 方法放入父类中，Horse、Pig、Dog通过继承Animal类即可自动获得 eat() 和 run() 方法。这样将会少些很多重复的代码。</p><p><img src="https://raw.githubusercontent.com/guduxingzheplus/blogPic/main/imgs/20230330102109.png"></p><p>OOP的代码如下：  </p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token punctuation">&#123;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Animal</span> <span class="token punctuation">&#123;</span>    <span class="token comment">/** 身高 */</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> height<span class="token punctuation">;</span>    <span class="token comment">/** 体重 */</span>    <span class="token keyword">private</span> <span class="token keyword">double</span> weight<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 性能监控代码</span>        <span class="token keyword">long</span> start <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 业务逻辑代码</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"I can eat..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 性能监控代码</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"执行时长："</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> start<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">1000f</span> <span class="token operator">+</span> <span class="token string">"s"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 性能监控代码</span>        <span class="token keyword">long</span> start <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 业务逻辑代码</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"I can run..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 性能监控代码</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"执行时长："</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> start<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">1000f</span> <span class="token operator">+</span> <span class="token string">"s"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/guduxingzheplus/blogPic/main/imgs/20230330102246.png"></p><p>横切代码存在的逻辑问题：</p><ul><li>代码重复</li><li>横切代码逻辑代码和业务代码混合在一起，代码臃肿，维护不方便</li></ul><p>AOP另辟蹊径，将横切代码抽离出来<br><img src="https://raw.githubusercontent.com/guduxingzheplus/blogPic/main/imgs/20230330102433.png"><br>代码拆分容易，难的是如何在不改变原有业务逻辑的情况下，达到一致的效果。</p><p><strong>AOP 为什么叫面向切片编程</strong></p><p>切：指的是横切逻辑，又有业务逻辑代码不懂，只能操作横切逻辑代码，所以面向横切逻辑</p><p>面：横切逻辑代码往往要影响很多个方法，每个方法如同一个点，多个点构成一个面。</p><h1 id="2-什么是Spring-Bean"><a href="#2-什么是Spring-Bean" class="headerlink" title="2. 什么是Spring Bean"></a>2. 什么是Spring Bean</h1><p>简单说，就是背那些Ioc容器管理的对象<br>我们需要告诉ioc容器要帮我们管理哪些对象，这个是通过元数据定义的。配置文件可以是XML文件，注解或者java配置类</p><h2 id="2-1-将类声明为Bean的注解"><a href="#2-1-将类声明为Bean的注解" class="headerlink" title="2.1 将类声明为Bean的注解"></a>2.1 将类声明为Bean的注解</h2><ul><li>@Componenet：通用注解，可以理解为Spring组件，不知道属于哪层的时候可以用。</li><li>@Repository：对应持久层的Dao层，主要用于数据库操作</li><li>@Service ：服务层，主要涉及一些复杂的逻辑，需要用到Dao</li><li>@Controller ：控制层，接受用户的调用，并请求Service层返回数据给前端。</li></ul><h2 id="2-2-Component-和-Bean区别"><a href="#2-2-Component-和-Bean区别" class="headerlink" title="2.2 @Component 和 @Bean区别"></a>2.2 @Component 和 @Bean区别</h2><ul><li>@Componenet 主要用于类的注解。 @Bean主要用于方法</li><li>@Componnet 主要是通过类路径扫描获得的，比如@ComponentScan，但是@Bean是在标有该注解的方法中定义产生这个bean，@Bean告诉了Spring，这个是某个类的实例，当我需要的时候，要还给我。</li><li>@Bean比@Component更加灵活，很多时候我们只能通过@Bean来注册bean，比如引用第三方库的时候。</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AppConfig</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> <span class="token class-name">TransferService</span> <span class="token function">transferService</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">TransferServiceImpl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的代码相当于如下的xml文件</p><pre class="line-numbers language-XML" data-language="XML"><code class="language-XML">&lt;beans&gt;    &lt;bean id&#x3D;&quot;transferService&quot; class&#x3D;&quot;com.acme.TransferServiceImpl&quot;&#x2F;&gt;&lt;&#x2F;beans&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>下面这个例子是通过 @Component 无法实现的。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Bean</span><span class="token keyword">public</span> <span class="token class-name">OneService</span> <span class="token function">getService</span><span class="token punctuation">(</span>status<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">case</span> <span class="token punctuation">(</span>status<span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>        when <span class="token number">1</span><span class="token operator">:</span>                <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token function">serviceImpl1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        when <span class="token number">2</span><span class="token operator">:</span>                <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token function">serviceImpl2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        when <span class="token number">3</span><span class="token operator">:</span>                <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token function">serviceImpl3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-3-Autowired和-Resource区别是什么？"><a href="#2-3-Autowired和-Resource区别是什么？" class="headerlink" title="2.3 @Autowired和@Resource区别是什么？"></a>2.3 @Autowired和@Resource区别是什么？</h2><p><font style="background: gray">Autowired</font><br>属于spring内置的注解，默认注入的方式为byType，也就是说会优先按照类型去匹配，但是存在如下的问题</p><ul><li><p>一个接口可能会出现同类型有很多个不同的实现类，这样就会造成byType混乱，找不到对应的实现类。这种情况下的实现办法如下：  </p><ul><li>spring会采用byName的形式来进行匹配，也就是根据类名的小写首字母的形式来进行匹配。举例  <pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Autowired</span><span class="token keyword">private</span> <span class="token class-name">SmService</span> smService<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul><p>  再比如：Sms有两个实现类，<font style="background:ddd gray">SmsServiceImpl1</font>和 <font style="background: gray">SmsServiceImpl2</font>此时都已经被spring容器管理，我们应该这样使用<br>  <pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 报错，byName 和 byType 都无法匹配到 bean</span><span class="token annotation punctuation">@Autowired</span><span class="token keyword">private</span> <span class="token class-name">SmsService</span> smsService<span class="token punctuation">;</span><span class="token comment">// 正确注入 SmsServiceImpl1 对象对应的 bean</span><span class="token annotation punctuation">@Autowired</span><span class="token keyword">private</span> <span class="token class-name">SmsService</span> smsServiceImpl1<span class="token punctuation">;</span><span class="token comment">// 正确注入  SmsServiceImpl1 对象对应的 bean</span><span class="token comment">// smsServiceImpl1 就是我们上面所说的名称</span><span class="token annotation punctuation">@Autowired</span><span class="token annotation punctuation">@Qualifier</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"smsServiceImpl1"</span><span class="token punctuation">)</span><span class="token keyword">private</span> <span class="token class-name">SmsService</span> smsService<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>  这里推荐使用@Qualifier来指定使用的类。</p><p>  <strong>@Resource</strong> 是jdk提供的注解，默认的注入方式为byName，如果无法通过byName注入，那么久通过byType进行注入。<br>  Resource有两个比较重要的属性：</p><ul><li>Name：名称</li><li>type：类型</li></ul></li></ul><p>总结一下：</p><ul><li>@Autowired 是 Spring 提供的注解，@Resource 是 JDK 提供的注解。</li><li>Autowired 默认的注入方式为byType（根据类型进行匹配），@Resource默认注入方式为 byName（根据名称进行匹配）。</li><li>在一个接口存在多个实现类的时候，二者都需要通过名称才能正确匹配到对应的bean，Autowired可以通过@Qualifer类显示的指定名称，@Resourse可以通过name属性来显示指定名称。</li></ul><h1 id="3-对SpringAoP的理解"><a href="#3-对SpringAoP的理解" class="headerlink" title="3.对SpringAoP的理解"></a>3.对SpringAoP的理解</h1><p>基于动态代理的，如果被代理的对象实现了某个接口，那么会用JDK Proxy代理，对于没有实现接口的对象，就使用cglib代理。</p><h2 id="3-1-Spring-AOP-和-AspectJ-AOP-有什么区别？"><a href="#3-1-Spring-AOP-和-AspectJ-AOP-有什么区别？" class="headerlink" title="3.1 Spring AOP 和 AspectJ AOP 有什么区别？"></a>3.1 Spring AOP 和 AspectJ AOP 有什么区别？</h2><p>也可以用AspectJ，这个是最完整的aop框架。Spring AOP属于是<strong>运行时增强</strong>而AspectJ是<strong>编译时增强</strong>，AOP是基于字节码操作。目前AOP已经集成了AspetJ但是，在切面比较少的情况下，两者差异不大，多的时候就用AspectJ，她的速度快很多。</p><h2 id="3-2-多个切面之间的执行顺序？"><a href="#3-2-多个切面之间的执行顺序？" class="headerlink" title="3.2 多个切面之间的执行顺序？"></a>3.2 多个切面之间的执行顺序？</h2><p>通过@Order来进行控制，通过实现Orderd接口重写getOrder方法</p><h1 id="4-Spring-mvc"><a href="#4-Spring-mvc" class="headerlink" title="4. Spring mvc"></a>4. Spring mvc</h1><h2 id="4-1-核心组件"><a href="#4-1-核心组件" class="headerlink" title="4.1 核心组件"></a>4.1 核心组件</h2><ul><li><font style="background:ddd gray">DispatcherServlet</font>： 核心的中央处理器，负责接受请求，分发，并给予客户端响应</li><li>HandlerMapping： 处理器映射器，根据uri去匹配查找能处理的Handler，并会将设计到的拦截器和Handler一起封装。</li><li>HandlerAdapter： 处理器适配器，根据上一步找到的Handler，适配对应执行的Handler</li><li>Handler: 请求处理器，处理实际请求的处理器。</li><li>ViewResolver：视图解析器，根据Handler返回的逻辑视图，解析并渲染真正的视图，并传递给DispatcherServlet。</li></ul><h2 id="4-2-工作原理"><a href="#4-2-工作原理" class="headerlink" title="4.2 工作原理"></a>4.2 工作原理</h2><p><img src="https://raw.githubusercontent.com/guduxingzheplus/blogPic/main/imgs/20230331081801.png" alt="20230331081801"></p><p><font style="background: gray">流程说明（important）：</font></p><ol><li>客户端浏览器发送请求到DispatchServlet</li><li>DispatcherServlet调用HandlerMapping，根据uri寻找合适的Handler（也就是Controller），并且会将请求涉及的拦截器和Handler一起封装返回。</li><li>DispatcherServlet调用HandlerAdapter适配执行Handler</li><li>Handler完成对用户请求的处理后，返回一个ModelAndView对象给DispathcerServlet，ModelAndView就是包含了数据模型以及相应的视图信息。Model是返回的数据对象，View是逻辑上的View</li><li>ViewResolver会根据逻辑View查找实际的view</li><li>DispatcherServlet将返回的Model传给View（视图渲染）</li><li>把view返回给请求者。</li></ol><h2 id="4-3-统一异常处理怎么做"><a href="#4-3-统一异常处理怎么做" class="headerlink" title="4.3 统一异常处理怎么做"></a>4.3 统一异常处理怎么做</h2><p>使用@ControllerAdvice + @ExceptionHandler来处理</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@ControllerAdvice</span><span class="token annotation punctuation">@ResponseBody</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">GlobalExceptionHandler</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@ExceptionHandler</span><span class="token punctuation">(</span><span class="token class-name">BaseException</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token class-name">ResponseEntity</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> <span class="token function">handleAppException</span><span class="token punctuation">(</span><span class="token class-name">BaseException</span> ex<span class="token punctuation">,</span> <span class="token class-name">HttpServletRequest</span> request<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token comment">//......</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@ExceptionHandler</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token class-name">ResourceNotFoundException</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token class-name">ResponseEntity</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">ErrorReponse</span><span class="token punctuation">></span></span> <span class="token function">handleResourceNotFoundException</span><span class="token punctuation">(</span><span class="token class-name">ResourceNotFoundException</span> ex<span class="token punctuation">,</span> <span class="token class-name">HttpServletRequest</span> request<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token comment">//......</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>@ControllerAdvice是controller增强器，主要三个作用，全局异常处理，全局数据绑定，全局数据预处理</p><p>这种异常处理方式下，会给所有或者指定的 Controller 织入异常处理的逻辑（AOP），当 Controller 中的方法抛出异常的时候，由被@ExceptionHandler 注解修饰的方法进行处理。</p><h1 id="5-Spring-Data-JPA"><a href="#5-Spring-Data-JPA" class="headerlink" title="5. Spring Data JPA"></a>5. Spring Data JPA</h1><h2 id="5-1-如何用JPA对数据库中的某个字段非持久化"><a href="#5-1-如何用JPA对数据库中的某个字段非持久化" class="headerlink" title="5.1 如何用JPA对数据库中的某个字段非持久化"></a>5.1 如何用JPA对数据库中的某个字段非持久化</h2><p>所谓非持久化，就是在实体类中，让某个字段不被数据库存储。<br>可以采用如下方法</p><ul><li><p>static String s1; &#x2F;&#x2F;加了static</p></li><li><p>final String s1 &#x3D; “ss”;  &#x2F;&#x2F;final修饰</p></li><li><p>transient String s1; &#x2F;&#x2F;trainsient修饰</p></li><li><p>@Transient &#x2F;&#x2F;加了注解<br>String s1;</p><p>主要使用后两种比较多</p></li></ul><h2 id="5-2-PA-的审计功能是做什么的？有什么用？"><a href="#5-2-PA-的审计功能是做什么的？有什么用？" class="headerlink" title="5.2 PA 的审计功能是做什么的？有什么用？"></a>5.2 PA 的审计功能是做什么的？有什么用？</h2><p>审计功能主要是帮助我们记录数据库操作的具体行为比如某条记录是谁创建的、什么时间创建的、最后修改人是谁、最后修改时间是什么时候。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Data</span><span class="token annotation punctuation">@AllArgsConstructor</span><span class="token annotation punctuation">@NoArgsConstructor</span><span class="token annotation punctuation">@MappedSuperclass</span><span class="token annotation punctuation">@EntityListeners</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token class-name">AuditingEntityListener</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">AbstractAuditBase</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@CreatedDate</span>    <span class="token annotation punctuation">@Column</span><span class="token punctuation">(</span>updatable <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">)</span>    <span class="token annotation punctuation">@JsonIgnore</span>    <span class="token keyword">private</span> <span class="token class-name">Instant</span> createdAt<span class="token punctuation">;</span>    <span class="token annotation punctuation">@LastModifiedDate</span>    <span class="token annotation punctuation">@JsonIgnore</span>    <span class="token keyword">private</span> <span class="token class-name">Instant</span> updatedAt<span class="token punctuation">;</span>    <span class="token annotation punctuation">@CreatedBy</span>    <span class="token annotation punctuation">@Column</span><span class="token punctuation">(</span>updatable <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">)</span>    <span class="token annotation punctuation">@JsonIgnore</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> createdBy<span class="token punctuation">;</span>    <span class="token annotation punctuation">@LastModifiedBy</span>    <span class="token annotation punctuation">@JsonIgnore</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> updatedBy<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>@CreatedDate: 表示该字段为创建时间字段，在这个实体被 insert 的时候，会设置值</li><li>@CreatedBy :表示该字段为创建人，在这个实体被 insert 的时候，会设置值@LastModifiedDate、@LastModifiedBy同理。</li></ul><h1 id="6-Spring-Security"><a href="#6-Spring-Security" class="headerlink" title="6. Spring Security"></a>6. Spring Security</h1><h2 id="6-1-有哪些请求权限的方法"><a href="#6-1-有哪些请求权限的方法" class="headerlink" title="6.1 有哪些请求权限的方法"></a>6.1 有哪些请求权限的方法</h2><ul><li>permitAll() ：无条件允许任何形式访问，不管你登录还是没有登录。</li><li>anonymous() ：允许匿名访问，也就是没有登录才可以访问。</li><li>denyAll() ：无条件决绝任何形式的访问。</li><li>authenticated()：只允许已认证的用户访问。</li><li>fullyAuthenticated() ：只允许已经登录或者通过 </li><li>remember-me 登录的用户访问。</li><li>hasRole(String) : 只允许指定的角色访问。</li><li>hasAnyRole(String)  : 指定一个或者多个角色，满足其一的用户即可访问。</li><li>hasAuthority(String) ：只允许具有指定权限的用户访问</li><li>hasAnyAuthority(String) ：指定一个或者多个权限，满足其一的用户即可访问。</li><li>hasIpAddress(String) : 只允许指定 ip 的用户访问。</li></ul><h2 id="6-2-hasRole-和-hasAuthority-有区别吗？"><a href="#6-2-hasRole-和-hasAuthority-有区别吗？" class="headerlink" title="6.2 hasRole 和 hasAuthority 有区别吗？"></a>6.2 hasRole 和 hasAuthority 有区别吗？</h2><p>二者是存在区别的，hasRole会要求数据库中的权限字段加上ROLE_前缀，而hasAuthority并不要求。从设计层面上讲，hasRole是角色表，而角色是权限的集合。也就是说，使用 hasAuthority 更具有一致性，你不用考虑要不要加 ROLE_ 前缀，数据库什么样这里就是什么样！而 hasRole 则不同，代码里如果写的是 admin，框架会自动加上 ROLE_ 前缀，所以数据库就必须是 ROLE_admin。</p><h2 id="6-3-对密码加密？"><a href="#6-3-对密码加密？" class="headerlink" title="6.3 对密码加密？"></a>6.3 对密码加密？</h2><p>使用bcrypt，当然也可以自己设计加密算法，继承PasswordEncoder类</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">PasswordEncoder</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 加密也就是对原始密码进行编码</span>    <span class="token class-name">String</span> <span class="token function">encode</span><span class="token punctuation">(</span><span class="token class-name">CharSequence</span> var1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 比对原始密码和数据库中保存的密码</span>    <span class="token keyword">boolean</span> <span class="token function">matches</span><span class="token punctuation">(</span><span class="token class-name">CharSequence</span> var1<span class="token punctuation">,</span> <span class="token class-name">String</span> var2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 判断加密密码是否需要再次进行加密，默认返回 false</span>    <span class="token keyword">default</span> <span class="token keyword">boolean</span> <span class="token function">upgradeEncoding</span><span class="token punctuation">(</span><span class="token class-name">String</span> encodedPassword<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="6-4-更换密码加密算法"><a href="#6-4-更换密码加密算法" class="headerlink" title="6.4 更换密码加密算法"></a>6.4 更换密码加密算法</h2><p>使用DelegatingPasswordEncoder兼容多种不同的加密方案。这其实是个代理类，并非全新的加密算法，他做的事情就是代理加密算法实现类。</p>]]></content>
      
      
      <categories>
          
          <category> spring面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
