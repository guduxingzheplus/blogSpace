<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>字符串dp</title>
      <link href="/2023/04/17/zi-fu-chuan-dp/"/>
      <url>/2023/04/17/zi-fu-chuan-dp/</url>
      
        <content type="html"><![CDATA[<h1 id="通配符匹配"><a href="#通配符匹配" class="headerlink" title="通配符匹配"></a>通配符匹配</h1><h1 id="力扣44题"><a href="#力扣44题" class="headerlink" title="力扣44题"></a>力扣44题</h1><p>给你一个输入字符串 (s) 和一个字符模式 (p) ，请你实现一个支持 ‘?’ 和 ‘*’ 匹配规则的通配符匹配：</p><ul><li>‘?’ 可以匹配任何单个字符。</li><li>‘*’ 可以匹配任意字符序列（包括空字符序列）。</li></ul><p>判定匹配成功的充要条件是：字符模式必须能够 完全匹配 输入字符串（而不是部分匹配）。</p><p>示例：</p><blockquote><p>输入：s &#x3D; “aa”, p &#x3D; “a”</p></blockquote><blockquote><p>输出：false</p></blockquote><blockquote><p>解释：”a” 无法匹配 “aa” 整个字符串。</p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>可以采用dp来解题。dp定义如下：</p><blockquote><p>dp[i][j] 表示s[i]与p[j]是否匹配</p></blockquote><p>主要遇到以下几种情况</p><ol><li><p>如果是普通字符，只需要比较当前字符是否相等，并和dp[i-1][j-1]相与。</p></li><li><p>如果是 <strong>？</strong> 那么秩序判断dp[i-1][j-1]即可，因为是可以匹配任意单个字符。</p></li><li><p>如果是 <strong>*</strong> 号比较复杂，因为可以选择是否使用*号，</p><ul><li>如果使用，则dp[i][j] &#x3D; dp[i-1][j],比如 abc, ab*。</li><li>如果不使用，则dp[i][j] &#x3D; dp[i][j-1], 比如ab， ab*</li></ul></li></ol><p>所以代码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isMatch</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">,</span> <span class="token class-name">String</span> p<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> m <span class="token operator">=</span> p<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">boolean</span><span class="token punctuation">[</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>m <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        s <span class="token operator">=</span> <span class="token string">" "</span> <span class="token operator">+</span> s<span class="token punctuation">;</span>        p <span class="token operator">=</span> <span class="token string">" "</span> <span class="token operator">+</span> p<span class="token punctuation">;</span>        <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> sc <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> pc <span class="token operator">=</span> p<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> m<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>pc<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token char">'*'</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">||</span><span class="token punctuation">(</span>i<span class="token operator">-</span><span class="token number">1</span> <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token operator">-</span><span class="token number">1</span><span class="token operator">>=</span><span class="token number">0</span> <span class="token operator">&amp;&amp;</span> dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>sc<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> pc<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">||</span> pc<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token char">'?'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>为了方便，在两个字符串的开头加了哨兵，省去了初始化的过程。<br>动图在这<br><a href="https://leetcode.cn/problems/wildcard-matching/solutions/80942/dong-tai-gui-hua-dai-zhu-shi-by-tangweiqun/">https://leetcode.cn/problems/wildcard-matching/solutions/80942/dong-tai-gui-hua-dai-zhu-shi-by-tangweiqun/</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 力扣刷题 </tag>
            
            <tag> dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring面试-循环依赖</title>
      <link href="/2023/04/17/spring-mian-shi-xun-huan-yi-lai/"/>
      <url>/2023/04/17/spring-mian-shi-xun-huan-yi-lai/</url>
      
        <content type="html"><![CDATA[<h1 id="Spring是如何解决的循环依赖？"><a href="#Spring是如何解决的循环依赖？" class="headerlink" title="Spring是如何解决的循环依赖？"></a>Spring是如何解决的循环依赖？</h1><p>Spring通过三级缓存解决了循环依赖，其中一级缓存为单例池（singletonObjects）,二级缓存为早期曝光对象earlySingletonObjects，三级缓存为早期曝光对象工厂（singletonFactories）。当A、B两个类发生循环引用时，在A完成实例化后，就使用实例化后的对象去创建一个对象工厂，并添加到三级缓存中，如果A被AOP代理，那么通过这个工厂获取到的就是A代理后的对象，如果A没有被AOP代理，那么这个工厂获取到的就是A实例化的对象。当A进行属性注入时，会去创建B，同时B又依赖了A，所以创建B的同时又会去调用getBean(a)来获取需要的依赖，此时的getBean(a)会从缓存中获取，第一步，先获取到三级缓存中的工厂；第二步，调用对象工工厂的getObject方法来获取到对应的对象，得到这个对象后将其注入到B中。紧接着B会走完它的生命周期流程，包括初始化、后置处理器等。当B创建完后，会将B再注入到A中，此时A再完成它的整个生命周期。至此，循环依赖结束！</p><h1 id="为什么要使用三级缓存呢？二级缓存能解决循环依赖吗"><a href="#为什么要使用三级缓存呢？二级缓存能解决循环依赖吗" class="headerlink" title="为什么要使用三级缓存呢？二级缓存能解决循环依赖吗"></a>为什么要使用三级缓存呢？二级缓存能解决循环依赖吗</h1><p>如果要使用二级缓存解决循环依赖，意味着所有Bean在实例化后就要完成AOP代理，这样违背了Spring设计的原则，Spring在设计之初就是通过AnnotationAwareAspectJAutoProxyCreator这个后置处理器来在Bean生命周期的最后一步来完成AOP代理，而不是在实例化后就立马进行AOP代理。</p><h1 id="什么情况下循环依赖可以被处理？"><a href="#什么情况下循环依赖可以被处理？" class="headerlink" title="什么情况下循环依赖可以被处理？"></a>什么情况下循环依赖可以被处理？</h1><p>在回答这个问题之前首先要明确一点，Spring解决循环依赖是有前置条件的</p><ol><li>出现循环依赖的Bean必须要是单例</li><li>依赖注入的方式不能全是构造器注入的方式（很多博客上说，只能解决setter方法的循环依赖，这是错误的）</li></ol><p>其中第一点应该很好理解，第二点：不能全是构造器注入是什么意思呢？我们还是用代码说话</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Component</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">&#123;</span><span class="token comment">//    @Autowired</span><span class="token comment">//    private B b;</span>    <span class="token keyword">public</span> <span class="token class-name">A</span><span class="token punctuation">(</span><span class="token class-name">B</span> b<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token annotation punctuation">@Component</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token punctuation">&#123;</span><span class="token comment">//    @Autowired</span><span class="token comment">//    private A a;</span>    <span class="token keyword">public</span> <span class="token class-name">B</span><span class="token punctuation">(</span><span class="token class-name">A</span> a<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在上面的例子中，A中注入B的方式是通过构造器，B中注入A的方式也是通过构造器，这个时候循环依赖是无法被解决</p>]]></content>
      
      
      
        <tags>
            
            <tag> spring </tag>
            
            <tag> 循环依赖 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>消息队列基础知识</title>
      <link href="/2023/04/10/xiao-xi-dui-lie-ji-chu-zhi-shi/"/>
      <url>/2023/04/10/xiao-xi-dui-lie-ji-chu-zhi-shi/</url>
      
        <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8">消息队列有什么用？</a><ul><li><a href="#%E9%80%9A%E8%BF%87%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86%E6%8F%90%E9%AB%98%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%80%A7%E8%83%BD%E5%87%8F%E5%B0%91%E7%9B%B8%E5%BA%94%E6%89%80%E9%9C%80%E7%9A%84%E6%97%B6%E9%97%B4">通过异步处理提高系统的性能（减少相应所需的时间）</a></li><li><a href="#%E5%89%8A%E5%B3%B0--%E9%99%90%E6%B5%81">削峰 &#x2F; 限流</a></li><li><a href="#%E9%99%8D%E4%BD%8E%E7%B3%BB%E7%BB%9F%E8%80%A6%E5%90%88%E6%80%A7">降低系统耦合性</a></li></ul></li><li><a href="#%E4%BD%BF%E7%94%A8%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%B8%A6%E6%9D%A5%E5%93%AA%E4%BA%9B%E9%97%AE%E9%A2%98">使用消息队列带来哪些问题</a></li><li><a href="#rpc%E6%9E%B6%E6%9E%84%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84">RPC架构的基本结构</a></li><li><a href="#rpc-%E5%92%8C%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E5%8C%BA%E5%88%AB">RPC 和消息队列的区别</a></li></ul><!-- /TOC --><h1 id="1-消息队列有什么用？"><a href="#1-消息队列有什么用？" class="headerlink" title="1. 消息队列有什么用？"></a>1. 消息队列有什么用？</h1><ol><li>通过异步处理提高系统的性能（减少相应所需的时间）</li><li>削峰 &#x2F; 限流</li><li>降低系统耦合性</li></ol><h2 id="1-1-通过异步处理提高系统的性能（减少相应所需的时间）"><a href="#1-1-通过异步处理提高系统的性能（减少相应所需的时间）" class="headerlink" title="1.1 通过异步处理提高系统的性能（减少相应所需的时间）"></a>1.1 通过异步处理提高系统的性能（减少相应所需的时间）</h2><p>主要原理就是将请求打到消息队列后，立即返回相应的结果，由消息队列消化这些消息，由于可能涉及到数据库的操作等诸多行为，所以可能存在失败的风险，在执行成功后，通知用户。类似下单买火车票，会告诉你正在下单中，然后会返回短信提醒你下单成功。<br><img src="https://raw.githubusercontent.com/guduxingzheplus/blogPic/main/imgs/20230410095226.png" alt="20230410095226"></p><h2 id="1-2-削峰-x2F-限流"><a href="#1-2-削峰-x2F-限流" class="headerlink" title="1.2 削峰 &#x2F; 限流"></a>1.2 削峰 &#x2F; 限流</h2><p>先将短时间的高并发事务产生的事务消息存储在消息队列中，然后后端服务再慢慢根据自己的能力去消费这些信息，这样就避免了直接将后端服务打垮掉。</p><p><img src="https://raw.githubusercontent.com/guduxingzheplus/blogPic/main/imgs/20230410095446.png" alt="20230410095446"></p><h2 id="1-3-降低系统耦合性"><a href="#1-3-降低系统耦合性" class="headerlink" title="1.3 降低系统耦合性"></a>1.3 降低系统耦合性</h2><p>消息队列的主要形式就是订阅-发布模式，但是并不是唯一的一种模式，只是说比较常用，还有点对点的一些模式。这两种模型由JMS提供。降低耦合性的具体体现在于。生产者在将消息发送出去之后，不再管理消息，但是发送之后会记录这条消息，直到消息被消费者成功消费了以后在从发送者的服务器上删除这条记录（主要是为了避免服务器宕机造成的消息的丢失问题），在消息队列宕机后，生产者会选择分布式消息队列服务器集群中的其他服务发布消息。<br>生产者（客户端）发送消息到消息队列中去，接受者（服务端）处理消息，需要消费的系统直接去消息队列取消息进行消费即可而不需要和其他系统有耦合，这显然也提高了系统的扩展性。对于新增的业务，只要对消息队列中的内容感兴趣就可以订阅该消息队列。对原有的系统没有任何影响。<br><img src="https://raw.githubusercontent.com/guduxingzheplus/blogPic/main/imgs/20230410101108.png" alt="20230410101108"></p><h1 id="2-使用消息队列带来哪些问题"><a href="#2-使用消息队列带来哪些问题" class="headerlink" title="2.使用消息队列带来哪些问题"></a>2.使用消息队列带来哪些问题</h1><ul><li>系统可用性降低： 因为加入了新的MQ模块，需要考虑消息丢失或者挂掉 的风险。</li><li>系统复杂性的提高： 要保证消息没有被重复消费，消息丢失等情况，保证消息传递的顺序性问题。</li><li>一致性问题： 异步模式导致的消息真正的消费者并没有正确消费消息。</li></ul><h1 id="3-RPC架构的基本结构"><a href="#3-RPC架构的基本结构" class="headerlink" title="3. RPC架构的基本结构"></a>3. RPC架构的基本结构</h1><p>构建分布式系统的时候的服务与服务之间的调用。</p><p>首先，我们通常把发生调用关系的两个服务分别称为服务的提供者（Provider）和消费者（Consumer）。所以，简单来说，RPC 就是服务的消费者向提供者发起远程调用并获取结果的过程，这是 RPC 最简单的一种表现形式。<img src="https://raw.githubusercontent.com/guduxingzheplus/blogPic/main/imgs/20230410102857.png" alt="20230410102857"></p><p>如果想要实现服务提供者和消费者之间的有效交互，那么两者之间就需要确立与网络通信相关的网络协议以及通信通道。同时，服务的提供者需要把自己的服务调用入口暴露出来，并时刻准备接收来自消费者的请求。<br>这里，我们把通信通道和网络协议分别命名为 RpcChannel 和 RpcProtocol，而把服务提供者接收请求的组件称为 RpcAcceptor，把消费者发起请求的组件称为 RpcConnector。这样，RPC 架构就演变成了这个样子：<br><img src="https://raw.githubusercontent.com/guduxingzheplus/blogPic/main/imgs/20230410102932.png" alt="20230410102932"></p><p>然后，对于服务提供者和消费者而言，为了双方能够正常识别所发送的请求和所接收到的响应结果，需要定义统一的契约。我们把这种契约称为远程 API（Remote API），以便与本地 API 加以区别。如此一来，基于同一套远程 API 的定义，RPC 架构就具备了根据业务来定义通信契约的能力。</p><h1 id="4-RPC-和消息队列的区别"><a href="#4-RPC-和消息队列的区别" class="headerlink" title="4. RPC 和消息队列的区别"></a>4. RPC 和消息队列的区别</h1><ul><li>从用途看： RPC主要解决的是远程调用api的问题，并不需要了解底层网络的通信机制，通过RPC调用远程方法就像调用本地方法一样简单。消息队列主要用来降低系统的耦合性，实现任务异步，有效的进行流量削峰。</li><li>从通信方式来看： RPC是直接双向网络通讯，消息队列是单向的引入中间载体的网络通讯。</li><li>从架构上来看： 消息队列为了防止消息的丢失，需要将消息存储起来，而RPC则不需要，因为是双向直接网络通讯。</li><li>从处理请求的时效性上来看： 通过RPC发出的调用一般会立即被处理，而消息队列则不会。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 消息队列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> 消息队列基础知识 </tag>
            
            <tag> 消息队列通用知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络常见面试题--TCP</title>
      <link href="/2023/04/04/ji-suan-ji-wang-luo-chang-jian-mian-shi-ti-tcp/"/>
      <url>/2023/04/04/ji-suan-ji-wang-luo-chang-jian-mian-shi-ti-tcp/</url>
      
        <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#tcp%E9%93%BE%E6%8E%A5%E5%BB%BA%E7%AB%8B">TCP链接建立</a><ul><li><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%B8%8D%E6%98%AF%E4%B8%A4%E6%AC%A1%E5%9B%9B%E6%AC%A1">为什么是三次握手？不是两次、四次？</a><ul><li><a href="#%E9%81%BF%E5%85%8D%E5%8E%86%E5%8F%B2%E8%BF%9E%E6%8E%A5">避免历史连接</a><ul><li><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%A4%E6%AC%A1%E6%8F%A1%E6%89%8B%E6%97%A0%E6%B3%95%E9%98%BB%E6%AD%A2%E5%8E%86%E5%8F%B2%E8%BF%9E%E6%8E%A5">为什么两次握手无法阻止历史连接？</a></li><li><a href="#%E5%A6%82%E6%9E%9C%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%9C%A8%E5%9B%9E%E5%A4%8D%E7%AC%AC%E4%BA%8C%E6%AC%A1ack%E7%9A%84%E6%97%B6%E5%80%99%E4%B8%A2%E5%A4%B1%E6%98%AF%E5%90%A6%E8%83%BD%E6%AD%A3%E5%B8%B8%E5%BB%BA%E7%AB%8B%E6%95%B4%E4%B8%AA%E8%BF%87%E7%A8%8B">如果客户端在回复第二次ack的时候丢失是否能正常建立整个过程？</a></li></ul></li><li><a href="#%E5%8F%8C%E6%96%B9%E5%90%8C%E6%AD%A5%E5%88%9D%E5%A7%8B%E5%A7%8B%E5%88%97%E5%8F%B7">双方同步初始始列号</a></li><li><a href="#%E9%81%BF%E5%85%8D%E8%B5%84%E6%BA%90%E6%B5%AA%E8%B4%B9">避免资源浪费</a></li></ul></li><li><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%AF%8F%E6%AC%A1%E5%BB%BA%E7%AB%8Btcp%E8%BF%9E%E6%8E%A5%E7%9A%84%E6%97%B6%E5%80%99%E9%83%BD%E8%A6%81%E6%B1%82%E5%88%9D%E5%A7%8B%E5%8C%96%E5%BA%8F%E5%88%97%E5%8F%B7%E4%B8%8D%E4%B8%80%E6%A0%B7">为什么每次建立TCP连接的时候都要求初始化序列号不一样？</a></li><li><a href="#%E6%97%A2%E7%84%B6ip%E5%B1%82%E4%BC%9A%E5%88%86%E7%89%87%E9%82%A3%E4%B9%88%E4%B8%BA%E4%BB%80%E4%B9%88tcp%E5%B1%82%E8%BF%98%E9%9C%80%E8%A6%81mss%E5%91%A2">既然IP层会分片，那么为什么TCP层还需要MSS呢？</a></li><li><a href="#%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%B8%A2%E5%A4%B1%E4%BA%86%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88">第一次握手丢失了，会发生什么？</a></li><li><a href="#%E7%AC%AC%E4%BA%8C%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%B8%A2%E5%A4%B1%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E9%BA%BD">第二次握手丢失会发生什麽？</a></li><li><a href="#%E7%AC%AC%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%B8%A2%E5%A4%B1%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88">第三次握手丢失会发生什么？</a></li><li><a href="#%E4%BB%80%E4%B9%88%E6%98%AFsyn%E6%94%BB%E5%87%BB%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D">什么是SYN攻击，如何避免？</a></li></ul></li><li><a href="#tcp%E6%96%AD%E5%BC%80%E8%BF%9E%E6%8E%A5">TCP断开连接</a><ul><li><a href="#%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B">四次挥手</a></li></ul></li><li><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%8C%A5%E6%89%8B%E9%9C%80%E8%A6%81%E5%9B%9B%E6%AC%A1">为什么挥手需要四次？</a></li><li><a href="#%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%8C%A5%E6%89%8B%E4%B8%A2%E5%A4%B1%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88">第一次挥手丢失会发生什么？</a></li><li><a href="#%E7%AC%AC%E4%BA%8C%E6%AC%A1%E6%8C%A5%E6%89%8B%E4%B8%A2%E5%A4%B1%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88">第二次挥手丢失会发生什么？</a></li><li><a href="#%E7%AC%AC%E4%B8%89%E6%AC%A1%E6%8C%A5%E6%89%8B%E4%B8%A2%E5%A4%B1%E4%BA%86%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88">第三次挥手丢失了，会发生什么？</a></li><li><a href="#%E7%AC%AC%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E4%B8%A2%E5%A4%B1%E4%BA%86%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E9%BA%BD">第四次挥手丢失了会发生什麽？</a></li><li><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88-time_wait-%E7%AD%89%E5%BE%85%E7%9A%84%E6%97%B6%E9%97%B4%E6%98%AF-2msl">为什么 TIME_WAIT 等待的时间是 2MSL？</a></li><li><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81time_wait%E7%8A%B6%E6%80%81">为什么需要TIME_WAIT状态？</a><ul><li><a href="#%E9%98%B2%E6%AD%A2%E5%8E%86%E5%8F%B2%E8%BF%9E%E6%8E%A5%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E8%A2%AB%E5%90%8E%E9%9D%A2%E7%9B%B8%E5%90%8C%E7%9A%84%E5%9B%9B%E5%85%83%E7%BB%84%E9%94%81%E6%8E%A5%E5%8F%97">防止历史连接中的数据，被后面相同的四元组锁接受</a></li><li><a href="#%E4%BF%9D%E8%AF%81%E8%BF%9E%E6%8E%A5%E8%A2%AB%E5%8A%A8%E5%85%B3%E9%97%AD%E7%9A%84%E4%B8%80%E6%96%B9%E5%8F%AF%E4%BB%A5%E8%A2%AB%E6%AD%A3%E7%A1%AE%E7%9A%84%E5%85%B3%E9%97%AD">保证连接被动关闭的一方可以被正确的关闭</a></li></ul></li><li><a href="#time_wait-%E8%BF%87%E5%A4%9A%E6%9C%89%E4%BB%80%E4%B9%88%E5%8D%B1%E5%AE%B3">TIME_WAIT 过多有什么危害</a></li><li><a href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%A4%A7%E9%87%8F%E5%87%BA%E7%8E%B0time_wait%E7%9A%84%E5%8E%9F%E5%9B%A0">服务端大量出现TIME_WAIT的原因</a></li></ul><!-- /TOC --><h1 id="1-TCP链接建立"><a href="#1-TCP链接建立" class="headerlink" title="1.TCP链接建立"></a>1.TCP链接建立</h1><hr><h2 id="1-为什么是三次握手？不是两次、四次？"><a href="#1-为什么是三次握手？不是两次、四次？" class="headerlink" title="1. 为什么是三次握手？不是两次、四次？"></a>1. 为什么是三次握手？不是两次、四次？</h2><h3 id="1-1-避免历史连接"><a href="#1-1-避免历史连接" class="headerlink" title="1.1 避免历史连接"></a>1.1 避免历史连接</h3><p>主要原因就是防止旧的连接重复建立造成的初始化混乱。我们考虑一个场景，客户端先发送了 SYN（seq &#x3D; 90）报文，然后客户端宕机了，而且这个 SYN 报文还被网络阻塞了，服务端并没有收到，接着客户端重启后，又重新向服务端建立连接，发送了 SYN（seq &#x3D; 100）报文（注意！不是重传 SYN，重传的 SYN 的序列号是一样的）。<br><img src="https://raw.githubusercontent.com/guduxingzheplus/blogPic/main/imgs/20230404085731.png" alt="20230404085731"></p><p>客户端连续发送多次的syn，建立连接的报文，在网络拥堵的情况下：</p><ul><li>一个旧的报文比新的syn报文早到达了服务端，那么此时服务端就会返回一个SYN+ACK报文给客户端，此报文的确认号就是91</li><li>客户端收到后，发现自己的期望值应该是101，不是91，所以会回RST报文</li><li>服务端收到RST报文后，会释放连接</li><li>后续新的SYN到达服务端之后，客户端与服务端建立正常的三次握手</li></ul><blockquote><p>如果服务器在收到RST之前收到了新的SYN，怎么办？<br>当服务器收到旧的SYN的时候会返回ACK+SYN（91），此时再收到新的SYN报文就会回Challenge Ack报文给客户端，这个ack报文并不是确认收到新syn报文的确认信息，而是上一次的ack确认号，也就是91，所以客户端收到ACK报文时，会发现自己收到的是91，而期望的是101，就会发送RST报文。</p></blockquote><h4 id="1-1-1-为什么两次握手无法阻止历史连接？"><a href="#1-1-1-为什么两次握手无法阻止历史连接？" class="headerlink" title="1.1.1 为什么两次握手无法阻止历史连接？"></a>1.1.1 为什么两次握手无法阻止历史连接？</h4><p>因为两次握手的过程中，只要客户点的syn到达服务端，服务端就会创建一个连接，进入establish状态，这样无疑是资源的浪费。虽然客户端收到服务端的ack+syn后会再次返回RST，但是这期间服务端的端口已经被占用了，并开启了连接，所以是资源的浪费。<br><img src="https://raw.githubusercontent.com/guduxingzheplus/blogPic/main/imgs/20230404091803.png" alt="20230404091803"></p><h4 id="1-1-2-如果客户端在回复第二次ack的时候丢失是否能正常建立整个过程？"><a href="#1-1-2-如果客户端在回复第二次ack的时候丢失是否能正常建立整个过程？" class="headerlink" title="1.1.2 如果客户端在回复第二次ack的时候丢失是否能正常建立整个过程？"></a>1.1.2 如果客户端在回复第二次ack的时候丢失是否能正常建立整个过程？</h4><p>可以的。因为在服务端收到syn之后，就进入了syn_received状态，整个状态中，收到客户端的数据时可以建立连接的，因为客户端的数据时在的头部带有ack的。</p><h3 id="1-2-双方同步初始始列号"><a href="#1-2-双方同步初始始列号" class="headerlink" title="1.2 双方同步初始始列号"></a>1.2 双方同步初始始列号</h3><p>序列号的作用</p><ul><li>避免重复数据</li><li>接收方可以根据数据包的序列号去接收</li><li>可以标识发送出的数据哪些是已经被对方收到的<br>可见，序列号作用非常大，只有一来一回这样的形式才能保证双方的初始序列号是被可靠的同步了。<br><img src="https://raw.githubusercontent.com/guduxingzheplus/blogPic/main/imgs/20230404093029.png" alt="20230404093029"><br>而两次握手只保证了一方的初始序列号能被对方成功接收，没办法保证双方的初始序列号都能被确认接收。</li></ul><h3 id="1-3-避免资源浪费"><a href="#1-3-避免资源浪费" class="headerlink" title="1.3 避免资源浪费"></a>1.3 避免资源浪费</h3><p>如果是两次握手，那么，服务端每次收到一个syn，由于不知道客户端是否收到了自己的ack+syn，所以无论如何都会建立连接，这样，如果客户端发送的syn在网络中阻塞了，那服务端会建立许多冗余的链接。<br><img src="https://raw.githubusercontent.com/guduxingzheplus/blogPic/main/imgs/20230404093626.png" alt="20230404093626"></p><h2 id="2-为什么每次建立TCP连接的时候都要求初始化序列号不一样？"><a href="#2-为什么每次建立TCP连接的时候都要求初始化序列号不一样？" class="headerlink" title="2. 为什么每次建立TCP连接的时候都要求初始化序列号不一样？"></a>2. 为什么每次建立TCP连接的时候都要求初始化序列号不一样？</h2><ul><li>防止历史报文被下一个相同的四元组使用</li><li>为了安全性，黑客攻击<br><img src="https://raw.githubusercontent.com/guduxingzheplus/blogPic/main/imgs/20230404094008.png" alt="20230404094008"><br><img src="https://raw.githubusercontent.com/guduxingzheplus/blogPic/main/imgs/20230404094014.png" alt="20230404094014"></li></ul><h2 id="3-既然IP层会分片，那么为什么TCP层还需要MSS呢？"><a href="#3-既然IP层会分片，那么为什么TCP层还需要MSS呢？" class="headerlink" title="3.既然IP层会分片，那么为什么TCP层还需要MSS呢？"></a>3.既然IP层会分片，那么为什么TCP层还需要MSS呢？</h2><ul><li>MTU：一个网络包的最大长度，最大1500</li><li>MSS：去除ip头，tcp头之后，一个网络包所能容纳的最大长度<br>因为IP层是不可靠传输，是不支持超时重传的。她的重传机制是依赖于TCP的，如果我们使用IP的默认分片，由于IP层不具备可靠通信的性质，所以一旦丢失某个数据分片，需要重传全部的数据分片。效率非常低下。</li></ul><p>经过TCP层分片后，即便重传也只是MSS为单位的，不是重传所有分片。</p><h2 id="4-第一次握手丢失了，会发生什么？"><a href="#4-第一次握手丢失了，会发生什么？" class="headerlink" title="4.第一次握手丢失了，会发生什么？"></a>4.第一次握手丢失了，会发生什么？</h2><p> 第一次握手丢失就是客户端在发送syn后迟迟得不到服务端的ack，那么根据操作系统的不同，客户端会重发1-5次的syn，每次重发后等待的时间是上一次的2倍，如果在最后一次等待后，仍然得不到相应，就关闭TCP。</p><h2 id="5-第二次握手丢失会发生什麽？"><a href="#5-第二次握手丢失会发生什麽？" class="headerlink" title="5.第二次握手丢失会发生什麽？"></a>5.第二次握手丢失会发生什麽？</h2><p> 第二次握手丢失会发生比较神奇的事情。</p><ul><li>服务端：由于迟迟得不到客户端的ack，服务端会不断重发syn+ack，直到服务端设置的上限。</li><li>客户端： 由于得不到服务端的确认，会不断重发syn，直到上限。</li></ul><h2 id="6-第三次握手丢失会发生什么？"><a href="#6-第三次握手丢失会发生什么？" class="headerlink" title="6.第三次握手丢失会发生什么？"></a>6.第三次握手丢失会发生什么？</h2><p>首先说明，<strong>ACK报文是不会重传的，当ACK丢失后，由对方重传对应的报文</strong><br>第三次握手对应的是第二次握手的SYN的确认报文，所以一旦丢失，服务端会不断的重传syn-ack报文。直到上限。<br><img src="https://raw.githubusercontent.com/guduxingzheplus/blogPic/main/imgs/20230404100326.png" alt="20230404100326"></p><h2 id="7-什么是SYN攻击，如何避免？"><a href="#7-什么是SYN攻击，如何避免？" class="headerlink" title="7.什么是SYN攻击，如何避免？"></a>7.什么是SYN攻击，如何避免？</h2><p>所谓SYN攻击就是攻击者使用许多ip来对服务器发送syn请求，然后造成服务器宕机。</p><ul><li>半连接队列：也称之为SYN队列</li><li>全连接队列：也称之为accept队列</li></ul><p><img src="https://raw.githubusercontent.com/guduxingzheplus/blogPic/main/imgs/20230404100728.png" alt="20230404100728"><br>正常流程：</p><ul><li>当服务端接收到客户端的 SYN 报文时，会创建一个半连接的对象，然后将其加入到内核的「 SYN 队列」；</li><li>接着发送 SYN + ACK 给客户端，等待客户端回应 ACK 报文；</li><li>服务端接收到 ACK 报文后，从「 SYN 队列」取出一个半连接对象，然后创建一个新的连接对象放入到「 Accept 队列」；</li><li>应用通过调用 accpet() socket 接口，从「 Accept 队列」取出连接对象。<br>不管是半连接队列还是全连接队列，都有最大长度限制，超过限制时，默认情况都会丢弃报文。</li></ul><p>syn攻击最常见的方式就是把半连接队列打满了，造成新来的数据直接被丢弃，客户端和服务端无法建立连接<br>解决方式：</p><ul><li>调大netdev_max_backlog</li><li>增大TCP半连接队列</li><li>开启tcp_syncookies</li><li><strong>减少SYN+ACK重传次数</strong></li></ul><h1 id="2-TCP断开连接"><a href="#2-TCP断开连接" class="headerlink" title="2. TCP断开连接"></a>2. TCP断开连接</h1><h2 id="2-1-四次挥手"><a href="#2-1-四次挥手" class="headerlink" title="2.1 四次挥手"></a>2.1 四次挥手</h2><p><img src="https://raw.githubusercontent.com/guduxingzheplus/blogPic/main/imgs/20230404101211.png" alt="20230404101211"></p><ul><li>客户端想关闭连接，会发送fin标志位为1 的数据报。进入fin_wait1状态。</li><li>服务端收到后会发送ack应答报文，并进入close_wait状态</li><li>客户端收到ack后进入fin_wait2状态</li><li>等服务端处理完数据后，向客户端发送fin后， 进入到last_ack状态。</li><li>客户端收到服务端的fin报文后，回一个ack，进入time_wait阶段</li><li>服务端收到了ack应答报文后，进入close状态，服务端完成连接关闭</li><li>客户端在2MSL后进入close状态，客户端完成连接关闭。</li></ul><p><strong>主动关闭连接才有time_wait转态</strong></p><h1 id="2-2-为什么挥手需要四次？"><a href="#2-2-为什么挥手需要四次？" class="headerlink" title="2.2 为什么挥手需要四次？"></a>2.2 为什么挥手需要四次？</h1><p>再来回顾下四次挥手双方发 FIN 包的过程，就能理解为什么需要四次了。</p><ul><li>关闭连接时，客户端向服务端发送 FIN 时，仅仅表示客户端不再发送数据了但是还能接收数据。</li><li>服务端收到客户端的 FIN 报文时，先回一个 ACK 应答报文，而服务端可能还有数据需要处理和发送，等服务端不再发送数据时，才发送 FIN 报文给客户端来表示同意现在关闭连接。</li></ul><h1 id="2-3-第一次挥手丢失会发生什么？"><a href="#2-3-第一次挥手丢失会发生什么？" class="headerlink" title="2.3 第一次挥手丢失会发生什么？"></a>2.3 第一次挥手丢失会发生什么？</h1><p>超过重试次数，直接关闭连接</p><h1 id="2-4-第二次挥手丢失会发生什么？"><a href="#2-4-第二次挥手丢失会发生什么？" class="headerlink" title="2.4 第二次挥手丢失会发生什么？"></a>2.4 第二次挥手丢失会发生什么？</h1><p>第二次的挥手报文时服务端发送的ack报文，而我们知道ack报文时不会重传的，所以会让客户端不断重发fin报文，客户端超过最大连接次数，服务端过了最大等待时长，都会关闭。</p><p>对于 close 函数关闭的连接，由于无法再发送和接收数据，所以FIN_WAIT2 状态不可以持续太久，而 tcp_fin_timeout 控制了这个状态下连接的持续时长，默认值是 60 秒。</p><p>但是注意，如果主动关闭方使用 shutdown 函数关闭连接，指定了只关闭发送方向，而接收方向并没有关闭，那么意味着主动关闭方还是可以接收数据的。</p><p>此时，如果主动关闭方一直没收到第三次挥手，那么主动关闭方的连接将会一直处于 FIN_WAIT2 状态（tcp_fin_timeout 无法控制 shutdown 关闭的连接）。如下图：<img src="https://raw.githubusercontent.com/guduxingzheplus/blogPic/main/imgs/20230404104634.png" alt="20230404104634"><br><img src="https://raw.githubusercontent.com/guduxingzheplus/blogPic/main/imgs/20230404104648.png" alt="20230404104648"></p><h1 id="2-5-第三次挥手丢失了，会发生什么？"><a href="#2-5-第三次挥手丢失了，会发生什么？" class="headerlink" title="2.5 第三次挥手丢失了，会发生什么？"></a>2.5 第三次挥手丢失了，会发生什么？</h1><p>当服务端（被动关闭方）收到客户端（主动关闭方）的 FIN 报文后，内核会自动回复 ACK，同时连接处于 CLOSE_WAIT 状态，顾名思义，它表示等待应用进程调用 close 函数关闭连接。</p><p>此时，内核是没有权利替代进程关闭连接，必须由进程主动调用 close 函数来触发服务端发送 FIN 报文。</p><p>服务端处于 CLOSE_WAIT 状态时，调用了 close 函数，内核就会发出 FIN 报文，同时连接进入 LAST_ACK 状态，等待客户端返回 ACK 来确认连接关闭。</p><p>如果迟迟收不到这个 ACK，服务端就会重发 FIN 报文，重发次数仍然由 tcp_orphan_retries 参数控制，这与客户端重发 FIN 报文的重传次数控制方式是一样的。</p><p>具体过程：</p><ul><li>当服务端重传第三次挥手报文的次数达到了 3 次后，由于 tcp_orphan_retries 为 3，达到了重传最大次数，于是再等待一段时间（时间为上一次超时时间的 2 倍），如果还是没能收到客户端的第四次挥手（ACK报文），那么服务端就会断开连接。</li><li>客户端因为是通过 close 函数关闭连接的，处于 FIN_WAIT_2 状态是有时长限制的，如果 tcp_fin_timeout 时间内还是没能收到服务端的第三次挥手（FIN 报文），那么客户端就会断开连接。</li></ul><h1 id="2-6-第四次挥手丢失了会发生什麽？"><a href="#2-6-第四次挥手丢失了会发生什麽？" class="headerlink" title="2.6 第四次挥手丢失了会发生什麽？"></a>2.6 第四次挥手丢失了会发生什麽？</h1><p>当客户端收到服务端的第三次挥手的 FIN 报文后，就会回 ACK 报文，也就是第四次挥手，此时客户端连接进入 TIME_WAIT 状态。</p><p>在 Linux 系统，TIME_WAIT 状态会持续 2MSL 后才会进入关闭状态。</p><p>然后，服务端（被动关闭方）没有收到 ACK 报文前，还是处于 LAST_ACK 状态。</p><p>如果第四次挥手的 ACK 报文没有到达服务端，服务端就会重发 FIN 报文，重发次数仍然由前面介绍过的 tcp_orphan_retries 参数控制。</p><p>当服务端重传第三次挥手报文达到 2 时，由于 tcp_orphan_retries 为 2， 达到了最大重传次数，于是再等待一段时间（时间为上一次超时时间的 2 倍），如果还是没能收到客户端的第四次挥手（ACK 报文），那么服务端就会断开连接。<br>客户端在收到第三次挥手后，就会进入 TIME_WAIT 状态，开启时长为 2MSL 的定时器，如果途中再次收到第三次挥手（FIN 报文）后，就会重置定时器，当等待 2MSL 时长后，客户端就会断开连接。<br><img src="https://raw.githubusercontent.com/guduxingzheplus/blogPic/main/imgs/20230404104921.png" alt="20230404104921"></p><h1 id="3-为什么-TIME-WAIT-等待的时间是-2MSL？"><a href="#3-为什么-TIME-WAIT-等待的时间是-2MSL？" class="headerlink" title="3. 为什么 TIME_WAIT 等待的时间是 2MSL？"></a>3. 为什么 TIME_WAIT 等待的时间是 2MSL？</h1><ul><li>MSL： 报文最大生存时间，他是任何网络上的报文的最大存在的时长。超过这个时长的报文将会被丢弃。</li><li>TTL：是IP数据报可以经过的最大的路由数，每经过一个路由，这个值就减一，为0则被丢弃。</li></ul><p>默认的是2MSL的目的也很好理解，即数据报在网络中一来一回所需要的时间，其实是默认允许数据丢失一次。比如一个ACK在MSL内丢失，这样被动方重发的FIN会在第二个MSL内到达。</p><p>为什么不使用4MSL，因为没必要，即便是丢包率在百分制一的网络，连续两次丢包的概率也不过是万分之一。重传比解决这个问题所需要的代价小很多。</p><h1 id="4-为什么需要TIME-WAIT状态？"><a href="#4-为什么需要TIME-WAIT状态？" class="headerlink" title="4.为什么需要TIME_WAIT状态？"></a>4.为什么需要TIME_WAIT状态？</h1><p><strong>主动发起连接关闭的一方才有time_wait状态</strong><br>原因：</p><ul><li>防止历史连接中的数据，被后面相同的四元组锁接受</li><li>保证被动关闭的一方能正确的关闭</li></ul><h2 id="4-1-防止历史连接中的数据，被后面相同的四元组锁接受"><a href="#4-1-防止历史连接中的数据，被后面相同的四元组锁接受" class="headerlink" title="4.1 防止历史连接中的数据，被后面相同的四元组锁接受"></a>4.1 防止历史连接中的数据，被后面相同的四元组锁接受</h2><p><img src="https://raw.githubusercontent.com/guduxingzheplus/blogPic/main/imgs/20230404110507.png" alt="20230404110507"></p><ul><li>服务端在关闭连接之前发送的 SEQ &#x3D; 301 报文，被网络延迟了。</li><li>接着，服务端以相同的四元组重新打开了新连接，前面被延迟的 SEQ &#x3D; 301 这时抵达了客户端，而且该数据报文的序列号刚好在客户端接收窗口内，因此客户端会正常接收这个数据报文，但是这个数据报文是上一个连接残留下来的，这样就产生数据错乱等严重的问题。</li></ul><p>为了防止历史连接中的数据，被后面相同四元组的连接错误的接收，因此 TCP 设计了 TIME_WAIT 状态，状态会持续 2MSL 时长，这个时间足以让两个方向上的数据包都被丢弃，使得原来连接的数据包在网络中都自然消失，再出现的数据包一定都是新建立连接所产生的。</p><h2 id="4-2-保证连接被动关闭的一方可以被正确的关闭"><a href="#4-2-保证连接被动关闭的一方可以被正确的关闭" class="headerlink" title="4.2 保证连接被动关闭的一方可以被正确的关闭"></a>4.2 保证连接被动关闭的一方可以被正确的关闭</h2><p>在客户端发送第四次挥手后，如果没有TIME_WAIT那么就会立即关闭，如果客户端发送的ACK报文丢失了，那么服务端会重发FIN报文，此时由于客户端已经关闭了，所以客户端会回复一个RST报文，这就导致服务端以为出现了错误。为了防止这种情况，客户端必须等待足够长的时间，确保服务端能收到ack，如果服务端没有收到ACK，那么就会触发TCP重传机制，这样服务端会重发一个FIN，这样一来一回正好2MSL。</p><h1 id="5-TIME-WAIT-过多有什么危害"><a href="#5-TIME-WAIT-过多有什么危害" class="headerlink" title="5. TIME_WAIT 过多有什么危害"></a>5. TIME_WAIT 过多有什么危害</h1><ul><li><p>占用系统资源，比如文件描述符，内存资源</p></li><li><p>占用端口资源</p></li><li><p>对于客户端：占满了所有的端口资源，那么久无法对目的ip+目的port相同的进行服务发起连接了。但是被使用的端口号是可以继续对另一个服务端发起连接的，因为是四元组的形式，只要目的地址不同，就可以。</p></li><li><p>对于服务端： 由于只监听一个端口，所以只是会增加CPU的等系统资源的负载。</p></li></ul><h1 id="6-服务端大量出现TIME-WAIT的原因"><a href="#6-服务端大量出现TIME-WAIT的原因" class="headerlink" title="6. 服务端大量出现TIME_WAIT的原因"></a>6. 服务端大量出现TIME_WAIT的原因</h1>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> 计算机网络 </tag>
            
            <tag> 计网 </tag>
            
            <tag> TCP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络常见面试题--基础</title>
      <link href="/2023/04/03/ji-suan-ji-wang-luo-chang-jian-mian-shi-ti/"/>
      <url>/2023/04/03/ji-suan-ji-wang-luo-chang-jian-mian-shi-ti/</url>
      
        <content type="html"><![CDATA[<h1 id="1-基础"><a href="#1-基础" class="headerlink" title="1. 基础"></a>1. 基础</h1><hr><h2 id="1-1-发送网络数据的时候，涉及几次内存拷贝操作？"><a href="#1-1-发送网络数据的时候，涉及几次内存拷贝操作？" class="headerlink" title="1.1 发送网络数据的时候，涉及几次内存拷贝操作？"></a>1.1 发送网络数据的时候，涉及几次内存拷贝操作？</h2><p>第一次，调用发送数据的系统调用的时候，内核会申请一个内核态的 sk_buff 内存，将用户待发送的数据拷贝到 sk_buff 内存，并将其加入到发送缓冲区。</p><p>第二次，在使用 TCP 传输协议的情况下，从传输层进入网络层的时候，每一个 sk_buff 都会被克隆一个新的副本出来。副本 sk_buff 会被送往网络层，等它发送完的时候就会释放掉，然后原始的 sk_buff 还保留在传输层，目的是为了实现 TCP 的可靠传输，等收到这个数据包的 ACK 时，才会释放原始的 sk_buff 。</p><p>第三次，当 IP 层发现 sk_buff 大于 MTU 时才需要进行。会再申请额外的 sk_buff，并将原来的 sk_buff 拷贝为多个小的 sk_buff。</p><h1 id="2-Linux-发送网络包的流程"><a href="#2-Linux-发送网络包的流程" class="headerlink" title="2. Linux 发送网络包的流程"></a>2. Linux 发送网络包的流程</h1><hr><p><img src="https://raw.githubusercontent.com/guduxingzheplus/blogPic/main/imgs/20230403100138.png" alt="20230403100138"><br>先，应用程序会调用 Socket 发送数据包的接口，由于这个是系统调用，所以会从用户态陷入到内核态中的 Socket 层，内核会申请一个内核态的 sk_buff 内存，将用户待发送的数据拷贝到 sk_buff 内存，并将其加入到发送缓冲区。</p><p>接下来，网络协议栈从 Socket 发送缓冲区中取出 sk_buff，并按照 TCP&#x2F;IP 协议栈从上到下逐层处理。</p><p>如果使用的是 TCP 传输协议发送数据，那么先拷贝一个新的 sk_buff 副本 ，这是因为 sk_buff 后续在调用网络层，最后到达网卡发送完成的时候，这个 sk_buff 会被释放掉。而 TCP 协议是支持丢失重传的，在收到对方的 ACK 之前，这个 sk_buff 不能被删除。所以内核的做法就是每次调用网卡发送的时候，实际上传递出去的是 sk_buff 的一个拷贝，等收到 ACK 再真正删除。</p><p>接着，对 sk_buff 填充 TCP 头。这里提一下，sk_buff 可以表示各个层的数据包，在应用层数据包叫 data，在 TCP 层我们称为 segment，在 IP 层我们叫 packet，在数据链路层称为 frame。</p><p>你可能会好奇，为什么全部数据包只用一个结构体来描述呢？协议栈采用的是分层结构，上层向下层传递数据时需要增加包头，下层向上层数据时又需要去掉包头，如果每一层都用一个结构体，那在层之间传递数据的时候，就要发生多次拷贝，这将大大降低 CPU 效率。</p><p>于是，为了在层级之间传递数据时，不发生拷贝，只用 sk_buff 一个结构体来描述所有的网络包，那它是如何做到的呢？是通过调整 sk_buff 中 data 的指针，比如：</p><p>当接收报文时，从网卡驱动开始，通过协议栈层层往上传送数据报，通过增加 skb-&gt;data 的值，来逐步剥离协议首部。<br>当要发送报文时，创建 sk_buff 结构体，数据缓存区的头部预留足够的空间，用来填充各层首部，在经过各下层协议时，通过减少 skb-&gt;data 的值来增加协议首部。<br>你可以从下面这张图看到，当发送报文时，data 指针的移动过程。<br><img src="https://raw.githubusercontent.com/guduxingzheplus/blogPic/main/imgs/20230403100107.png" alt="20230403100107"></p><h1 id="3-Linux-接收网络包的流程"><a href="#3-Linux-接收网络包的流程" class="headerlink" title="3. Linux 接收网络包的流程"></a>3. Linux 接收网络包的流程</h1><hr><p>网卡是计算机里的一个硬件，专门负责接收和发送网络包，当网卡接收到一个网络包后，会通过 DMA 技术，将网络包写入到指定的内存地址，也就是写入到 Ring Buffer ，这个是一个环形缓冲区，接着就会告诉操作系统这个网络包已经到达。</p><p>那应该怎么告诉操作系统这个网络包已经到达了呢？</p><p>最简单的一种方式就是触发中断，也就是每当网卡收到一个网络包，就触发一个中断告诉操作系统。</p><p>但是，这存在一个问题，在高性能网络场景下，网络包的数量会非常多，那么就会触发非常多的中断，要知道当 CPU 收到了中断，就会停下手里的事情，而去处理这些网络包，处理完毕后，才会回去继续其他事情，那么频繁地触发中断，则会导致 CPU 一直没完没了的处理中断，而导致其他任务可能无法继续前进，从而影响系统的整体效率。</p><p>所以为了解决频繁中断带来的性能开销，Linux 内核在 2.6 版本中引入了 NAPI 机制，它是混合「中断和轮询」的方式来接收网络包，它的核心概念就是不采用中断的方式读取数据，而是首先采用中断唤醒数据接收的服务程序，然后 poll 的方法来轮询数据。</p><p>因此，当有网络包到达时，会通过 DMA 技术，将网络包写入到指定的内存地址，接着网卡向 CPU 发起硬件中断，当 CPU 收到硬件中断请求后，根据中断表，调用已经注册的中断处理函数。</p><p>硬件中断处理函数会做如下的事情：</p><p>需要先「暂时屏蔽中断」，表示已经知道内存中有数据了，告诉网卡下次再收到数据包直接写内存就可以了，不要再通知 CPU 了，这样可以提高效率，避免 CPU 不停的被中断。<br>接着，发起「软中断」，然后恢复刚才屏蔽的中断。<br>至此，硬件中断处理函数的工作就已经完成。</p><p>硬件中断处理函数做的事情很少，主要耗时的工作都交给软中断处理函数了。</p><p>软中断的处理</p><p>内核中的 ksoftirqd 线程专门负责软中断的处理，当 ksoftirqd 内核线程收到软中断后，就会来轮询处理数据。</p><p>ksoftirqd 线程会从 Ring Buffer 中获取一个数据帧，用 sk_buff 表示，从而可以作为一个网络包交给网络协议栈进行逐层处理。</p><p>网络协议栈</p><p>首先，会先进入到网络接口层，在这一层会检查报文的合法性，如果不合法则丢弃，合法则会找出该网络包的上层协议的类型，比如是 IPv4，还是 IPv6，接着再去掉帧头和帧尾，然后交给网络层。</p><p>到了网络层，则取出 IP 包，判断网络包下一步的走向，比如是交给上层处理还是转发出去。当确认这个网络包要发送给本机后，就会从 IP 头里看看上一层协议的类型是 TCP 还是 UDP，接着去掉 IP 头，然后交给传输层。</p><p>传输层取出 TCP 头或 UDP 头，根据四元组「源 IP、源端口、目的 IP、目的端口」 作为标识，找出对应的 Socket，并把数据放到 Socket 的接收缓冲区。</p><p>最后，应用层程序调用 Socket 接口，将内核的 Socket 接收缓冲区的数据「拷贝」到应用层的缓冲区，然后唤醒用户进程。</p><p>至此，一个网络包的接收过程就已经结束了，你也可以从下图左边部分看到网络包接收的流程，右边部分刚好反过来，它是网络包发送的流程。</p><h1 id="4-TCP-与-UDP-的区别（重要）"><a href="#4-TCP-与-UDP-的区别（重要）" class="headerlink" title="4. TCP 与 UDP 的区别（重要）"></a>4. TCP 与 UDP 的区别（重要）</h1><hr><ul><li>是否面向连接 ：UDP 在传送数据之前不需要先建立连接。而 TCP 提供面向连接的服务，在传送数据之前必须先建立连接，数据传送结束后要释放连接。</li><li>是否是可靠传输：远地主机在收到 UDP 报文后，不需要给出任何确认，并且不保证数据不丢失，不保证是否顺序到达。TCP 提供可靠的传输服务，TCP 在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制。通过 TCP 连接传输的数据，无差错、不丢失、不重复、并且按序到达。</li><li>是否有状态 ：这个和上面的“是否可靠传输”相对应。TCP 传输是有状态的，这个有状态说的是 TCP 会去记录自己发送消息的状态比如消息是否发送了、是否被接收了等等。为此 ，TCP 需要维持复杂的连接状态表。而 UDP 是无状态服务，简单来说就是不管发出去之后的事情了（这很渣男！）。</li><li>传输效率 ：由于使用 TCP 进行传输的时候多了连接、确认、重传等机制，所以 TCP 的传输效率要比 UDP 低很多。</li><li>传输形式 ： TCP 是面向字节流的，UDP 是面向报文的。</li><li>首部开销 ：TCP 首部开销（20 ～ 60 字节）比 UDP 首部开销（8 字节）要大。</li><li>是否提供广播或多播服务 ：TCP 只支持点对点通信，UDP 支持一对一、一对多、多对一、多对多；</li></ul><p><img src="https://raw.githubusercontent.com/guduxingzheplus/blogPic/main/imgs/20230403100531.png" alt="20230403100531"></p><h2 id="4-1-HTTP-基于-TCP-还是-UDP？"><a href="#4-1-HTTP-基于-TCP-还是-UDP？" class="headerlink" title="4.1 HTTP 基于 TCP 还是 UDP？"></a>4.1 HTTP 基于 TCP 还是 UDP？</h2><p>HTTP 3.0 之前是基于 TCP 协议的，而 HTTP3.0 将弃用 TCP，改用 基于 UDP 的 QUIC 协议 。此变化主要为了解决 HTTP&#x2F;2 中存在的队头阻塞问题。由于 HTTP&#x2F;2 在单个 TCP 连接上使用了多路复用，受到 TCP 拥塞控制的影响，少量的丢包就可能导致整个 TCP 连接上的所有流被阻塞。</p><h2 id="4-2-使用-TCP-的协议有哪些-使用-UDP-的协议有哪些"><a href="#4-2-使用-TCP-的协议有哪些-使用-UDP-的协议有哪些" class="headerlink" title="4.2 使用 TCP 的协议有哪些?使用 UDP 的协议有哪些?"></a>4.2 使用 TCP 的协议有哪些?使用 UDP 的协议有哪些?</h2><p>运行于 TCP 协议之上的协议 ：</p><ol><li>HTTP 协议 ：超文本传输协议（HTTP，HyperText Transfer Protocol)主要是为 Web 浏览器与 Web 服务器之间的通信而设计的。当我们使用浏览器浏览网页的时候，我们网页就是通过 HTTP 请求进行加载的。</li><li>HTTPS 协议 ：更安全的超文本传输协议(HTTPS,Hypertext Transfer Protocol Secure)，身披 SSL 外衣的 HTTP 协议</li><li>FTP 协议：文件传输协议 FTP（File Transfer Protocol），提供文件传输服务，基于 TCP 实现可靠的传输。使用 FTP 传输文件的好处是可以屏蔽操作系统和文件存储方式。</li><li>SMTP 协议：简单邮件传输协议（SMTP，Simple Mail Transfer Protocol）的缩写，基于 TCP 协议，用来发送电子邮件。注意 ⚠️：接受邮件的协议不是 SMTP 而是 POP3 协议。</li><li>POP3&#x2F;IMAP 协议： POP3 和 IMAP 两者都是负责邮件接收的协议。</li><li>Telnet 协议：远程登陆协议，通过一个终端登陆到其他服务器。被一种称为 SSH 的非常安全的协议所取代。</li><li>SSH 协议 : SSH（ Secure Shell）是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题。SSH 建立在可靠的传输协议 TCP 之上。</li><li>……</li></ol><p><strong>运行于 UDP 协议之上的协议 ：</strong></p><ol><li>DHCP 协议：动态主机配置协议，动态配置 IP </li><li>地址DNS ： 域名系统（DNS，Domain Name System）将人类可读的域名 (例如，<a href="http://www.baidu.com/">www.baidu.com</a>) 转换为机器可读的 IP 地址 (例如，220.181.38.148)。 我们可以将其理解为专为互联网设计的电话薄。实际上 DNS 同时支持 UDP 和 TCP 协议。</li></ol><h1 id="5-TCP-三次握手和四次挥手（传输层）"><a href="#5-TCP-三次握手和四次挥手（传输层）" class="headerlink" title="5. TCP 三次握手和四次挥手（传输层）"></a>5. TCP 三次握手和四次挥手（传输层）</h1><p><a href="https://javaguide.cn/cs-basics/network/tcp-connection-and-disconnection.html#%E6%96%AD%E5%BC%80%E8%BF%9E%E6%8E%A5-tcp-%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B">https://javaguide.cn/cs-basics/network/tcp-connection-and-disconnection.html#%E6%96%AD%E5%BC%80%E8%BF%9E%E6%8E%A5-tcp-%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B</a></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> 计算机网络 </tag>
            
            <tag> 计网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Springboot 自动装配简介</title>
      <link href="/2023/04/03/springboot-zi-dong-zhuang-pei-jian-jie/"/>
      <url>/2023/04/03/springboot-zi-dong-zhuang-pei-jian-jie/</url>
      
        <content type="html"><![CDATA[<h1 id="1-什么是springBoot自动装配？"><a href="#1-什么是springBoot自动装配？" class="headerlink" title="1. 什么是springBoot自动装配？"></a>1. 什么是springBoot自动装配？</h1><p>实际上自动装配在Spring Framework中早就实现了这个功能。spring boot只是在这个基础上，通过spi的方式，做了进一步优化。</p><blockquote><p>springBoot自己定义了一套接口规范，在启动时会去扫描外部引用的jar包中的META-INF&#x2F;spring.factories文件，将文件中的配置信息的类型信息加载到spring容器中，并执行类中定义的各种操作。对于外部jar来说，只需要按照springboot定义的标准，就能将自己的功能装置加载进springboot。</p></blockquote><p>没有spring boot的情况下，我们需要引入第三方依赖，需要手动配置，但是springboot里，直接引入一个strarter即可。比如想在项目主使用redis，那么引入对应的starter就好了</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-data-redis<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>然后再引入少量的注解和一些简单配置就行了。<br>自动装配可以理解为： <strong>通过注解或者一些简单配置就能在springboot的帮助下，实现某块功能。</strong>  </p><h1 id="2-springBoot是如何实现自动装配的"><a href="#2-springBoot是如何实现自动装配的" class="headerlink" title="2. springBoot是如何实现自动装配的"></a>2. springBoot是如何实现自动装配的</h1><p>核心注解就是@SpringBootApplication，源代码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token class-name">ElementType</span><span class="token punctuation">.</span><span class="token constant">TYPE</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span><span class="token class-name">RetentionPolicy</span><span class="token punctuation">.</span><span class="token constant">RUNTIME</span><span class="token punctuation">)</span><span class="token annotation punctuation">@Documented</span><span class="token annotation punctuation">@Inherited</span><span class="token generics"><span class="token punctuation">&lt;</span>1<span class="token punctuation">.</span><span class="token punctuation">></span></span><span class="token annotation punctuation">@SpringBootConfiguration</span><span class="token generics"><span class="token punctuation">&lt;</span>2<span class="token punctuation">.</span><span class="token punctuation">></span></span><span class="token annotation punctuation">@ComponentScan</span><span class="token generics"><span class="token punctuation">&lt;</span>3<span class="token punctuation">.</span><span class="token punctuation">></span></span><span class="token annotation punctuation">@EnableAutoConfiguration</span><span class="token keyword">public</span> <span class="token annotation punctuation">@interface</span> <span class="token class-name">SpringBootApplication</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token class-name">ElementType</span><span class="token punctuation">.</span><span class="token constant">TYPE</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span><span class="token class-name">RetentionPolicy</span><span class="token punctuation">.</span><span class="token constant">RUNTIME</span><span class="token punctuation">)</span><span class="token annotation punctuation">@Documented</span><span class="token annotation punctuation">@Configuration</span> <span class="token comment">//实际上它也是一个配置类</span><span class="token keyword">public</span> <span class="token annotation punctuation">@interface</span> <span class="token class-name">SpringBootConfiguration</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，@SpringBootApplication可以理解为@SpringBootConfiguration，@ComponentScan，@EnableAutoConfiguration三者的组合。<br>作用如下：  </p><ul><li>@EnableAutoConfiguration：开启自动装配</li><li>@Configuration: 允许上下文中注册额外的bean或导入其他配置类。</li><li>@ComponentScan： 扫描被@Component修饰的bean，默认会扫描启动类所在的包下的所有类，可以自定义不扫描的某些bean，使用 @ComponentScan（excludeFilters &#x3D; {@Filter(type &#x3D; FilterType.CUSTOM, classes &#x3D; TypeExcluderFilter.class),@Filter(type &#x3D; FilterType.CUSTOM, classes &#x3D; AutoConfigurationExcludeFilter.class)}<br>容器中将排除TypeExcludeFilter和AutoConfigurationExcludeFilter。</li></ul><h2 id="2-1-EnableAutoConfiguration-实现自动装配的核心注解"><a href="#2-1-EnableAutoConfiguration-实现自动装配的核心注解" class="headerlink" title="2.1@EnableAutoConfiguration:实现自动装配的核心注解"></a>2.1@EnableAutoConfiguration:实现自动装配的核心注解</h2><p>EnableAutoConfiguration 只是一个简单地注解，自动装配核心功能的实现实际是通过 AutoConfigurationImportSelector类。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token class-name">ElementType</span><span class="token punctuation">.</span><span class="token constant">TYPE</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span><span class="token class-name">RetentionPolicy</span><span class="token punctuation">.</span><span class="token constant">RUNTIME</span><span class="token punctuation">)</span><span class="token annotation punctuation">@Documented</span><span class="token annotation punctuation">@Inherited</span><span class="token annotation punctuation">@AutoConfigurationPackage</span> <span class="token comment">//作用：将main包下的所有组件注册到容器中</span><span class="token annotation punctuation">@Import</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token class-name">AutoConfigurationImportSelector</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span> <span class="token comment">//加载自动装配类 xxxAutoconfiguration</span><span class="token keyword">public</span> <span class="token annotation punctuation">@interface</span> <span class="token class-name">EnableAutoConfiguration</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">String</span> <span class="token constant">ENABLED_OVERRIDE_PROPERTY</span> <span class="token operator">=</span> <span class="token string">"spring.boot.enableautoconfiguration"</span><span class="token punctuation">;</span>    <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">exclude</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">excludeName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们现在重点分析下AutoConfigurationImportSelector 类到底做了什么？</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AutoConfigurationImportSelector</span> <span class="token keyword">implements</span> <span class="token class-name">DeferredImportSelector</span><span class="token punctuation">,</span> <span class="token class-name">BeanClassLoaderAware</span><span class="token punctuation">,</span> <span class="token class-name">ResourceLoaderAware</span><span class="token punctuation">,</span> <span class="token class-name">BeanFactoryAware</span><span class="token punctuation">,</span> <span class="token class-name">EnvironmentAware</span><span class="token punctuation">,</span> <span class="token class-name">Ordered</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">DeferredImportSelector</span> <span class="token keyword">extends</span> <span class="token class-name">ImportSelector</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">ImportSelector</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">selectImports</span><span class="token punctuation">(</span><span class="token class-name">AnnotationMetadata</span> var1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看出，AutoConfigurationImportSelector 类实现了 ImportSelector接口，也就实现了这个接口中的 selectImports方法，该方法主要用于获取所有符合条件的类的全限定类名，这些类需要被加载到 IoC 容器中。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token constant">NO_IMPORTS</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">selectImports</span><span class="token punctuation">(</span><span class="token class-name">AnnotationMetadata</span> annotationMetadata<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// &lt;1>.判断自动装配开关是否打开</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">isEnabled</span><span class="token punctuation">(</span>annotationMetadata<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> <span class="token constant">NO_IMPORTS</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>          <span class="token comment">//&lt;2>.获取所有需要装配的bean</span>            <span class="token class-name">AutoConfigurationMetadata</span> autoConfigurationMetadata <span class="token operator">=</span> <span class="token class-name">AutoConfigurationMetadataLoader</span><span class="token punctuation">.</span><span class="token function">loadMetadata</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>beanClassLoader<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">AutoConfigurationImportSelector<span class="token punctuation">.</span>AutoConfigurationEntry</span> autoConfigurationEntry <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getAutoConfigurationEntry</span><span class="token punctuation">(</span>autoConfigurationMetadata<span class="token punctuation">,</span> annotationMetadata<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token class-name">StringUtils</span><span class="token punctuation">.</span><span class="token function">toStringArray</span><span class="token punctuation">(</span>autoConfigurationEntry<span class="token punctuation">.</span><span class="token function">getConfigurations</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里我们需要重点关注一下getAutoConfigurationEntry()方法，这个方法主要负责加载自动配置类的。<br><img src="https://raw.githubusercontent.com/guduxingzheplus/blogPic/main/imgs/20230403084719.png" alt="20230403084719"></p><p>现在我们结合getAutoConfigurationEntry()的源码来详细分析一下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">AutoConfigurationEntry</span> <span class="token constant">EMPTY_ENTRY</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AutoConfigurationEntry</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">AutoConfigurationEntry</span> <span class="token function">getAutoConfigurationEntry</span><span class="token punctuation">(</span><span class="token class-name">AutoConfigurationMetadata</span> autoConfigurationMetadata<span class="token punctuation">,</span> <span class="token class-name">AnnotationMetadata</span> annotationMetadata<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">//&lt;1>.</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">isEnabled</span><span class="token punctuation">(</span>annotationMetadata<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> <span class="token constant">EMPTY_ENTRY</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            <span class="token comment">//&lt;2>.</span>            <span class="token class-name">AnnotationAttributes</span> attributes <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getAttributes</span><span class="token punctuation">(</span>annotationMetadata<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">//&lt;3>.</span>            <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> configurations <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getCandidateConfigurations</span><span class="token punctuation">(</span>annotationMetadata<span class="token punctuation">,</span> attributes<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">//&lt;4>.</span>            configurations <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">removeDuplicates</span><span class="token punctuation">(</span>configurations<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> exclusions <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getExclusions</span><span class="token punctuation">(</span>annotationMetadata<span class="token punctuation">,</span> attributes<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">checkExcludedClasses</span><span class="token punctuation">(</span>configurations<span class="token punctuation">,</span> exclusions<span class="token punctuation">)</span><span class="token punctuation">;</span>            configurations<span class="token punctuation">.</span><span class="token function">removeAll</span><span class="token punctuation">(</span>exclusions<span class="token punctuation">)</span><span class="token punctuation">;</span>            configurations <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>configurations<span class="token punctuation">,</span> autoConfigurationMetadata<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">fireAutoConfigurationImportEvents</span><span class="token punctuation">(</span>configurations<span class="token punctuation">,</span> exclusions<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">AutoConfigurationImportSelector<span class="token punctuation">.</span>AutoConfigurationEntry</span><span class="token punctuation">(</span>configurations<span class="token punctuation">,</span> exclusions<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>第 1 步:<br>判断自动装配开关是否打开。默认spring.boot.enableautoconfiguration&#x3D;true，可在 application.properties 或 application.yml 中设置<br><img src="https://raw.githubusercontent.com/guduxingzheplus/blogPic/main/imgs/20230403084903.png" alt="20230403084903"></p><p>第 2 步 ：</p><p>用于获取EnableAutoConfiguration注解中的 exclude 和 excludeName。<br><img src="https://raw.githubusercontent.com/guduxingzheplus/blogPic/main/imgs/20230403084927.png" alt="20230403084927"></p><p>第 3 步:</p><p>获取需要自动装配的所有配置类，读取META-INF&#x2F;spring.factories</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">spring-boot/spring-boot-project/spring-boot-autoconfigure/src/main/resources/META-INF/spring.factories<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/guduxingzheplus/blogPic/main/imgs/20230403085022.png" alt="20230403085022"></p><p>从下图可以看到这个文件的配置内容都被我们读取到了。XXXAutoConfiguration的作用就是按需加载组件。<br><img src="https://raw.githubusercontent.com/guduxingzheplus/blogPic/main/imgs/20230403085048.png" alt="20230403085048"><br>不光是这个依赖下的META-INF&#x2F;spring.factories被读取到，所有 Spring Boot Starter 下的META-INF&#x2F;spring.factories都会被读取到。所以，你可以清楚滴看到， druid 数据库连接池的 Spring Boot Starter 就创建了META-INF&#x2F;spring.factories文件。<br><img src="https://raw.githubusercontent.com/guduxingzheplus/blogPic/main/imgs/20230403090605.png" alt="20230403090605"></p><p>第 4 步 ：<br>到这里可能面试官会问你:“spring.factories中这么多配置，每次启动都要全部加载么？”。很明显，这是不现实的。我们 debug 到后面你会发现，configurations 的值变小了。</p><p>因为，这一步有经历了一遍筛选，@ConditionalOnXXX 中的所有条件都满足，该类才会生效。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span><span class="token comment">// 检查相关的类：RabbitTemplate 和 Channel是否存在</span><span class="token comment">// 存在才会加载</span><span class="token annotation punctuation">@ConditionalOnClass</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span> <span class="token class-name">RabbitTemplate</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> <span class="token class-name">Channel</span><span class="token punctuation">.</span><span class="token keyword">class</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token annotation punctuation">@EnableConfigurationProperties</span><span class="token punctuation">(</span><span class="token class-name">RabbitProperties</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token annotation punctuation">@Import</span><span class="token punctuation">(</span><span class="token class-name">RabbitAnnotationDrivenConfiguration</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RabbitAutoConfiguration</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> spring面试 </category>
          
          <category> springBoot原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> springboot </tag>
            
            <tag> 自动装配 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Trie 前缀树（字典树）</title>
      <link href="/2023/04/02/trie-qian-zhui-shu/"/>
      <url>/2023/04/02/trie-qian-zhui-shu/</url>
      
        <content type="html"><![CDATA[<h1 id="1-什么是前缀树？"><a href="#1-什么是前缀树？" class="headerlink" title="1. 什么是前缀树？"></a>1. 什么是前缀树？</h1><p>字典树是一种树形结构，典型应用是用于统计，排序和大量字符串的索引工作，比如查询要插入的数据是否已经存在于数据结构之中，查询已有数据中是否有以要插入的字段开头的数据。</p><p>他的图形化表示如下所示：<br><img src="https://raw.githubusercontent.com/guduxingzheplus/blogPic/main/imgs/20230402182559.png" alt="20230402182559"></p><p><a  href ="https://www.bilibili.com/video/BV1yA4y1Z74t/?spm_id_from=333.337.search-card.all.click&vd_source=ecd5c866d6cf8dc2ca7670889ecca2f4">图片出处</a></p><p>从图中我们可以看到，其实前缀树就是不断地将具有相同前缀的数据结构合并。比如对于car和cat，他们同样的是“ca”，所以在左侧第二颗前缀树中，最后一层有两个分叉。前缀树中，边表示字符，同时每个节点会额外添加一个数组，表示以节点P结尾的单词的插入次数。这里注意，节点的序号没有什么实际的意义。</p><h1 id="2-前缀树定义题"><a href="#2-前缀树定义题" class="headerlink" title="2. 前缀树定义题"></a>2. 前缀树定义题</h1><p>力扣上的前缀树定义题如下：<br><a  href ="https://leetcode.cn/problems/implement-trie-prefix-tree/description/">208. 实现 Trie (前缀树)</a><br>，简单的题目描述如下：</p><blockquote><p>Trie（发音类似 “try”）或者说 前缀树 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补完和拼写检查。</p></blockquote><p>请你实现 Trie 类：</p><ul><li>Trie() 初始化前缀树对象。</li><li>void insert(String word) 向前缀树中插入字符串 word 。</li><li>boolean search(String word) 如果字符串 word 在前缀树中，返回 true（即，在检索之前已经插入）；否则，返回 false 。</li><li>boolean startsWith(String prefix) 如果之前已经插入的字符串 word 的前缀之一为 prefix ，返回 true ；否则，返回 false 。<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Trie</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token class-name">Trie</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token punctuation">&#125;</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">insert</span><span class="token punctuation">(</span><span class="token class-name">String</span> word<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token punctuation">&#125;</span>        <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">search</span><span class="token punctuation">(</span><span class="token class-name">String</span> word<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token punctuation">&#125;</span>        <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">startsWith</span><span class="token punctuation">(</span><span class="token class-name">String</span> prefix<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p>解题的代码如下，思路和上文中提到的一样：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Trie</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> <span class="token class-name">N</span> <span class="token operator">=</span> <span class="token number">100009</span><span class="token punctuation">;</span> <span class="token comment">// 直接设置为十万级</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> trie<span class="token punctuation">;</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> count<span class="token punctuation">;</span>    <span class="token keyword">int</span> index<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">Trie</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        trie <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">26</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//因为有26个字母，所以有26个分叉</span>        count <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//初试的节点下标（根节点）</span>    <span class="token punctuation">&#125;</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">insert</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> p <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> u <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token char">'a'</span><span class="token punctuation">;</span>            <span class="token comment">//如果没有这个节点，就创建这个节点，index要增加</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>trie<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> trie<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">++</span>index<span class="token punctuation">;</span>            p <span class="token operator">=</span> trie<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        count<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">search</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> p <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> u <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token char">'a'</span><span class="token punctuation">;</span>            <span class="token comment">//不存在这条路径，就返回false</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>trie<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            p <span class="token operator">=</span> trie<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> count<span class="token punctuation">[</span>p<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">startsWith</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> p <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> u <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token char">'a'</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>trie<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            p <span class="token operator">=</span> trie<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="3-变形题"><a href="#3-变形题" class="headerlink" title="3. 变形题"></a>3. 变形题</h1><p><a  href ="https://leetcode.cn/problems/maximum-xor-of-two-numbers-in-an-array/description/">421. 数组中两个数的最大异或值</a></p><blockquote><p>给你一个整数数组 nums ，返回 nums[i] XOR nums[j] 的最大运算结果，其中 0 ≤ i ≤ j &lt; n 。</p></blockquote><p>示例 1：</p><blockquote><p>输入：nums &#x3D; [3,10,5,25,2,8]<br>输出：28<br>解释：最大运算结果是 5 XOR 25 &#x3D; 28.</p></blockquote><p>示例 2：</p><blockquote><p>输入：nums &#x3D; [14,70,53,83,49,91,36,80,92,51,66,70]<br>输出：127</p></blockquote><p>这道问题我们采用的是前缀树加上贪心的思路。我们将遍历到i之前的所有数字全加入到Trie树中，同时将第i个数也加入。此时我们有个贪心的思路，就是说在Trie树中，我们对于nums[i]，由于是异或，所以我们要寻找和nums[i]当前位不一样的，比如nums[i]当前位是1，我们就要找是0的数字。</p><p>具体实现代码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">class</span> <span class="token class-name">Node</span><span class="token punctuation">&#123;</span>        <span class="token class-name">Node</span><span class="token punctuation">[</span><span class="token punctuation">]</span> ns <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//因为只有0/1，所以大小为2</span>    <span class="token punctuation">&#125;</span>    <span class="token class-name">Node</span> root <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token class-name">Node</span> p <span class="token operator">=</span> root<span class="token punctuation">;</span>        <span class="token comment">//int位数为32位，全部遍历，从高到低</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">31</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> u <span class="token operator">=</span> <span class="token punctuation">(</span>x <span class="token operator">>></span> i<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token comment">//没有这个节点，就创建</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>ns<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> p<span class="token punctuation">.</span>ns<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            p <span class="token operator">=</span> p<span class="token punctuation">.</span>ns<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">int</span> <span class="token function">getVal</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token class-name">Node</span> p <span class="token operator">=</span> root<span class="token punctuation">;</span>        <span class="token keyword">int</span> ans <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">31</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token comment">//我们期望b是a不一样的</span>            <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token punctuation">(</span>x <span class="token operator">>></span> i<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">-</span> a<span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>ns<span class="token punctuation">[</span>b<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token comment">//此时b存在，符合期望，我们就把b按照位数还原</span>                ans <span class="token operator">|=</span> <span class="token punctuation">(</span>b <span class="token operator">&lt;&lt;</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>                p <span class="token operator">=</span> p<span class="token punctuation">.</span>ns<span class="token punctuation">[</span>b<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>                <span class="token comment">//不存在期望的b，我们只能走a的路线</span>                <span class="token comment">//记得最后将p指向我们移动后的位置</span>                ans <span class="token operator">|=</span> <span class="token punctuation">(</span>a <span class="token operator">&lt;&lt;</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>                p <span class="token operator">=</span> p<span class="token punctuation">.</span>ns<span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>         <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">findMaximumXOR</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> ans <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">:</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">add</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token function">getVal</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>            ans <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>ans<span class="token punctuation">,</span> i <span class="token operator">^</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h1><p>学了一下午，做了两个题，但是还是很有收获的。Trie的基本性质通过这两个题有所了解，继续更新这个Trie的会。<br><img src="https://raw.githubusercontent.com/guduxingzheplus/blogPic/main/imgs/IMG_4879.jpg" alt="IMG_4879"></p>]]></content>
      
      
      <categories>
          
          <category> 力扣刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 力扣刷题 </tag>
            
            <tag> Trie </tag>
            
            <tag> 前缀树 </tag>
            
            <tag> 字典树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring面试-事务</title>
      <link href="/2023/03/31/spring-mian-shi-shi-wu/"/>
      <url>/2023/03/31/spring-mian-shi-shi-wu/</url>
      
        <content type="html"><![CDATA[<p>spring 能否支持事务，取决去使用的数据库是否支持事务，比如对于MySQL来说，如果采用MyISAM，由于Myisam自身不支持事务，那么无论是否开启spring自身的事务，都是不能实现的。</p><h1 id="Spring事务"><a href="#Spring事务" class="headerlink" title="Spring事务"></a>Spring事务</h1><h2 id="1-spring支持的两种事务管理方式"><a href="#1-spring支持的两种事务管理方式" class="headerlink" title="1. spring支持的两种事务管理方式"></a>1. spring支持的两种事务管理方式</h2><h3 id="1-1-编程式事务管理"><a href="#1-1-编程式事务管理" class="headerlink" title="1.1 编程式事务管理"></a>1.1 编程式事务管理</h3><p>通过TransactionTemplate或者TransactionManager手动管理事务，实际中很少使用。<br>使用TransactionTrmplate进行编程式事务管理的实例代码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Autowired</span><span class="token keyword">private</span> <span class="token class-name">TransactionTemplate</span> transactionTemplate<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testTransaction</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        transactionTemplate<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">TransactionCallbackWithoutResult</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">doInTransactionWithoutResult</span><span class="token punctuation">(</span><span class="token class-name">TransactionStatus</span> transactionStatus<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>                    <span class="token comment">// ....  业务代码</span>                <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                    <span class="token comment">//回滚</span>                    transactionStatus<span class="token punctuation">.</span><span class="token function">setRollbackOnly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用 TransactionManager 进行编程式事务管理的示例代码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Autowired</span><span class="token keyword">private</span> <span class="token class-name">PlatformTransactionManager</span> transactionManager<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testTransaction</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token class-name">TransactionStatus</span> status <span class="token operator">=</span> transactionManager<span class="token punctuation">.</span><span class="token function">getTransaction</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">DefaultTransactionDefinition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>               <span class="token comment">// ....  业务代码</span>              transactionManager<span class="token punctuation">.</span><span class="token function">commit</span><span class="token punctuation">(</span>status<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>              transactionManager<span class="token punctuation">.</span><span class="token function">rollback</span><span class="token punctuation">(</span>status<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-2-声明式事务"><a href="#1-2-声明式事务" class="headerlink" title="1.2 声明式事务"></a>1.2 声明式事务</h3><p>实际是通过AOP实现的，这种方式对代码的侵入性比较小。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Transactional</span><span class="token punctuation">(</span>propagation <span class="token operator">=</span> <span class="token class-name">Propagation</span><span class="token punctuation">.</span><span class="token constant">REQUIRED</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">void</span> aMethod <span class="token punctuation">&#123;</span>  <span class="token comment">//do something</span>  <span class="token class-name">B</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token class-name">C</span> c <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">C</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  b<span class="token punctuation">.</span><span class="token function">bMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  c<span class="token punctuation">.</span><span class="token function">cMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-3-Spring事务管理接口介绍"><a href="#1-3-Spring事务管理接口介绍" class="headerlink" title="1.3 Spring事务管理接口介绍"></a>1.3 Spring事务管理接口介绍</h3><ul><li>PlatformTransactionManager: 事务管理器，Spring事务策略的核心</li><li>TransactionDefination： 事务定义信息（事务的回滚，隔离级别，传播行为，只读，超时）</li><li>TransactionalStatus： 事务运行的状态</li></ul><h4 id="1-3-1-PlatformTransactionManager"><a href="#1-3-1-PlatformTransactionManager" class="headerlink" title="1.3.1 PlatformTransactionManager"></a>1.3.1 PlatformTransactionManager</h4><p>Spring并不直接管理实务而是提供了许多的事务管理器。PlatformTransactionManager就是spring的重要管理器。通过这个接口，spring为各个平台：JDBC，JPA等等，都提供了对应的事务管理器，但是具体的实现就是各个平台自己的事情了。<br>PlatformTransactionManager接口中定义的方法:</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>transaction</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>lang<span class="token punctuation">.</span></span><span class="token class-name">Nullable</span></span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">PlatformTransactionManager</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//获得事务</span>    <span class="token class-name">TransactionStatus</span> <span class="token function">getTransaction</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Nullable</span> <span class="token class-name">TransactionDefinition</span> var1<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">TransactionException</span><span class="token punctuation">;</span>    <span class="token comment">//提交事务</span>    <span class="token keyword">void</span> <span class="token function">commit</span><span class="token punctuation">(</span><span class="token class-name">TransactionStatus</span> var1<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">TransactionException</span><span class="token punctuation">;</span>    <span class="token comment">//回滚事务</span>    <span class="token keyword">void</span> <span class="token function">rollback</span><span class="token punctuation">(</span><span class="token class-name">TransactionStatus</span> var1<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">TransactionException</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-3-2为什么要定义或者抽象出来这个接口"><a href="#1-3-2为什么要定义或者抽象出来这个接口" class="headerlink" title="1.3.2为什么要定义或者抽象出来这个接口"></a>1.3.2为什么要定义或者抽象出来这个接口</h3><p>主要是为了方便扩展，因为这样一来，不同平台的实现就可以自行设计，但是暴露给外部的接口是不变的，也就是说，提供给外部的行为是不变的，方便扩展。</p><blockquote><p>就如同我们为什么使用接口一样，比如我们要实现一个发送短信的代码，我们抽象出来一个接口，接口中有两个方法，发送短信，处理发送结果。如果我们刚开始是使用的阿里云发送，而后我们要改成其他的短信服务平台实现发送的功能，那么很显然，如果我们没有定义接口，那么需要重构调用发送代码的代码，而采用接口则只需要修改具体的短息发送代码。</p></blockquote><h3 id="1-3-3-事务属性"><a href="#1-3-3-事务属性" class="headerlink" title="1.3.3 事务属性"></a>1.3.3 事务属性</h3><p>事务管理器接口PlatformTransactionManager通过getTransaction(TransactionDefinition definition)方法来得到一个事务，而TransactionDefinition就是一个定义事务的基本属性的类。</p><p><strong>什么是事务属性？</strong></p><ul><li>隔离级别</li><li>传播行为</li><li>回滚规则</li><li>是否只读</li><li>是否超时</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>transaction</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>lang<span class="token punctuation">.</span></span><span class="token class-name">Nullable</span></span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">TransactionDefinition</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> <span class="token constant">PROPAGATION_REQUIRED</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token constant">PROPAGATION_SUPPORTS</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token constant">PROPAGATION_MANDATORY</span> <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token constant">PROPAGATION_REQUIRES_NEW</span> <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token constant">PROPAGATION_NOT_SUPPORTED</span> <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token constant">PROPAGATION_NEVER</span> <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token constant">PROPAGATION_NESTED</span> <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token constant">ISOLATION_DEFAULT</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token constant">ISOLATION_READ_UNCOMMITTED</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token constant">ISOLATION_READ_COMMITTED</span> <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token constant">ISOLATION_REPEATABLE_READ</span> <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token constant">ISOLATION_SERIALIZABLE</span> <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token constant">TIMEOUT_DEFAULT</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment">// 返回事务的传播行为，默认值为 REQUIRED。</span>    <span class="token keyword">int</span> <span class="token function">getPropagationBehavior</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//返回事务的隔离级别，默认值是 DEFAULT</span>    <span class="token keyword">int</span> <span class="token function">getIsolationLevel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 返回事务的超时时间，默认值为-1。如果超过该时间限制但事务还没有完成，则自动回滚事务。</span>    <span class="token keyword">int</span> <span class="token function">getTimeout</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 返回是否为只读事务，默认值为 false</span>    <span class="token keyword">boolean</span> <span class="token function">isReadOnly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Nullable</span>    <span class="token class-name">String</span> <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-3-4-事务状态"><a href="#1-3-4-事务状态" class="headerlink" title="1.3.4 事务状态"></a>1.3.4 事务状态</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">TransactionStatus</span><span class="token punctuation">&#123;</span>    <span class="token keyword">boolean</span> <span class="token function">isNewTransaction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 是否是新的事务</span>    <span class="token keyword">boolean</span> <span class="token function">hasSavepoint</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 是否有恢复点</span>    <span class="token keyword">void</span> <span class="token function">setRollbackOnly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 设置为只回滚</span>    <span class="token keyword">boolean</span> <span class="token function">isRollbackOnly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 是否为只回滚</span>    <span class="token keyword">boolean</span> isCompleted<span class="token punctuation">;</span> <span class="token comment">// 是否已完成</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="Spring事务详解"><a href="#Spring事务详解" class="headerlink" title="Spring事务详解"></a>Spring事务详解</h1><h2 id="2-事务传播行为"><a href="#2-事务传播行为" class="headerlink" title="2. 事务传播行为"></a>2. 事务传播行为</h2><p>事务传播行为是为了解决业务层方法之间相互调用的事务问题。<br>比如非事务方法去调用事务方法，那么事务方法会发生事务失效的问题。</p><p>当事务方法被另一个事务方法调用的时候我们必须指定事务该如何传播，比如如何回滚的问题。</p><h3 id="2-1-正确的事务传播行为可能的值"><a href="#2-1-正确的事务传播行为可能的值" class="headerlink" title="2.1 正确的事务传播行为可能的值"></a>2.1 正确的事务传播行为可能的值</h3><h4 id="1-TransactionDefinition-PROPAGATION-REQUIRED"><a href="#1-TransactionDefinition-PROPAGATION-REQUIRED" class="headerlink" title="1. TransactionDefinition.PROPAGATION_REQUIRED"></a>1. TransactionDefinition.PROPAGATION_REQUIRED</h4><p>使用最多的事务传播行为，也是<font style="background: violet"> 默认</font>的传播行为。</p><ul><li>如果当前外部方法没有开启事务，则当前事务会开启一个自己的新的事务，而且事务之间相互独立，不干扰</li><li>如果当前事务的外部事物开启了事务，并且被Progation.Required修饰的话，，那么当前的事务因为也开启了同样的Progation.Required，所以会被视为一个事务，只要一个方法发生了回滚，那么就会发生整体的回滚</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Service</span><span class="token class-name">Class</span> <span class="token class-name">A</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token class-name">B</span> b<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Transactional</span><span class="token punctuation">(</span>propagation <span class="token operator">=</span> <span class="token class-name">Propagation</span><span class="token punctuation">.</span><span class="token constant">REQUIRED</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> aMethod <span class="token punctuation">&#123;</span>        <span class="token comment">//do something</span>        b<span class="token punctuation">.</span><span class="token function">bMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token annotation punctuation">@Service</span><span class="token class-name">Class</span> <span class="token class-name">B</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Transactional</span><span class="token punctuation">(</span>propagation <span class="token operator">=</span> <span class="token class-name">Propagation</span><span class="token punctuation">.</span><span class="token constant">REQUIRED</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> bMethod <span class="token punctuation">&#123;</span>       <span class="token comment">//do something</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>只要B发生了回滚，那么因为A开启了Progation.REQUIRED，所以A也会回滚</p><h4 id="2-TransactionDefinanition-PROPAGATION-RTEQUIRES-NEW"><a href="#2-TransactionDefinanition-PROPAGATION-RTEQUIRES-NEW" class="headerlink" title="2. TransactionDefinanition.PROPAGATION_RTEQUIRES_NEW"></a>2. TransactionDefinanition.PROPAGATION_RTEQUIRES_NEW</h4><p>创建一个新的事务，如果当前存在事务，则会把当前的事务挂起，就是说不管外部是否存在事务，都会自行创建一个新的事务。且开启的事务相互独立，不户型干扰。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"> <span class="token annotation punctuation">@Service</span><span class="token class-name">Class</span> <span class="token class-name">A</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token class-name">B</span> b<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Transactional</span><span class="token punctuation">(</span>propagation <span class="token operator">=</span> <span class="token class-name">Propagation</span><span class="token punctuation">.</span><span class="token constant">REQUIRED</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> aMethod <span class="token punctuation">&#123;</span>        <span class="token comment">//do something</span>        b<span class="token punctuation">.</span><span class="token function">bMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token annotation punctuation">@Service</span><span class="token class-name">Class</span> <span class="token class-name">B</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Transactional</span><span class="token punctuation">(</span>propagation <span class="token operator">=</span> <span class="token class-name">Propagation</span><span class="token punctuation">.</span><span class="token constant">REQUIRES_NEW</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> bMethod <span class="token punctuation">&#123;</span>       <span class="token comment">//do something</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>如果A发生异常回滚，那么B不会回滚，因为B开启的是独立的事务，不会加入到A的事务之中</li><li>如果B发生异常回滚，<font style="background: violet"> A会回滚！</font>因为A是REQUIRED级别的事务，他会将上下文的事务统一成一个来看，所以一旦其中一个事务出现回滚，他也会回滚。</li></ul><h4 id="3-TransactioDefinition-PROPAGATION-NESTED"><a href="#3-TransactioDefinition-PROPAGATION-NESTED" class="headerlink" title="3. TransactioDefinition.PROPAGATION_NESTED:"></a>3. TransactioDefinition.PROPAGATION_NESTED:</h4><p>如果当前存在事务就在当前的事务内部嵌套执行事务，如果当前没有事务，就执行与 REQUIRED类似的事务。</p><ul><li><p>在外部方法开启事务的情况下，在内部开启一个新的事务，作为嵌套的存在。</p></li><li><p>在外部事物无方法的情况下，则单独开启一个事务。</p></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Service</span><span class="token class-name">Class</span> <span class="token class-name">A</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token class-name">B</span> b<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Transactional</span><span class="token punctuation">(</span>propagation <span class="token operator">=</span> <span class="token class-name">Propagation</span><span class="token punctuation">.</span><span class="token constant">REQUIRED</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> aMethod <span class="token punctuation">&#123;</span>        <span class="token comment">//do something</span>        b<span class="token punctuation">.</span><span class="token function">bMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token annotation punctuation">@Service</span><span class="token class-name">Class</span> <span class="token class-name">B</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Transactional</span><span class="token punctuation">(</span>propagation <span class="token operator">=</span> <span class="token class-name">Propagation</span><span class="token punctuation">.</span><span class="token constant">NESTED</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> bMethod <span class="token punctuation">&#123;</span>       <span class="token comment">//do something</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>B回滚，跟着回滚</p><h4 id="4-TransactionDefinition-PROPAGATION-MANDATORY"><a href="#4-TransactionDefinition-PROPAGATION-MANDATORY" class="headerlink" title="4. TransactionDefinition.PROPAGATION_MANDATORY"></a>4. TransactionDefinition.PROPAGATION_MANDATORY</h4><p>如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。（mandatory：强制性）这个使用的很少，就不举例子来说了</p><h3 id="2-2-事务的隔离级别"><a href="#2-2-事务的隔离级别" class="headerlink" title="2.2 事务的隔离级别"></a>2.2 事务的隔离级别</h3><p>一共5个隔离级别</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">TransactionDefinition</span> <span class="token punctuation">&#123;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">int</span> <span class="token constant">ISOLATION_DEFAULT</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token constant">ISOLATION_READ_UNCOMMITTED</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token constant">ISOLATION_READ_COMMITTED</span> <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token constant">ISOLATION_REPEATABLE_READ</span> <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token constant">ISOLATION_SERIALIZABLE</span> <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>逐一介绍（和MySQL类似。。。）</p><ul><li><p>TransactionDefinition.ISOLATION_DEFAULT：使用后端数据库默认的隔离级别，Mysql默认的级别是RR（可重复读），Oracle默认的是RC（读取已提交）</p></li><li><p>TransactionDefinition.ISOLATION_READ_UNCOMMITTED：读取未提交，会有脏读，幻读，不可重复读</p></li><li><p>TransactionDefinition.ISOLATION_READ_COMMITTED : 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生</p></li><li><p>TransactionDefinition.ISOLATION_REPEATABLE_READ : 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。</p></li><li><p>TransactionDefinition.ISOLATION_SERIALIZABLE : 最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。但是这将严重影响程序的性能。通常情况下也不会用到该级别。</p></li></ul><h3 id="2-3-事务超时属性"><a href="#2-3-事务超时属性" class="headerlink" title="2.3 事务超时属性"></a>2.3 事务超时属性</h3><p>如果超过最长执行时限，还没有完成，则自动回滚，在TransDefination中以init的值来表示超时时间。默认是-1；</p><h3 id="2-4-事务的只读属性"><a href="#2-4-事务的只读属性" class="headerlink" title="2.4 事务的只读属性"></a>2.4 事务的只读属性</h3><p>对于只要读取数据的事务，可以开启readonly，数据库会去优化。为什么数据查询操作还要开启事务支持？</p><blockquote><p>因为MySQL默认对每一个新建立的链接都启用了autocomit模式，在这个模式下，每一个发送到Mysql的sql语句都会在一个单独的事务中进行处理，执行结束后会自动提交事务，并开启一个新的事务。所欲我们可以看到，如果我们给方法加上了Transactional注解的话，这个方法的全部sql会被放入到一个事务之中，如果声明了只读事物的话数据库同样会去优化她的执行过程。缩短了执行时间。如果不加Transactional，那么每条sql会单独开启一个独立事务，这样耗时长，但是也会在实时的读取到最新的值。</p></blockquote><h3 id="2-5-事务回滚原则"><a href="#2-5-事务回滚原则" class="headerlink" title="2.5 事务回滚原则"></a>2.5 事务回滚原则</h3><p>可以自定义事务回滚的特定异常类型</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Transactional</span><span class="token punctuation">(</span>rollbackFor<span class="token operator">=</span> <span class="token class-name">MyException</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="3-Transactional-注解使用详解"><a href="#3-Transactional-注解使用详解" class="headerlink" title="3. @Transactional 注解使用详解"></a>3. @Transactional 注解使用详解</h2><h3 id="3-1-Transactional-的作用范围"><a href="#3-1-Transactional-的作用范围" class="headerlink" title="3.1 @Transactional 的作用范围"></a>3.1 @Transactional 的作用范围</h3><ol><li>方法：推荐使用在方法上，不过需要注意的是这个注解只能用到public方法上，否则不生效。</li><li>类： 如果这个注解使用在类上，表明该注解对类上的所有public方法都有效。</li><li>接口：不推荐在接口上使用</li></ol><p>@Transactional 的常用配置参数总结（只列出了 5 个平时比较常用的）：</p><p><img src="https://raw.githubusercontent.com/guduxingzheplus/blogPic/main/imgs/20230401093008.png" alt="20230401093008"></p><p>@Transactional 事务注解原理：<br>AOP实现的，AOP基于动态代理，如果目标实现了接口，默认情况下会采用jdk动态代理，否则采用cglib的代理。<br>createAopProxy（）方法决定了使用什么代理</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DefaultAopProxyFactory</span> <span class="token keyword">implements</span> <span class="token class-name">AopProxyFactory</span><span class="token punctuation">,</span> <span class="token class-name">Serializable</span> <span class="token punctuation">&#123;</span><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token class-name">AopProxy</span> <span class="token function">createAopProxy</span><span class="token punctuation">(</span><span class="token class-name">AdvisedSupport</span> config<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">AopConfigException</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>config<span class="token punctuation">.</span><span class="token function">isOptimize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> config<span class="token punctuation">.</span><span class="token function">isProxyTargetClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token function">hasNoUserSuppliedProxyInterfaces</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> targetClass <span class="token operator">=</span> config<span class="token punctuation">.</span><span class="token function">getTargetClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>targetClass <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">AopConfigException</span><span class="token punctuation">(</span><span class="token string">"TargetSource cannot determine target class: "</span> <span class="token operator">+</span><span class="token string">"Either an interface or a target is required for proxy creation."</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>targetClass<span class="token punctuation">.</span><span class="token function">isInterface</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token class-name">Proxy</span><span class="token punctuation">.</span><span class="token function">isProxyClass</span><span class="token punctuation">(</span>targetClass<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">JdkDynamicAopProxy</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ObjenesisCglibAopProxy</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">JdkDynamicAopProxy</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果一个类或者一个类中的public方法被标注了@Transactional注解，那么spring容器在启动的时候会为其创建一个代理类，在调用@Transactional注解的public方法的时候，实际调用的是TransactionInterceptor 类中的 invoke()方法。这个方法的作用就是在目标方法之前开启事务，方法执行过程中如果遇到异常的时候回滚事务，方法调用完成之后提交事务。</p><h3 id="3-2-Transactional-的使用注意事项总结"><a href="#3-2-Transactional-的使用注意事项总结" class="headerlink" title="3.2 @Transactional 的使用注意事项总结"></a>3.2 @Transactional 的使用注意事项总结</h3><ul><li>@Transactional 注解只有作用到 public 方法上事务才生效，不推荐在接口上使用；</li><li>避免同一个类中调用@Transactional 注解的方法，这样会导致事务失效；</li><li>正确的设置 @Transactional 的 rollbackFor 和 propagation 属性，否则事务可能会回滚失败;</li><li>被 @Transactional 注解的方法所在的类必须被 Spring 管理，否则不生效；底层使用的数据库必须支持事务机制，否则不生效</li></ul>]]></content>
      
      
      <categories>
          
          <category> spring面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
            <tag> 事务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring面试--IoC/Aop</title>
      <link href="/2023/03/30/spring-mian-shi-ioc-aop/"/>
      <url>/2023/03/30/spring-mian-shi-ioc-aop/</url>
      
        <content type="html"><![CDATA[<h1 id="Spring-IoC"><a href="#Spring-IoC" class="headerlink" title="Spring IoC"></a>Spring IoC</h1><h2 id="1-谈谈对SpringIoc的理解"><a href="#1-谈谈对SpringIoc的理解" class="headerlink" title="1.谈谈对SpringIoc的理解"></a>1.谈谈对SpringIoc的理解</h2><h3 id="1-1-控制反转来源"><a href="#1-1-控制反转来源" class="headerlink" title="1.1 控制反转来源"></a>1.1 控制反转来源</h3><p>-控制指的是对象创建（实例化，管理的权利）<br>-反转：指的是将控制权交给外部环境（Spring框架，Ioc容器）<br><img src="https://raw.githubusercontent.com/guduxingzheplus/blogPic/main/imgs/20230330101109.png"></p><p>将对象之间的相互依赖关系交给IoC容器来管理，并由容器完成对象的注入，这样可以很大程度上简化应用的开发过程。<br>这样的好处是两方之间（调用方和被调用方）之间不再相互依赖</p><ul><li>降低对象之间的耦合度  </li><li>资源变得容易管理，比如用Spring容器提供的话，很容易实现一个单例。</li></ul><p><strong>IoC最常见的最合理的实践方式是依赖注入（DI）</strong></p><h3 id="1-2-DI"><a href="#1-2-DI" class="headerlink" title="1.2 DI"></a>1.2 DI</h3><p>DI即依赖注入：组件之间依赖关系由容器在运行时决定，形象的说，即由容器动态的将某个依赖注入到组件之中，依赖注入的目的并非为软件带来更多的功能，而是为了提升组件重用的频率，并未系统搭建一个灵活，可扩展的平台。</p><p>理解DI的关键是理解如下四个点：</p><ul><li>谁依赖谁 当然是程序依赖于IOC容器</li><li>为什么需要依赖：需要容器提供对象需要的外部资源</li><li>谁注入了谁： 很明显是IoC容器注入应用程序某个对象，应用程序依赖的对象。</li><li>注入了什么：就是注入某个对象所需要的外部资源</li></ul><h4 id="1-2-1-对于IoC的理解"><a href="#1-2-1-对于IoC的理解" class="headerlink" title="1.2.1 对于IoC的理解"></a>1.2.1 对于IoC的理解</h4><p>Spring所倡导的开发方式就是如此，所有的类都会在spring容器中登记，告诉spring你是个什么东西，你需要什么东西，然后spring会在系统运行到适当的时候，把你要的东西主动给你，同时也把你交给其他需要你的东西。所有的类的创建、销毁都由 spring来控制，也就是说控制对象生存周期的不再是引用它的对象，而是spring。对于某个具体的对象而言，以前是它控制其他对象，现在是所有对象都被spring控制，所以这叫控制反转。</p><h4 id="1-2-2-对于DI的理解"><a href="#1-2-2-对于DI的理解" class="headerlink" title="1.2.2 对于DI的理解"></a>1.2.2 对于DI的理解</h4><p>IoC的一个重点是在运行的时候，动态的向某个对象提供他所需要的对象，这一点是通过DI来实现的。</p><p>比如A对象需要操作数据库，他会向spring报告这个需求，而spring会在合适的时候创建这个数据库驱动，具体怎么创建A不知道，创建完毕之后注入A中，这就是DI。DI通常通过使用反射实现，他允许程序在运行的时候动态的生成对象，执行对象的方法，改变对象的属性。</p><h3 id="1-3-什么是AOP"><a href="#1-3-什么是AOP" class="headerlink" title="1.3 什么是AOP"></a>1.3 什么是AOP</h3><p>传统的OPP编程是不能解决横切逻辑代码的，所谓横切逻辑代码指的是代码在多个纵向顺序流程中出现的相同子流程代码，我们称之为横切逻辑代码。</p><p>例如：现有三个类，Horse、Pig、Dog，这三个类中都有 eat 和 run 两个方法。</p><p>通过 OOP 思想中的继承，我们可以提取出一个 Animal 的父类，然后将 eat 和 run 方法放入父类中，Horse、Pig、Dog通过继承Animal类即可自动获得 eat() 和 run() 方法。这样将会少些很多重复的代码。</p><p><img src="https://raw.githubusercontent.com/guduxingzheplus/blogPic/main/imgs/20230330102109.png"></p><p>OOP的代码如下：  </p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token punctuation">&#123;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Animal</span> <span class="token punctuation">&#123;</span>    <span class="token comment">/** 身高 */</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> height<span class="token punctuation">;</span>    <span class="token comment">/** 体重 */</span>    <span class="token keyword">private</span> <span class="token keyword">double</span> weight<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 性能监控代码</span>        <span class="token keyword">long</span> start <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 业务逻辑代码</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"I can eat..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 性能监控代码</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"执行时长："</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> start<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">1000f</span> <span class="token operator">+</span> <span class="token string">"s"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 性能监控代码</span>        <span class="token keyword">long</span> start <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 业务逻辑代码</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"I can run..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 性能监控代码</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"执行时长："</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> start<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">1000f</span> <span class="token operator">+</span> <span class="token string">"s"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/guduxingzheplus/blogPic/main/imgs/20230330102246.png"></p><p>横切代码存在的逻辑问题：</p><ul><li>代码重复</li><li>横切代码逻辑代码和业务代码混合在一起，代码臃肿，维护不方便</li></ul><p>AOP另辟蹊径，将横切代码抽离出来<br><img src="https://raw.githubusercontent.com/guduxingzheplus/blogPic/main/imgs/20230330102433.png"><br>代码拆分容易，难的是如何在不改变原有业务逻辑的情况下，达到一致的效果。</p><p><strong>AOP 为什么叫面向切片编程</strong></p><p>切：指的是横切逻辑，又有业务逻辑代码不懂，只能操作横切逻辑代码，所以面向横切逻辑</p><p>面：横切逻辑代码往往要影响很多个方法，每个方法如同一个点，多个点构成一个面。</p><h1 id="2-什么是Spring-Bean"><a href="#2-什么是Spring-Bean" class="headerlink" title="2. 什么是Spring Bean"></a>2. 什么是Spring Bean</h1><p>简单说，就是背那些Ioc容器管理的对象<br>我们需要告诉ioc容器要帮我们管理哪些对象，这个是通过元数据定义的。配置文件可以是XML文件，注解或者java配置类</p><h2 id="2-1-将类声明为Bean的注解"><a href="#2-1-将类声明为Bean的注解" class="headerlink" title="2.1 将类声明为Bean的注解"></a>2.1 将类声明为Bean的注解</h2><ul><li>@Componenet：通用注解，可以理解为Spring组件，不知道属于哪层的时候可以用。</li><li>@Repository：对应持久层的Dao层，主要用于数据库操作</li><li>@Service ：服务层，主要涉及一些复杂的逻辑，需要用到Dao</li><li>@Controller ：控制层，接受用户的调用，并请求Service层返回数据给前端。</li></ul><h2 id="2-2-Component-和-Bean区别"><a href="#2-2-Component-和-Bean区别" class="headerlink" title="2.2 @Component 和 @Bean区别"></a>2.2 @Component 和 @Bean区别</h2><ul><li>@Componenet 主要用于类的注解。 @Bean主要用于方法</li><li>@Componnet 主要是通过类路径扫描获得的，比如@ComponentScan，但是@Bean是在标有该注解的方法中定义产生这个bean，@Bean告诉了Spring，这个是某个类的实例，当我需要的时候，要还给我。</li><li>@Bean比@Component更加灵活，很多时候我们只能通过@Bean来注册bean，比如引用第三方库的时候。</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AppConfig</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> <span class="token class-name">TransferService</span> <span class="token function">transferService</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">TransferServiceImpl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的代码相当于如下的xml文件</p><pre class="line-numbers language-XML" data-language="XML"><code class="language-XML">&lt;beans&gt;    &lt;bean id&#x3D;&quot;transferService&quot; class&#x3D;&quot;com.acme.TransferServiceImpl&quot;&#x2F;&gt;&lt;&#x2F;beans&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>下面这个例子是通过 @Component 无法实现的。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Bean</span><span class="token keyword">public</span> <span class="token class-name">OneService</span> <span class="token function">getService</span><span class="token punctuation">(</span>status<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">case</span> <span class="token punctuation">(</span>status<span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>        when <span class="token number">1</span><span class="token operator">:</span>                <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token function">serviceImpl1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        when <span class="token number">2</span><span class="token operator">:</span>                <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token function">serviceImpl2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        when <span class="token number">3</span><span class="token operator">:</span>                <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token function">serviceImpl3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-3-Autowired和-Resource区别是什么？"><a href="#2-3-Autowired和-Resource区别是什么？" class="headerlink" title="2.3 @Autowired和@Resource区别是什么？"></a>2.3 @Autowired和@Resource区别是什么？</h2><p><font style="background: gray">Autowired</font><br>属于spring内置的注解，默认注入的方式为byType，也就是说会优先按照类型去匹配，但是存在如下的问题</p><ul><li><p>一个接口可能会出现同类型有很多个不同的实现类，这样就会造成byType混乱，找不到对应的实现类。这种情况下的实现办法如下：  </p><ul><li>spring会采用byName的形式来进行匹配，也就是根据类名的小写首字母的形式来进行匹配。举例  <pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Autowired</span><span class="token keyword">private</span> <span class="token class-name">SmService</span> smService<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul><p>  再比如：Sms有两个实现类，<font style="background:ddd gray">SmsServiceImpl1</font>和 <font style="background: gray">SmsServiceImpl2</font>此时都已经被spring容器管理，我们应该这样使用<br>  <pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 报错，byName 和 byType 都无法匹配到 bean</span><span class="token annotation punctuation">@Autowired</span><span class="token keyword">private</span> <span class="token class-name">SmsService</span> smsService<span class="token punctuation">;</span><span class="token comment">// 正确注入 SmsServiceImpl1 对象对应的 bean</span><span class="token annotation punctuation">@Autowired</span><span class="token keyword">private</span> <span class="token class-name">SmsService</span> smsServiceImpl1<span class="token punctuation">;</span><span class="token comment">// 正确注入  SmsServiceImpl1 对象对应的 bean</span><span class="token comment">// smsServiceImpl1 就是我们上面所说的名称</span><span class="token annotation punctuation">@Autowired</span><span class="token annotation punctuation">@Qualifier</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"smsServiceImpl1"</span><span class="token punctuation">)</span><span class="token keyword">private</span> <span class="token class-name">SmsService</span> smsService<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>  这里推荐使用@Qualifier来指定使用的类。</p><p>  <strong>@Resource</strong> 是jdk提供的注解，默认的注入方式为byName，如果无法通过byName注入，那么久通过byType进行注入。<br>  Resource有两个比较重要的属性：</p><ul><li>Name：名称</li><li>type：类型</li></ul></li></ul><p>总结一下：</p><ul><li>@Autowired 是 Spring 提供的注解，@Resource 是 JDK 提供的注解。</li><li>Autowired 默认的注入方式为byType（根据类型进行匹配），@Resource默认注入方式为 byName（根据名称进行匹配）。</li><li>在一个接口存在多个实现类的时候，二者都需要通过名称才能正确匹配到对应的bean，Autowired可以通过@Qualifer类显示的指定名称，@Resourse可以通过name属性来显示指定名称。</li></ul><h1 id="3-对SpringAoP的理解"><a href="#3-对SpringAoP的理解" class="headerlink" title="3.对SpringAoP的理解"></a>3.对SpringAoP的理解</h1><p>基于动态代理的，如果被代理的对象实现了某个接口，那么会用JDK Proxy代理，对于没有实现接口的对象，就使用cglib代理。</p><h2 id="3-1-Spring-AOP-和-AspectJ-AOP-有什么区别？"><a href="#3-1-Spring-AOP-和-AspectJ-AOP-有什么区别？" class="headerlink" title="3.1 Spring AOP 和 AspectJ AOP 有什么区别？"></a>3.1 Spring AOP 和 AspectJ AOP 有什么区别？</h2><p>也可以用AspectJ，这个是最完整的aop框架。Spring AOP属于是<strong>运行时增强</strong>而AspectJ是<strong>编译时增强</strong>，AOP是基于字节码操作。目前AOP已经集成了AspetJ但是，在切面比较少的情况下，两者差异不大，多的时候就用AspectJ，她的速度快很多。</p><h2 id="3-2-多个切面之间的执行顺序？"><a href="#3-2-多个切面之间的执行顺序？" class="headerlink" title="3.2 多个切面之间的执行顺序？"></a>3.2 多个切面之间的执行顺序？</h2><p>通过@Order来进行控制，通过实现Orderd接口重写getOrder方法</p><h1 id="4-Spring-mvc"><a href="#4-Spring-mvc" class="headerlink" title="4. Spring mvc"></a>4. Spring mvc</h1><h2 id="4-1-核心组件"><a href="#4-1-核心组件" class="headerlink" title="4.1 核心组件"></a>4.1 核心组件</h2><ul><li><font style="background:ddd gray">DispatcherServlet</font>： 核心的中央处理器，负责接受请求，分发，并给予客户端响应</li><li>HandlerMapping： 处理器映射器，根据uri去匹配查找能处理的Handler，并会将设计到的拦截器和Handler一起封装。</li><li>HandlerAdapter： 处理器适配器，根据上一步找到的Handler，适配对应执行的Handler</li><li>Handler: 请求处理器，处理实际请求的处理器。</li><li>ViewResolver：视图解析器，根据Handler返回的逻辑视图，解析并渲染真正的视图，并传递给DispatcherServlet。</li></ul><h2 id="4-2-工作原理"><a href="#4-2-工作原理" class="headerlink" title="4.2 工作原理"></a>4.2 工作原理</h2><p><img src="https://raw.githubusercontent.com/guduxingzheplus/blogPic/main/imgs/20230331081801.png" alt="20230331081801"></p><p><font style="background: gray">流程说明（important）：</font></p><ol><li>客户端浏览器发送请求到DispatchServlet</li><li>DispatcherServlet调用HandlerMapping，根据uri寻找合适的Handler（也就是Controller），并且会将请求涉及的拦截器和Handler一起封装返回。</li><li>DispatcherServlet调用HandlerAdapter适配执行Handler</li><li>Handler完成对用户请求的处理后，返回一个ModelAndView对象给DispathcerServlet，ModelAndView就是包含了数据模型以及相应的视图信息。Model是返回的数据对象，View是逻辑上的View</li><li>ViewResolver会根据逻辑View查找实际的view</li><li>DispatcherServlet将返回的Model传给View（视图渲染）</li><li>把view返回给请求者。</li></ol><h2 id="4-3-统一异常处理怎么做"><a href="#4-3-统一异常处理怎么做" class="headerlink" title="4.3 统一异常处理怎么做"></a>4.3 统一异常处理怎么做</h2><p>使用@ControllerAdvice + @ExceptionHandler来处理</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@ControllerAdvice</span><span class="token annotation punctuation">@ResponseBody</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">GlobalExceptionHandler</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@ExceptionHandler</span><span class="token punctuation">(</span><span class="token class-name">BaseException</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token class-name">ResponseEntity</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> <span class="token function">handleAppException</span><span class="token punctuation">(</span><span class="token class-name">BaseException</span> ex<span class="token punctuation">,</span> <span class="token class-name">HttpServletRequest</span> request<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token comment">//......</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@ExceptionHandler</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token class-name">ResourceNotFoundException</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token class-name">ResponseEntity</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">ErrorReponse</span><span class="token punctuation">></span></span> <span class="token function">handleResourceNotFoundException</span><span class="token punctuation">(</span><span class="token class-name">ResourceNotFoundException</span> ex<span class="token punctuation">,</span> <span class="token class-name">HttpServletRequest</span> request<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token comment">//......</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>@ControllerAdvice是controller增强器，主要三个作用，全局异常处理，全局数据绑定，全局数据预处理</p><p>这种异常处理方式下，会给所有或者指定的 Controller 织入异常处理的逻辑（AOP），当 Controller 中的方法抛出异常的时候，由被@ExceptionHandler 注解修饰的方法进行处理。</p><h1 id="5-Spring-Data-JPA"><a href="#5-Spring-Data-JPA" class="headerlink" title="5. Spring Data JPA"></a>5. Spring Data JPA</h1><h2 id="5-1-如何用JPA对数据库中的某个字段非持久化"><a href="#5-1-如何用JPA对数据库中的某个字段非持久化" class="headerlink" title="5.1 如何用JPA对数据库中的某个字段非持久化"></a>5.1 如何用JPA对数据库中的某个字段非持久化</h2><p>所谓非持久化，就是在实体类中，让某个字段不被数据库存储。<br>可以采用如下方法</p><ul><li><p>static String s1; &#x2F;&#x2F;加了static</p></li><li><p>final String s1 &#x3D; “ss”;  &#x2F;&#x2F;final修饰</p></li><li><p>transient String s1; &#x2F;&#x2F;trainsient修饰</p></li><li><p>@Transient &#x2F;&#x2F;加了注解<br>String s1;</p><p>主要使用后两种比较多</p></li></ul><h2 id="5-2-PA-的审计功能是做什么的？有什么用？"><a href="#5-2-PA-的审计功能是做什么的？有什么用？" class="headerlink" title="5.2 PA 的审计功能是做什么的？有什么用？"></a>5.2 PA 的审计功能是做什么的？有什么用？</h2><p>审计功能主要是帮助我们记录数据库操作的具体行为比如某条记录是谁创建的、什么时间创建的、最后修改人是谁、最后修改时间是什么时候。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Data</span><span class="token annotation punctuation">@AllArgsConstructor</span><span class="token annotation punctuation">@NoArgsConstructor</span><span class="token annotation punctuation">@MappedSuperclass</span><span class="token annotation punctuation">@EntityListeners</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token class-name">AuditingEntityListener</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">AbstractAuditBase</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@CreatedDate</span>    <span class="token annotation punctuation">@Column</span><span class="token punctuation">(</span>updatable <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">)</span>    <span class="token annotation punctuation">@JsonIgnore</span>    <span class="token keyword">private</span> <span class="token class-name">Instant</span> createdAt<span class="token punctuation">;</span>    <span class="token annotation punctuation">@LastModifiedDate</span>    <span class="token annotation punctuation">@JsonIgnore</span>    <span class="token keyword">private</span> <span class="token class-name">Instant</span> updatedAt<span class="token punctuation">;</span>    <span class="token annotation punctuation">@CreatedBy</span>    <span class="token annotation punctuation">@Column</span><span class="token punctuation">(</span>updatable <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">)</span>    <span class="token annotation punctuation">@JsonIgnore</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> createdBy<span class="token punctuation">;</span>    <span class="token annotation punctuation">@LastModifiedBy</span>    <span class="token annotation punctuation">@JsonIgnore</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> updatedBy<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>@CreatedDate: 表示该字段为创建时间字段，在这个实体被 insert 的时候，会设置值</li><li>@CreatedBy :表示该字段为创建人，在这个实体被 insert 的时候，会设置值@LastModifiedDate、@LastModifiedBy同理。</li></ul><h1 id="6-Spring-Security"><a href="#6-Spring-Security" class="headerlink" title="6. Spring Security"></a>6. Spring Security</h1><h2 id="6-1-有哪些请求权限的方法"><a href="#6-1-有哪些请求权限的方法" class="headerlink" title="6.1 有哪些请求权限的方法"></a>6.1 有哪些请求权限的方法</h2><ul><li>permitAll() ：无条件允许任何形式访问，不管你登录还是没有登录。</li><li>anonymous() ：允许匿名访问，也就是没有登录才可以访问。</li><li>denyAll() ：无条件决绝任何形式的访问。</li><li>authenticated()：只允许已认证的用户访问。</li><li>fullyAuthenticated() ：只允许已经登录或者通过 </li><li>remember-me 登录的用户访问。</li><li>hasRole(String) : 只允许指定的角色访问。</li><li>hasAnyRole(String)  : 指定一个或者多个角色，满足其一的用户即可访问。</li><li>hasAuthority(String) ：只允许具有指定权限的用户访问</li><li>hasAnyAuthority(String) ：指定一个或者多个权限，满足其一的用户即可访问。</li><li>hasIpAddress(String) : 只允许指定 ip 的用户访问。</li></ul><h2 id="6-2-hasRole-和-hasAuthority-有区别吗？"><a href="#6-2-hasRole-和-hasAuthority-有区别吗？" class="headerlink" title="6.2 hasRole 和 hasAuthority 有区别吗？"></a>6.2 hasRole 和 hasAuthority 有区别吗？</h2><p>二者是存在区别的，hasRole会要求数据库中的权限字段加上ROLE_前缀，而hasAuthority并不要求。从设计层面上讲，hasRole是角色表，而角色是权限的集合。也就是说，使用 hasAuthority 更具有一致性，你不用考虑要不要加 ROLE_ 前缀，数据库什么样这里就是什么样！而 hasRole 则不同，代码里如果写的是 admin，框架会自动加上 ROLE_ 前缀，所以数据库就必须是 ROLE_admin。</p><h2 id="6-3-对密码加密？"><a href="#6-3-对密码加密？" class="headerlink" title="6.3 对密码加密？"></a>6.3 对密码加密？</h2><p>使用bcrypt，当然也可以自己设计加密算法，继承PasswordEncoder类</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">PasswordEncoder</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 加密也就是对原始密码进行编码</span>    <span class="token class-name">String</span> <span class="token function">encode</span><span class="token punctuation">(</span><span class="token class-name">CharSequence</span> var1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 比对原始密码和数据库中保存的密码</span>    <span class="token keyword">boolean</span> <span class="token function">matches</span><span class="token punctuation">(</span><span class="token class-name">CharSequence</span> var1<span class="token punctuation">,</span> <span class="token class-name">String</span> var2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 判断加密密码是否需要再次进行加密，默认返回 false</span>    <span class="token keyword">default</span> <span class="token keyword">boolean</span> <span class="token function">upgradeEncoding</span><span class="token punctuation">(</span><span class="token class-name">String</span> encodedPassword<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="6-4-更换密码加密算法"><a href="#6-4-更换密码加密算法" class="headerlink" title="6.4 更换密码加密算法"></a>6.4 更换密码加密算法</h2><p>使用DelegatingPasswordEncoder兼容多种不同的加密方案。这其实是个代理类，并非全新的加密算法，他做的事情就是代理加密算法实现类。</p>]]></content>
      
      
      <categories>
          
          <category> spring面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
