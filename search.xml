<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Spring面试--IoC/Aop</title>
      <link href="/2023/03/30/spring-mian-shi-bi-ji/"/>
      <url>/2023/03/30/spring-mian-shi-bi-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="Spring-IoC"><a href="#Spring-IoC" class="headerlink" title="Spring IoC"></a>Spring IoC</h1><h2 id="1-谈谈对SpringIoc的理解"><a href="#1-谈谈对SpringIoc的理解" class="headerlink" title="1.谈谈对SpringIoc的理解"></a>1.谈谈对SpringIoc的理解</h2><h3 id="1-1-控制反转来源"><a href="#1-1-控制反转来源" class="headerlink" title="1.1 控制反转来源"></a>1.1 控制反转来源</h3><p>-控制指的是对象创建（实例化，管理的权利）<br>-反转：指的是将控制权交给外部环境（Spring框架，Ioc容器）<br><img src="https://raw.githubusercontent.com/guduxingzheplus/blogPic/main/imgs/20230330101109.png"></p><p>将对象之间的相互依赖关系交给IoC容器来管理，并由容器完成对象的注入，这样可以很大程度上简化应用的开发过程。<br>这样的好处是两方之间（调用方和被调用方）之间不再相互依赖</p><ul><li>降低对象之间的耦合度  </li><li>资源变得容易管理，比如用Spring容器提供的话，很容易实现一个单例。</li></ul><p><strong>IoC最常见的最合理的实践方式是依赖注入（DI）</strong></p><h3 id="1-2-DI"><a href="#1-2-DI" class="headerlink" title="1.2 DI"></a>1.2 DI</h3><p>DI即依赖注入：组件之间依赖关系由容器在运行时决定，形象的说，即由容器动态的将某个依赖注入到组件之中，依赖注入的目的并非为软件带来更多的功能，而是为了提升组件重用的频率，并未系统搭建一个灵活，可扩展的平台。</p><p>理解DI的关键是理解如下四个点：</p><ul><li>谁依赖谁 当然是程序依赖于IOC容器</li><li>为什么需要依赖：需要容器提供对象需要的外部资源</li><li>谁注入了谁： 很明显是IoC容器注入应用程序某个对象，应用程序依赖的对象。</li><li>注入了什么：就是注入某个对象所需要的外部资源</li></ul><h4 id="1-2-1-对于IoC的理解"><a href="#1-2-1-对于IoC的理解" class="headerlink" title="1.2.1 对于IoC的理解"></a>1.2.1 对于IoC的理解</h4><p>Spring所倡导的开发方式就是如此，所有的类都会在spring容器中登记，告诉spring你是个什么东西，你需要什么东西，然后spring会在系统运行到适当的时候，把你要的东西主动给你，同时也把你交给其他需要你的东西。所有的类的创建、销毁都由 spring来控制，也就是说控制对象生存周期的不再是引用它的对象，而是spring。对于某个具体的对象而言，以前是它控制其他对象，现在是所有对象都被spring控制，所以这叫控制反转。</p><h4 id="1-2-2-对于DI的理解"><a href="#1-2-2-对于DI的理解" class="headerlink" title="1.2.2 对于DI的理解"></a>1.2.2 对于DI的理解</h4><p>IoC的一个重点是在运行的时候，动态的向某个对象提供他所需要的对象，这一点是通过DI来实现的。</p><p>比如A对象需要操作数据库，他会向spring报告这个需求，而spring会在合适的时候创建这个数据库驱动，具体怎么创建A不知道，创建完毕之后注入A中，这就是DI。DI通常通过使用反射实现，他允许程序在运行的时候动态的生成对象，执行对象的方法，改变对象的属性。</p><h3 id="1-3-什么是AOP"><a href="#1-3-什么是AOP" class="headerlink" title="1.3 什么是AOP"></a>1.3 什么是AOP</h3><p>传统的OPP编程是不能解决横切逻辑代码的，所谓横切逻辑代码指的是代码在多个纵向顺序流程中出现的相同子流程代码，我们称之为横切逻辑代码。</p><p>例如：现有三个类，Horse、Pig、Dog，这三个类中都有 eat 和 run 两个方法。</p><p>通过 OOP 思想中的继承，我们可以提取出一个 Animal 的父类，然后将 eat 和 run 方法放入父类中，Horse、Pig、Dog通过继承Animal类即可自动获得 eat() 和 run() 方法。这样将会少些很多重复的代码。</p><p><img src="https://raw.githubusercontent.com/guduxingzheplus/blogPic/main/imgs/20230330102109.png"></p><p>OOP的代码如下：  </p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token punctuation">&#123;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Animal</span> <span class="token punctuation">&#123;</span>    <span class="token comment">/** 身高 */</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> height<span class="token punctuation">;</span>    <span class="token comment">/** 体重 */</span>    <span class="token keyword">private</span> <span class="token keyword">double</span> weight<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 性能监控代码</span>        <span class="token keyword">long</span> start <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 业务逻辑代码</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"I can eat..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 性能监控代码</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"执行时长："</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> start<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">1000f</span> <span class="token operator">+</span> <span class="token string">"s"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 性能监控代码</span>        <span class="token keyword">long</span> start <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 业务逻辑代码</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"I can run..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 性能监控代码</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"执行时长："</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> start<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">1000f</span> <span class="token operator">+</span> <span class="token string">"s"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/guduxingzheplus/blogPic/main/imgs/20230330102246.png"></p><p>横切代码存在的逻辑问题：</p><ul><li>代码重复</li><li>横切代码逻辑代码和业务代码混合在一起，代码臃肿，维护不方便</li></ul><p>AOP另辟蹊径，将横切代码抽离出来<br><img src="https://raw.githubusercontent.com/guduxingzheplus/blogPic/main/imgs/20230330102433.png"><br>代码拆分容易，难的是如何在不改变原有业务逻辑的情况下，达到一致的效果。</p><p><strong>AOP 为什么叫面向切片编程</strong></p><p>切：指的是横切逻辑，又有业务逻辑代码不懂，只能操作横切逻辑代码，所以面向横切逻辑</p><p>面：横切逻辑代码往往要影响很多个方法，每个方法如同一个点，多个点构成一个面。</p><h2 id="2-什么是Spring-Bean"><a href="#2-什么是Spring-Bean" class="headerlink" title="2. 什么是Spring Bean"></a>2. 什么是Spring Bean</h2><p>简单说，就是背那些Ioc容器管理的对象<br>我们需要告诉ioc容器要帮我们管理哪些对象，这个是通过元数据定义的。配置文件可以是XML文件，注解或者java配置类</p><h3 id="2-1-将类声明为Bean的注解"><a href="#2-1-将类声明为Bean的注解" class="headerlink" title="2.1 将类声明为Bean的注解"></a>2.1 将类声明为Bean的注解</h3><ul><li>@Componenet：通用注解，可以理解为Spring组件，不知道属于哪层的时候可以用。</li><li>@Repository：对应持久层的Dao层，主要用于数据库操作</li><li>@Service ：服务层，主要涉及一些复杂的逻辑，需要用到Dao</li><li>@Controller ：控制层，接受用户的调用，并请求Service层返回数据给前端。</li></ul><h3 id="2-2-Component-和-Bean区别"><a href="#2-2-Component-和-Bean区别" class="headerlink" title="2.2 @Component 和 @Bean区别"></a>2.2 @Component 和 @Bean区别</h3><ul><li>@Componenet 主要用于类的注解。 @Bean主要用于方法</li><li>@Componnet 主要是通过类路径扫描获得的，比如@ComponentScan，但是@Bean是在标有该注解的方法中定义产生这个bean，@Bean告诉了Spring，这个是某个类的实例，当我需要的时候，要还给我。</li><li>@Bean比@Component更加灵活，很多时候我们只能通过@Bean来注册bean，比如引用第三方库的时候。</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AppConfig</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> <span class="token class-name">TransferService</span> <span class="token function">transferService</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">TransferServiceImpl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的代码相当于如下的xml文件</p><pre class="line-numbers language-XML" data-language="XML"><code class="language-XML">&lt;beans&gt;    &lt;bean id&#x3D;&quot;transferService&quot; class&#x3D;&quot;com.acme.TransferServiceImpl&quot;&#x2F;&gt;&lt;&#x2F;beans&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>下面这个例子是通过 @Component 无法实现的。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Bean</span><span class="token keyword">public</span> <span class="token class-name">OneService</span> <span class="token function">getService</span><span class="token punctuation">(</span>status<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">case</span> <span class="token punctuation">(</span>status<span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>        when <span class="token number">1</span><span class="token operator">:</span>                <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token function">serviceImpl1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        when <span class="token number">2</span><span class="token operator">:</span>                <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token function">serviceImpl2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        when <span class="token number">3</span><span class="token operator">:</span>                <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token function">serviceImpl3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-3-Autowired和-Resource区别是什么？"><a href="#2-3-Autowired和-Resource区别是什么？" class="headerlink" title="2.3 @Autowired和@Resource区别是什么？"></a>2.3 @Autowired和@Resource区别是什么？</h3><p><font style="background: gray">Autowired</font><br>属于spring内置的注解，默认注入的方式为byType，也就是说会优先按照类型去匹配，但是存在如下的问题</p><ul><li><p>一个接口可能会出现同类型有很多个不同的实现类，这样就会造成byType混乱，找不到对应的实现类。这种情况下的实现办法如下：  </p><ul><li>spring会采用byName的形式来进行匹配，也就是根据类名的小写首字母的形式来进行匹配。举例  <pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Autowired</span><span class="token keyword">private</span> <span class="token class-name">SmService</span> smService<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul><p>  再比如：Sms有两个实现类，<font style="background:ddd gray">SmsServiceImpl1</font>和 <font style="background: gray">SmsServiceImpl2</font>此时都已经被spring容器管理，我们应该这样使用<br>  <pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 报错，byName 和 byType 都无法匹配到 bean</span><span class="token annotation punctuation">@Autowired</span><span class="token keyword">private</span> <span class="token class-name">SmsService</span> smsService<span class="token punctuation">;</span><span class="token comment">// 正确注入 SmsServiceImpl1 对象对应的 bean</span><span class="token annotation punctuation">@Autowired</span><span class="token keyword">private</span> <span class="token class-name">SmsService</span> smsServiceImpl1<span class="token punctuation">;</span><span class="token comment">// 正确注入  SmsServiceImpl1 对象对应的 bean</span><span class="token comment">// smsServiceImpl1 就是我们上面所说的名称</span><span class="token annotation punctuation">@Autowired</span><span class="token annotation punctuation">@Qualifier</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"smsServiceImpl1"</span><span class="token punctuation">)</span><span class="token keyword">private</span> <span class="token class-name">SmsService</span> smsService<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>  这里推荐使用@Qualifier来指定使用的类。</p><p>  <strong>@Resource</strong> 是jdk提供的注解，默认的注入方式为byName，如果无法通过byName注入，那么久通过byType进行注入。<br>  Resource有两个比较重要的属性：</p><ul><li>Name：名称</li><li>type：类型</li></ul></li></ul><p>总结一下：</p><ul><li>@Autowired 是 Spring 提供的注解，@Resource 是 JDK 提供的注解。</li><li>Autowired 默认的注入方式为byType（根据类型进行匹配），@Resource默认注入方式为 byName（根据名称进行匹配）。</li><li>在一个接口存在多个实现类的时候，二者都需要通过名称才能正确匹配到对应的bean，Autowired可以通过@Qualifer类显示的指定名称，@Resourse可以通过name属性来显示指定名称。</li></ul><h1 id="2-对SpringAoP的理解"><a href="#2-对SpringAoP的理解" class="headerlink" title="2.对SpringAoP的理解"></a>2.对SpringAoP的理解</h1><p>基于动态代理的，如果被代理的对象实现了某个接口，那么会用JDK Proxy代理，对于没有实现接口的对象，就使用cglib代理。</p><h2 id="2-1-Spring-AOP-和-AspectJ-AOP-有什么区别？"><a href="#2-1-Spring-AOP-和-AspectJ-AOP-有什么区别？" class="headerlink" title="2.1 Spring AOP 和 AspectJ AOP 有什么区别？"></a>2.1 Spring AOP 和 AspectJ AOP 有什么区别？</h2><p>也可以用AspectJ，这个是最完整的aop框架。Spring AOP属于是<strong>运行时增强</strong>而AspectJ是<strong>编译时增强</strong>，AOP是基于字节码操作。目前AOP已经集成了AspetJ但是，在切面比较少的情况下，两者差异不大，多的时候就用AspectJ，她的速度快很多。</p><h2 id="2-2-多个切面之间的执行顺序？"><a href="#2-2-多个切面之间的执行顺序？" class="headerlink" title="2.2 多个切面之间的执行顺序？"></a>2.2 多个切面之间的执行顺序？</h2><p>通过@Order来进行控制，通过实现Orderd接口重写getOrder方法</p><h1 id="3-Spring-mvc"><a href="#3-Spring-mvc" class="headerlink" title="3. Spring mvc"></a>3. Spring mvc</h1><h2 id="3-1-核心组件"><a href="#3-1-核心组件" class="headerlink" title="3.1 核心组件"></a>3.1 核心组件</h2><ul><li><font style="background:ddd gray">DispatcherServlet</font>： 核心的中央处理器，负责接受请求，分发，并给予客户端响应</li><li>HandlerMapping： 处理器映射器，根据uri去匹配查找能处理的Handler，并会将设计到的拦截器和Handler一起封装。</li><li>HandlerAdapter： 处理器适配器，根据上一步找到的Handler，适配对应执行的Handler</li><li>Handler: 请求处理器，处理实际请求的处理器。</li><li>ViewResolver：视图解析器，根据Handler返回的逻辑视图，解析并渲染真正的视图，并传递给DispatcherServlet。</li></ul><h2 id="3-2-工作原理"><a href="#3-2-工作原理" class="headerlink" title="3.2 工作原理"></a>3.2 工作原理</h2><p><img src="https://raw.githubusercontent.com/guduxingzheplus/blogPic/main/imgs/20230331081801.png" alt="20230331081801"></p><p><font style="background: blue">流程说明（important）：</font></p><ol><li>客户端浏览器发送请求到DispatchServlet</li><li>DispatcherServlet调用HandlerMapping，根据uri寻找合适的Handler（也就是Controller），并且会将请求涉及的拦截器和Handler一起封装返回。</li><li>DispatcherServlet调用HandlerAdapter适配执行Handler</li><li>Handler完成对用户请求的处理后，返回一个ModelAndView对象给DispathcerServlet，ModelAndView就是包含了数据模型以及相应的视图信息。Model是返回的数据对象，View是逻辑上的View</li><li>ViewResolver会根据逻辑View查找实际的view</li><li>DispatcherServlet将返回的Model传给View（视图渲染）</li><li>把view返回给请求者。</li></ol><h2 id="3-3-统一异常处理怎么做"><a href="#3-3-统一异常处理怎么做" class="headerlink" title="3.3 统一异常处理怎么做"></a>3.3 统一异常处理怎么做</h2><p>使用@ControllerAdvice + @ExceptionHandler来处理</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@ControllerAdvice</span><span class="token annotation punctuation">@ResponseBody</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">GlobalExceptionHandler</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@ExceptionHandler</span><span class="token punctuation">(</span><span class="token class-name">BaseException</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token class-name">ResponseEntity</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> <span class="token function">handleAppException</span><span class="token punctuation">(</span><span class="token class-name">BaseException</span> ex<span class="token punctuation">,</span> <span class="token class-name">HttpServletRequest</span> request<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token comment">//......</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@ExceptionHandler</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token class-name">ResourceNotFoundException</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token class-name">ResponseEntity</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">ErrorReponse</span><span class="token punctuation">></span></span> <span class="token function">handleResourceNotFoundException</span><span class="token punctuation">(</span><span class="token class-name">ResourceNotFoundException</span> ex<span class="token punctuation">,</span> <span class="token class-name">HttpServletRequest</span> request<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token comment">//......</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>@ControllerAdvice是controller增强器，主要三个作用，全局异常处理，全局数据绑定，全局数据预处理</p><p>这种异常处理方式下，会给所有或者指定的 Controller 织入异常处理的逻辑（AOP），当 Controller 中的方法抛出异常的时候，由被@ExceptionHandler 注解修饰的方法进行处理。</p><h1 id="4-Spring-Data-JPA"><a href="#4-Spring-Data-JPA" class="headerlink" title="4. Spring Data JPA"></a>4. Spring Data JPA</h1><h2 id="4-1-如何用JPA对数据库中的某个字段非持久化"><a href="#4-1-如何用JPA对数据库中的某个字段非持久化" class="headerlink" title="4.1 如何用JPA对数据库中的某个字段非持久化"></a>4.1 如何用JPA对数据库中的某个字段非持久化</h2><p>所谓非持久化，就是在实体类中，让某个字段不被数据库存储。<br>可以采用如下方法</p><ul><li><p>static String s1; &#x2F;&#x2F;加了static</p></li><li><p>final String s1 &#x3D; “ss”;  &#x2F;&#x2F;final修饰</p></li><li><p>transient String s1; &#x2F;&#x2F;trainsient修饰</p></li><li><p>@Transient &#x2F;&#x2F;加了注解<br>String s1;</p><p>主要使用后两种比较多</p></li></ul><h2 id="4-2-PA-的审计功能是做什么的？有什么用？"><a href="#4-2-PA-的审计功能是做什么的？有什么用？" class="headerlink" title="4.2 PA 的审计功能是做什么的？有什么用？"></a>4.2 PA 的审计功能是做什么的？有什么用？</h2><p>审计功能主要是帮助我们记录数据库操作的具体行为比如某条记录是谁创建的、什么时间创建的、最后修改人是谁、最后修改时间是什么时候。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Data</span><span class="token annotation punctuation">@AllArgsConstructor</span><span class="token annotation punctuation">@NoArgsConstructor</span><span class="token annotation punctuation">@MappedSuperclass</span><span class="token annotation punctuation">@EntityListeners</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token class-name">AuditingEntityListener</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">AbstractAuditBase</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@CreatedDate</span>    <span class="token annotation punctuation">@Column</span><span class="token punctuation">(</span>updatable <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">)</span>    <span class="token annotation punctuation">@JsonIgnore</span>    <span class="token keyword">private</span> <span class="token class-name">Instant</span> createdAt<span class="token punctuation">;</span>    <span class="token annotation punctuation">@LastModifiedDate</span>    <span class="token annotation punctuation">@JsonIgnore</span>    <span class="token keyword">private</span> <span class="token class-name">Instant</span> updatedAt<span class="token punctuation">;</span>    <span class="token annotation punctuation">@CreatedBy</span>    <span class="token annotation punctuation">@Column</span><span class="token punctuation">(</span>updatable <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">)</span>    <span class="token annotation punctuation">@JsonIgnore</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> createdBy<span class="token punctuation">;</span>    <span class="token annotation punctuation">@LastModifiedBy</span>    <span class="token annotation punctuation">@JsonIgnore</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> updatedBy<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>@CreatedDate: 表示该字段为创建时间字段，在这个实体被 insert 的时候，会设置值</li><li>@CreatedBy :表示该字段为创建人，在这个实体被 insert 的时候，会设置值@LastModifiedDate、@LastModifiedBy同理。</li></ul><h1 id="5-Spring-Security"><a href="#5-Spring-Security" class="headerlink" title="5. Spring Security"></a>5. Spring Security</h1><h2 id="5-1-有哪些请求权限的方法"><a href="#5-1-有哪些请求权限的方法" class="headerlink" title="5.1 有哪些请求权限的方法"></a>5.1 有哪些请求权限的方法</h2><ul><li>permitAll() ：无条件允许任何形式访问，不管你登录还是没有登录。</li><li>anonymous() ：允许匿名访问，也就是没有登录才可以访问。</li><li>denyAll() ：无条件决绝任何形式的访问。</li><li>authenticated()：只允许已认证的用户访问。</li><li>fullyAuthenticated() ：只允许已经登录或者通过 </li><li>remember-me 登录的用户访问。</li><li>hasRole(String) : 只允许指定的角色访问。</li><li>hasAnyRole(String)  : 指定一个或者多个角色，满足其一的用户即可访问。</li><li>hasAuthority(String) ：只允许具有指定权限的用户访问</li><li>hasAnyAuthority(String) ：指定一个或者多个权限，满足其一的用户即可访问。</li><li>hasIpAddress(String) : 只允许指定 ip 的用户访问。</li></ul><h2 id="5-2-hasRole-和-hasAuthority-有区别吗？"><a href="#5-2-hasRole-和-hasAuthority-有区别吗？" class="headerlink" title="5.2 hasRole 和 hasAuthority 有区别吗？"></a>5.2 hasRole 和 hasAuthority 有区别吗？</h2><p>二者是存在区别的，hasRole会要求数据库中的权限字段加上ROLE_前缀，而hasAuthority并不要求。从设计层面上讲，hasRole是角色表，而角色是权限的集合。也就是说，使用 hasAuthority 更具有一致性，你不用考虑要不要加 ROLE_ 前缀，数据库什么样这里就是什么样！而 hasRole 则不同，代码里如果写的是 admin，框架会自动加上 ROLE_ 前缀，所以数据库就必须是 ROLE_admin。</p><h2 id="5-3-对密码加密？"><a href="#5-3-对密码加密？" class="headerlink" title="5.3 对密码加密？"></a>5.3 对密码加密？</h2><p>使用bcrypt，当然也可以自己设计加密算法，继承PasswordEncoder类</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">PasswordEncoder</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 加密也就是对原始密码进行编码</span>    <span class="token class-name">String</span> <span class="token function">encode</span><span class="token punctuation">(</span><span class="token class-name">CharSequence</span> var1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 比对原始密码和数据库中保存的密码</span>    <span class="token keyword">boolean</span> <span class="token function">matches</span><span class="token punctuation">(</span><span class="token class-name">CharSequence</span> var1<span class="token punctuation">,</span> <span class="token class-name">String</span> var2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 判断加密密码是否需要再次进行加密，默认返回 false</span>    <span class="token keyword">default</span> <span class="token keyword">boolean</span> <span class="token function">upgradeEncoding</span><span class="token punctuation">(</span><span class="token class-name">String</span> encodedPassword<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="5-4-更换密码加密算法"><a href="#5-4-更换密码加密算法" class="headerlink" title="5.4 更换密码加密算法"></a>5.4 更换密码加密算法</h2><p>使用DelegatingPasswordEncoder兼容多种不同的加密方案。这其实是个代理类，并非全新的加密算法，他做的事情就是代理加密算法实现类。</p>]]></content>
      
      
      <categories>
          
          <category> spring面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
