<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>滑动窗口典型题</title>
      <link href="/2023/04/20/shuang-hua-dong-chuang-kou-dian-xing-ti/"/>
      <url>/2023/04/20/shuang-hua-dong-chuang-kou-dian-xing-ti/</url>
      
        <content type="html"><![CDATA[<h1 id="1-单滑窗模板"><a href="#1-单滑窗模板" class="headerlink" title="1.单滑窗模板"></a>1.单滑窗模板</h1><p>滑窗条件：</p><ol><li>研究对象为单个元素，而不是子数组的元素之和</li><li>约束条件是一个范围</li></ol><p><img src="https://raw.githubusercontent.com/guduxingzheplus/blogPic/main/imgs/20230420214434.png" alt="20230420214434"><br><img src="https://raw.githubusercontent.com/guduxingzheplus/blogPic/main/imgs/20230420214522.png" alt="20230420214522"><br>这个题就是典型的滑动窗口的题目，我们使用HashMap来进行滑动，对于示例4这样的我们发现，如果用双指针，则无法准确定位两个指针的位置（两个已有的不同的数字的位置），为什么用hashMap不用其他数据结构呢？还是例4，我们发现对于12112这个序列，再往后滑动，会直接将开头位置设置为2，而不是1开头，这就需要我们记录每个元素的使用次数，如果全用完了就从hashMap中删除。对于12112序列，最后剩下的是2，就是这个道理。代码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">totalFruit</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> fruits<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> right <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> fruits<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">></span></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> re <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>right <span class="token operator">&lt;</span> n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> temp <span class="token operator">=</span> fruits<span class="token punctuation">[</span>right<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>temp<span class="token punctuation">,</span> map<span class="token punctuation">.</span><span class="token function">getOrDefault</span><span class="token punctuation">(</span>temp<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token keyword">int</span> lt <span class="token operator">=</span> fruits<span class="token punctuation">[</span>left<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>lt<span class="token punctuation">,</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>lt<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>lt<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                    map<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>lt<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>            re <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>re<span class="token punctuation">,</span> right <span class="token operator">-</span> left<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> re<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="2-范围滑窗"><a href="#2-范围滑窗" class="headerlink" title="2. 范围滑窗"></a>2. 范围滑窗</h1><p><img src="https://raw.githubusercontent.com/guduxingzheplus/blogPic/main/imgs/20230420214906.png" alt="20230420214906"></p><p>在这个题目中，给出的最大值范围是[left,right]我们不能直接去限定滑窗内的最大值的范围为[left,right]，这样是非常困难的，我们不妨限定两部分，第一部分，找出最大值比left - 1小的数组的数量，第二部分，找到最大值比right小的部分，两者做差，就是最终的值。这个思想在下一题也使用到了。我们注意代码的</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">ans <span class="token operator">+=</span> temp<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这样可以求出全部的子数组的数量，为什么呢？</p><p>举个例子：</p><p>1,2,3,4能组成几个数组？</p><p>答案： 1+2+3+4， 所以发现了规律没有？就是不断的加当前数字。我们在</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">temp2 <span class="token operator">&lt;</span> maxNum<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这里将只要小于就加一，同时一旦发现不小于，不满足条件就清空重来。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">numSubarrayBoundedMax</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token function">nt</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> right<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token function">nt</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> left <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">nt</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span>nums<span class="token punctuation">,</span> <span class="token keyword">int</span> maxNum<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> ans <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">int</span> temp <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> temp2 <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>temp2 <span class="token operator">&lt;=</span> maxNum<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                temp<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">else</span><span class="token punctuation">&#123;</span>                temp <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            ans <span class="token operator">+=</span> temp<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="3-范围滑窗变种"><a href="#3-范围滑窗变种" class="headerlink" title="3. 范围滑窗变种"></a>3. 范围滑窗变种</h1><ol start="992"><li>K 个不同整数的子数组<br><img src="https://raw.githubusercontent.com/guduxingzheplus/blogPic/main/imgs/20230420172551.png" alt="20230420172551"></li></ol><p>最传统的想法就是使用基本的单滑动窗口来做，代码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">HashSet</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">Set</span></span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">subarraysWithKDistinct</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">int</span> startIndex <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> endIndex <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">int</span> re <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> set <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token keyword">int</span> temp <span class="token operator">=</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                set<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>temp<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>set<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> k<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                    re<span class="token operator">++</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>set<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> k<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                    set<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>            set<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> re<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但是会超时，因为时间复杂度比较高，主要的时间都浪费在了反复判断是不是重复数字上。需要想办法使得其具有记忆化效果，于是使用双重滑窗。</p><p>思路如下：</p><p><img src="https://raw.githubusercontent.com/guduxingzheplus/blogPic/main/imgs/20230420172815.png" alt="20230420172815"><br><img src="https://raw.githubusercontent.com/guduxingzheplus/blogPic/main/imgs/20230420172828.png" alt="20230420172828"></p><p>关键在于怎么找最远出现的满足K个不同数字的下标。我们可以采用HashMap的形式来记录，从左到右，如果hashMap中的数量大于等于k，那么就删除最左侧的元素(left指针记录)，这样，我们就找到了位于最远的满足k个不同字符的下标这一条件了。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">subarraysWithKDistinct</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// // [k, k] = [-∞, k] - [-∞, k - 1]</span>    <span class="token keyword">return</span> <span class="token function">atMostK</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> k<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token function">atMostK</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 计算不同整数的个数不超过 k 的子数组</span><span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">atMostK</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">></span></span> window <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> right <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> ans <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>right <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> g <span class="token operator">=</span> nums<span class="token punctuation">[</span>right<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        window<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>g<span class="token punctuation">,</span> window<span class="token punctuation">.</span><span class="token function">getOrDefault</span><span class="token punctuation">(</span>g<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 收缩窗口</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>window<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> k<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> d <span class="token operator">=</span> nums<span class="token punctuation">[</span>left<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            window<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>d<span class="token punctuation">,</span> window<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>window<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> window<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 更新答案</span>        <span class="token comment">// 以 nums[right] 结尾的子数组数量</span>        ans <span class="token operator">+=</span> <span class="token punctuation">(</span>right <span class="token operator">-</span> left<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> ans<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 力扣刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 力扣刷题 </tag>
            
            <tag> 滑动窗口 </tag>
            
            <tag> 双滑动窗口 </tag>
            
            <tag> 滑窗模板 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>session cookie jwt cookie 区别</title>
      <link href="/2023/04/19/session-cookie-jwt-cookie-qu-bie/"/>
      <url>/2023/04/19/session-cookie-jwt-cookie-qu-bie/</url>
      
        <content type="html"><![CDATA[<h1 id="1-什么是Cookie？"><a href="#1-什么是Cookie？" class="headerlink" title="1. 什么是Cookie？"></a>1. 什么是Cookie？</h1><ul><li>cookie 存储在客户端： cookie 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。</li><li>cookie 是不可跨域的： 每个 cookie 都会绑定单一的域名，无法在别的域名下获取使用，一级域名和二级域名之间是允许共享使用的（靠的是 domain）。</li></ul><h1 id="2-什么是session？"><a href="#2-什么是session？" class="headerlink" title="2. 什么是session？"></a>2. 什么是session？</h1><ul><li><p>session 是一种记录服务器和客户端会话状态的机制</p></li><li><p>session是基于cookie实现的， session存储在服务器端， sessionID会存储到客户端的cookie中<br><img src="https://raw.githubusercontent.com/guduxingzheplus/blogPic/main/imgs/20230419150720.png" alt="20230419150720"></p></li><li><p>session认证流程：</p><ul><li>用户第一次请求服务器的时候，服务器根据用户提交的相关信息，创建对应的 Session</li><li>请求返回时将此 Session 的唯一标识信息 SessionID 返回给浏览器</li><li>浏览器接收到服务器返回的 SessionID 信息后，会将此信息存入到 Cookie 中，同时 Cookie 记录此 SessionID 属于哪个域名</li><li>当用户第二次访问服务器的时候，请求会自动判断此域名下是否存在 Cookie 信息，如果存在自动将 Cookie 信息也发送给服务端，服务端会从 Cookie 中获取 SessionID，再根据 SessionID 查找对应的 Session 信息，如果没有找到说明用户没有登录或者登录失效，如果找到 Session 证明用户已经登录可执行后面操作</li></ul></li></ul><h1 id="3-什么是-Token（令牌）"><a href="#3-什么是-Token（令牌）" class="headerlink" title="3. 什么是 Token（令牌）"></a>3. 什么是 Token（令牌）</h1><ul><li>访问资源接口（api）时需要的资源凭证</li><li>简单token的组成： uid（用户身份标识），time（当前时间戳），sign（签名 token前几位以哈希压缩）</li><li>特点：<ul><li>服务端无状态化</li><li>支持移动端设备</li><li>安全</li><li>支持跨程序</li></ul></li><li>token 验证流程：<br><img src="https://raw.githubusercontent.com/guduxingzheplus/blogPic/main/imgs/20230419151515.png" alt="20230419151515"></li></ul><ol><li>客户端使用用户名跟密码请求登录</li><li>服务端收到请求，去验证用户名与密码</li><li>验证成功后，服务端会签发一个 token 并把这个 token 发送给客户端</li><li>客户端收到 token 以后，会把它存储起来，比如放在 cookie 里或者 localStorage 里</li><li>客户端每次向服务端请求资源的时候需要带着服务端签发的 token</li><li>服务端收到请求，然后去验证客户端请求里面带着的 token ，如果验证成功，就向客户端返回请求的数据</li></ol><p>注意：</p><ul><li>每次请求都要带token，放到http的header中</li><li>基于token是无状态认证，服务端不用存token，用解析token的时间换区session的存储空间</li><li>token 完全由应用管理，所以它可以避开同源策略</li></ul><h1 id="4-什么是RefreshToken"><a href="#4-什么是RefreshToken" class="headerlink" title="4. 什么是RefreshToken"></a>4. 什么是RefreshToken</h1><p>就是专门用于刷新access token的一种token，如果没有refresh token，每次刷新都需要用户手动输入密码，这很不友好。有了refresh token，直接调用refresh token 去更新accesstoken</p><p><img src="https://raw.githubusercontent.com/guduxingzheplus/blogPic/main/imgs/20230419152255.png" alt="20230419152255"></p><ul><li>Access Token 的有效期比较短，当 Acesss Token 由于过期而失效时，使用 Refresh Token 就可以获取到新的 Token，如果 Refresh Token 也失效了，用户就只能重新登录了。</li><li>Refresh Token 及过期时间是存储在服务器的数据库中，只有在申请新的 Acesss Token 时才会验证，不会对业务接口响应时间造成影响，也不需要向 Session 一样一直保持在内存中以应对大量的请求。</li></ul><h1 id="5-什么是jwt"><a href="#5-什么是jwt" class="headerlink" title="5. 什么是jwt"></a>5. 什么是jwt</h1><ul><li>JSON Web Token（简称 JWT）是目前最流行的跨域认证解决方案。<br>是一种认证授权机制。</li><li>JWT 是为了在网络应用环境间传递声明而执行的一种基于 JSON 的开放标准（RFC 7519）。JWT 的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源。比如用在用户登录上。</li><li>可以使用 HMAC 算法或者是 RSA 的公&#x2F;私秘钥对 JWT 进行签名。因为数字签名的存在，这些传递的信息是可信的。<br><img src="https://raw.githubusercontent.com/guduxingzheplus/blogPic/main/imgs/20230419152408.png" alt="20230419152408"></li></ul><p>JWT 认证流程：</p><ul><li><p>用户输入用户名&#x2F;密码登录，服务端认证成功后，会返回给客户端一个 JWT</p></li><li><p>客户端将 token 保存到本地（通常使用 localstorage，也可以使用 cookie）</p></li><li><p>当用户希望访问一个受保护的路由或者资源的时候，需要请求头的 Authorization 字段中使用Bearer 模式添加 JWT，其内容看起来是下面这样</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">Authorization: Bearer <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>token</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>服务端的保护路由将会检查请求头 Authorization 中的 JWT 信息，如果合法，则允许用户的行为</p></li><li><p>因为 JWT 是自包含的（内部包含了一些会话信息），因此减少了需要查询数据库的需要</p></li><li><p>因为 JWT 并不使用 Cookie 的，所以你可以使用任何域名提供你的 API 服务而不需要担心跨域资源共享问题（CORS）</p></li><li><p>因为用户的状态不再存储在服务端的内存中，所以这是一种无状态的认证机制</p></li></ul><h1 id="6-Cookie-和-Session区别"><a href="#6-Cookie-和-Session区别" class="headerlink" title="6.Cookie 和 Session区别"></a>6.Cookie 和 Session区别</h1><ul><li>安全性：Session比cookie更安全，session是存在服务器的</li><li>存取值的类型不同：cookie只支持字符串数据，session可以存任何数据类型</li><li>有效期不同： cookie可以设置为长时间保持，默认的登录功能。session有效期比较短，客户端关闭或者超时session都会失效。</li></ul><h1 id="7-token-和-session的区别"><a href="#7-token-和-session的区别" class="headerlink" title="7. token 和 session的区别"></a>7. token 和 session的区别</h1><ul><li>session是记录服务器和客户端的会话状态的<strong>机制</strong>，使服务端有状态化，可以记录会话信息，而token是<strong>令牌</strong>，访问资源的接口时所需要的资源凭证，token使得服务端无状态化，不会存储会话信息。</li><li>session和token并不矛盾，作为身份认证，token比session更安全，因为每一个强求都有签名，还能防止重放攻击。而session必须依赖链路层来保证通讯安全。</li><li>所谓 Session 认证只是简单的把 User 信息存储到 Session 里，因为 SessionID 的不可预测性，暂且认为是安全的。而 Token ，如果指的是 OAuth Token 或类似的机制的话，提供的是 认证 和 授权 ，认证是针对用户，授权是针对 App 。其目的是让某 App 有权利访问某用户的信息。这里的 Token 是唯一的。不可以转移到其它 App上，也不可以转到其它用户上。Session 只提供一种简单的认证，即只要有此 SessionID ，即认为有此 User 的全部权利。是需要严格保密的，这个数据应该只保存在站方，不应该共享给其它网站或者第三方 App。所以简单来说：如果你的用户数据可能需要和第三方共享，或者允许第三方调用 API 接口，用 Token 。如果永远只是自己的网站，自己的 App，用什么就无所谓了。</li></ul><h1 id="8-Token-和-JWT-的区别"><a href="#8-Token-和-JWT-的区别" class="headerlink" title="8. Token 和 JWT 的区别"></a>8. Token 和 JWT 的区别</h1><p>相同：</p><ul><li>都是访问资源的令牌</li><li>都是记录用户的信息</li><li>都是使得服务端无状态化</li><li>都是只有验证成功后，客户端才能访问服务端上受保护的资源</li></ul><p>区别：</p><ul><li>token： 服务端验证客户端发过来的token的时候还是需要查询数据库获取用户的信息，然后验证token是否有效</li><li>JWT： 将token和payload加密后存储于客户端，服务端只需要使用秘钥来进行解密校验（因为jwt<strong>自包含性质</strong>存储了部分的会话信息），减少查询数据库的需求。</li></ul><h1 id="9-使用cookie时间，需要考虑的问题"><a href="#9-使用cookie时间，需要考虑的问题" class="headerlink" title="9.使用cookie时间，需要考虑的问题"></a>9.使用cookie时间，需要考虑的问题</h1><ul><li>因为存储在客户端，容易被客户端篡改，使用前需要验证合法性</li><li>不要存储敏感数据，比如用户密码，账户余额</li><li>使用 httpOnly 在一定程度上提高安全性</li><li>尽量减少 cookie 的体积，能存储的数据量不能超过 4kb</li><li>设置正确的 domain 和 path，减少数据传输</li><li>cookie 无法跨域</li><li>一个浏览器针对一个网站最多存 20 个Cookie，浏览器一般只允许存放 - 300 个Cookie</li><li>移动端对 cookie 的支持不是很好，而 session 需要基于 cookie 实现，所以移动端常用的是 token</li></ul><h1 id="10-使用-session-时需要考虑的问题"><a href="#10-使用-session-时需要考虑的问题" class="headerlink" title="10.使用 session 时需要考虑的问题"></a>10.使用 session 时需要考虑的问题</h1><ul><li>将 session 存储在服务器里面，当用户同时在线量比较多时，这些 session 会占据较多的内存，需要在服务端定期的去清理过期的 session</li><li>当网站采用集群部署的时候，会遇到多台 web 服务器之间如何做 session 共享的问题。因为 session 是由单个服务器创建的，但是处理用户请求的服务器不一定是那个创建 session 的服务器，那么该服务器就无法拿到之前已经放入到 session 中的登录凭证之类的信息了。</li><li>当多个应用要共享 session 时，除了以上问题，还会遇到跨域问题，因为不同的应用可能部署的主机不一样，需要在各个应用做好 cookie 跨域的处理。</li><li>sessionId 是存储在 cookie 中的，假如浏览器禁止 cookie 或不支持 cookie 怎么办？ 一般会把 sessionId 跟在 url 参数后面即重写 url，所以 session 不一定非得需要靠 cookie 实现</li><li>移动端对 cookie 的支持不是很好，而 session 需要基于 cookie 实现，所以移动端常用的是 token</li></ul><h1 id="11-使用-token-时需要考虑的问题"><a href="#11-使用-token-时需要考虑的问题" class="headerlink" title="11. 使用 token 时需要考虑的问题"></a>11. 使用 token 时需要考虑的问题</h1><ul><li>如果你认为用数据库来存储 token 会导致查询时间太长，可以选择放在内存当中。比如 redis 很适合你对 token 查询的需求。</li><li>token 完全由应用管理，所以它可以避开同源策略</li><li>token 可以避免 CSRF 攻击(因为不需要 cookie 了)</li><li>移动端对 cookie 的支持不是很好，而 session 需要基于 cookie 实现，所以移动端常用的是 token</li></ul><h1 id="12-使用-JWT-时需要考虑的问题"><a href="#12-使用-JWT-时需要考虑的问题" class="headerlink" title="12. 使用 JWT 时需要考虑的问题"></a>12. 使用 JWT 时需要考虑的问题</h1><ul><li>因为 JWT 并不依赖 Cookie 的，所以你可以使用任何域名提供你的 API 服务而不需要担心跨域资源共享问题（CORS）</li><li>JWT 默认是不加密，但也是可以加密的。生成原始 Token 以后，可以用密钥再加密一次。</li><li>JWT 不加密的情况下，不能将秘密数据写入 JWT。</li><li>JWT 不仅可以用于认证，也可以用于交换信息。有效使用 JWT，可以降低服务器查询数据库的次数。</li><li>JWT 最大的优势是服务器不再需要存储 Session，使得服务器认证鉴权业务可以方便扩展。但这也是 JWT 最大的缺点：由于服务器不需要存储 Session 状态，因此使用过程中无法废弃某个 Token 或者更改 Token 的权限。也就是说一旦 JWT 签发了，到期之前就会始终有效，除非服务器部署额外的逻辑。</li><li>JWT 本身包含了认证信息，一旦泄露，任何人都可以获得该令牌的所有权限。为了减少盗用，JWT的有效期应该设置得比较短。对于一些比较重要的权限，使用时应该再次对用户进行认证。</li><li>JWT 适合一次性的命令认证，颁发一个有效期极短的 JWT，即使暴露了危险也很小，由于每次操作都会生成新的 JWT，因此也没必要保存 JWT，真正实现无状态。</li><li>为了减少盗用，JWT 不应该使用 HTTP 协议明码传输，要使用 HTTPS 协议传输。</li></ul><h1 id="13-分布式架构下-session-共享方案"><a href="#13-分布式架构下-session-共享方案" class="headerlink" title="13. 分布式架构下 session 共享方案"></a>13. 分布式架构下 session 共享方案</h1><h2 id="13-1-session-复制"><a href="#13-1-session-复制" class="headerlink" title="13.1. session 复制"></a>13.1. session 复制</h2><p>任何一个服务器上的 session 发生改变（增删改），该节点会把这个 session 的所有内容序列化，然后广播给所有其它节点，不管其他服务器需不需要 session ，以此来保证 session 同步</p><p>优点： 可容错，各个服务器间 session 能够实时响应。</p><p>缺点： 会对网络负荷造成一定压力，如果 session 量大的话可能会造成网络堵塞，拖慢服务器性能。</p><h2 id="13-2-粘性-session-x2F-IP-绑定策略"><a href="#13-2-粘性-session-x2F-IP-绑定策略" class="headerlink" title="13.2. 粘性 session &#x2F;IP 绑定策略"></a>13.2. 粘性 session &#x2F;IP 绑定策略</h2><p>采用 Ngnix 中的 ip_hash 机制，将某个 ip的所有请求都定向到同一台服务器上，即将用户与服务器绑定。 用户第一次请求时，负载均衡器将用户的请求转发到了 A 服务器上，如果负载均衡器设置了粘性 session 的话，那么用户以后的每次请求都会转发到 A 服务器上，相当于把用户和 A 服务器粘到了一块，这就是粘性 session 机制。</p><p>优点： 简单，不需要对 session 做任何处理。</p><p>缺点： 缺乏容错性，如果当前访问的服务器发生故障，用户被转移到第二个服务器上时，他的 session 信息都将失效。</p><p>适用场景： 发生故障对客户产生的影响较小；服务器发生故障是低概率事件<br>。<br>实现方式： 以 Nginx 为例，在 upstream 模块配置 ip_hash 属性即可实现粘性 session。</p><h2 id="13-3-session-共享（常用）"><a href="#13-3-session-共享（常用）" class="headerlink" title="13.3. session 共享（常用）"></a>13.3. session 共享（常用）</h2><p>使用分布式缓存方案比如 Memcached 、Redis 来缓存 session，但是要求 Memcached 或 Redis 必须是集群<br>把 session 放到 Redis 中存储，虽然架构上变得复杂，并且需要多访问一次 Redis ，但是这种方案带来的好处也是很大的：</p><p>实现了 session 共享；<br>可以水平扩展（增加 Redis 服务器）；<br>服务器重启 session 不丢失（不过也要注意 session 在 Redis 中的刷新&#x2F;失效机制）；<br>不仅可以跨服务器 session 共享，甚至可以跨平台（例如网页端和 APP 端）<br><img src="https://raw.githubusercontent.com/guduxingzheplus/blogPic/main/imgs/20230420171956.png" alt="20230420171956"></p><h2 id="13-4"><a href="#13-4" class="headerlink" title="13.4"></a>13.4</h2><ol start="4"><li>session 持久化</li></ol><p>将 session 存储到数据库中，保证 session 的持久化</p><p>优点： 服务器出现问题，session 不会丢失</p><p>缺点： 如果网站的访问量很大，把 session 存储到数据库中，会对数据库造成很大压力，还需要增加额外的开销维护数据库。</p>]]></content>
      
      
      <categories>
          
          <category> 认证授权 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>认证授权</title>
      <link href="/2023/04/19/ren-zheng-shou-quan/"/>
      <url>/2023/04/19/ren-zheng-shou-quan/</url>
      
        <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E8%AE%A4%E8%AF%81%E5%92%8C%E6%8E%88%E6%9D%83%E5%8C%BA%E5%88%AB">认证和授权区别</a></li><li><a href="#rbac">RBAC</a></li><li><a href="#cookie">cookie</a></li><li><a href="#cookie-%E5%92%8C-session-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB">Cookie 和 Session 有什么区别？</a></li><li><a href="#cookie--session-%E6%96%B9%E6%A1%88%E9%AA%8C%E8%AF%81%E7%94%A8%E6%88%B7%E7%9A%84%E8%BA%AB%E4%BB%BD">cookie + session 方案验证用户的身份</a></li><li><a href="#%E5%A4%9A%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%8A%82%E7%82%B9%E4%B8%8B-session-cookie-%E6%96%B9%E6%A1%88%E5%A6%82%E4%BD%95%E5%81%9A">多服务器节点下 Session-Cookie 方案如何做？</a></li><li><a href="#%E6%B2%A1%E6%9C%89cookie%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8session">没有cookie是否可以使用session？</a></li><li><a href="#cookie-%E4%B8%8D%E5%8F%AF%E4%BB%A5%E9%98%B2%E6%AD%A2csrf%E6%94%BB%E5%87%BB%E8%80%8Ctoken%E5%8F%AF%E4%BB%A5">cookie 不可以防止csrf攻击，而token可以？</a></li><li><a href="#jwt">JWT</a><ul><li><a href="#jwt%E7%9A%84%E4%BC%98%E5%8A%BF">jwt的优势</a></li><li><a href="#jwt%E7%9A%84%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86">JWT的组成部分</a></li><li><a href="#%E5%9F%BA%E4%BA%8Ejwt%E8%BF%9B%E8%A1%8C%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81">基于JWT进行身份验证</a></li><li><a href="#%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2-jwt-%E8%A2%AB%E7%AF%A1%E6%94%B9">如何防止 JWT 被篡改？</a></li><li><a href="#%E9%82%A3%E4%B8%BA%E4%BB%80%E4%B9%88-jwt-%E4%B8%8D%E4%BC%9A%E5%AD%98%E5%9C%A8csrf%E6%94%BB%E5%87%BB%E9%97%AE%E9%A2%98">那为什么 JWT 不会存在csrf攻击问题？</a></li><li><a href="#token%E5%92%8Cjwt%E5%8C%BA%E5%88%AB">token和jwt区别</a></li><li><a href="#jwt%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95">JWT身份认证常见问题及解决办法</a><ul><li><a href="#%E6%B3%A8%E9%94%80%E7%99%BB%E5%BD%95%E5%9C%BA%E6%99%AF%E4%B8%8Bjwt%E8%BF%98%E6%9C%89%E6%95%88">注销登录场景下JWT还有效</a><ul><li><a href="#%E5%B0%86jwt%E5%AD%98%E5%85%A5%E5%86%85%E5%AD%98%E6%95%B0%E6%8D%AE%E5%BA%93">将JWT存入内存数据库</a></li><li><a href="#%E9%BB%91%E5%90%8D%E5%8D%95%E6%9C%BA%E5%88%B6">黑名单机制</a></li><li><a href="#%E4%BF%AE%E6%94%B9%E7%A7%98%E9%92%A5">修改秘钥</a></li><li><a href="#%E4%BF%9D%E8%AF%81%E4%BB%A4%E7%89%8C%E7%9A%84%E7%9F%AD%E6%9C%9F%E6%9C%89%E6%95%88%E5%B9%B6%E8%BF%9B%E8%A1%8C%E7%BB%AD%E7%AD%BE">保证令牌的短期有效，并进行续签</a></li></ul></li><li><a href="#jwt%E7%BB%AD%E7%AD%BE%E9%97%AE%E9%A2%98">JWT续签问题</a></li></ul></li></ul></li></ul><!-- /TOC --><h1 id="1-认证和授权区别"><a href="#1-认证和授权区别" class="headerlink" title="1.认证和授权区别"></a>1.认证和授权区别</h1><ul><li>认证是确认系统中是否有这个用户</li><li>授权是查看这个用户有没有权限</li></ul><h1 id="2-RBAC"><a href="#2-RBAC" class="headerlink" title="2.RBAC"></a>2.RBAC</h1><p>全称（Role - Base - Access - Control) </p><p>也就是说是基于角色的权限访问控制，用户关联角色，角色关联权限。<br>简单的说就是，一个用户可以有多个角色，一个角色拥有若干权限，一般通过多表实现，下面就是一个5表实现的例子<br><img src="https://raw.githubusercontent.com/guduxingzheplus/blogPic/main/imgs/20230419101641.png" alt="20230419101641"></p><p><img src="https://raw.githubusercontent.com/guduxingzheplus/blogPic/main/imgs/20230419101649.png" alt="20230419101649"></p><h1 id="3-cookie"><a href="#3-cookie" class="headerlink" title="3. cookie"></a>3. cookie</h1><p>简单来说： Cookie 存放在客户端，一般用来保存用户信息。</p><ol><li>我们在 Cookie 中保存已经登录过的用户信息，下次访问网站的时候页面可以自动帮你登录的一些基本信息给填了。除此之外，Cookie 还能保存用户首选项，主题和其他设置信息。</li><li>使用 Cookie 保存 SessionId 或者 Token ，向后端发送请求的时候带上 Cookie，这样后端就能取到 Session 或者 Token 了。这样就能记录用户当前的状态了，因为 HTTP 协议是无状态的。</li><li>Cookie 还可以用来记录和分析用户行为。举个简单的例子你在网上购物的时候，因为 HTTP 协议是没有状态的，如果服务器想要获取你在某个页面的停留状态或者看了哪些商品，一种常用的实现方式就是将这些信息存放在 Cookie</li></ol><h1 id="4-Cookie-和-Session-有什么区别？"><a href="#4-Cookie-和-Session-有什么区别？" class="headerlink" title="4. Cookie 和 Session 有什么区别？"></a>4. Cookie 和 Session 有什么区别？</h1><ol><li>首先二者的存储位置不一样，cookie存储在客户端，session存储在服务端。</li><li>session主要是通过服务器记录用户的状态的，典型的场景是购物车，当添加商品到购物车的时候，服务器不知道是那个用户添加的，因为http是无状态的。服务器给特定的用户创建特定的session之后就可以识别并跟踪用户了</li></ol><h1 id="5-cookie-session-方案验证用户的身份"><a href="#5-cookie-session-方案验证用户的身份" class="headerlink" title="5. cookie + session 方案验证用户的身份"></a>5. cookie + session 方案验证用户的身份</h1><p><img src="https://raw.githubusercontent.com/guduxingzheplus/blogPic/main/imgs/20230419102153.png" alt="20230419102153"></p><ol><li>用户向服务器发送用户名、密码、验证码用于登陆系统。</li><li>服务器验证通过后，服务器为用户创建一个 Session，并将 Session 信息存储起来。</li><li>服务器向用户返回一个 SessionID，写入用户的 Cookie。</li><li>当用户保持登录状态时，Cookie 将与每个后续请求一起被发送出去。</li><li>服务器可以将存储在 Cookie 上的 SessionID 与存储在内存中或者数据库中的 Session 信息进行比较，以验证用户的身份，返回给用户客户端响应信息的时候会附带用户当前的状态。</li></ol><p><strong>使用 Session 的时候需要注意下面几个点：</strong></p><ol><li>依赖 Session 的关键业务一定要确保客户端开启了 Cookie。</li><li>注意 Session 的过期时间。</li></ol><h1 id="6-多服务器节点下-Session-Cookie-方案如何做？"><a href="#6-多服务器节点下-Session-Cookie-方案如何做？" class="headerlink" title="6.多服务器节点下 Session-Cookie 方案如何做？"></a>6.多服务器节点下 Session-Cookie 方案如何做？</h1><p>为什么多节点会出现问题？</p><p>因为session可能路由到其并非第一次请求的服务器上，而其他服务器，并没有保存这个请求的sessionId,造成无法识别的问题。</p><p>解决办法：</p><ol><li>通过hash保证每次都被ngix转发到相同的服务器上</li><li>服务器端同步session，但是代价很大</li><li>单独使用一个所有服务器都能访问的数据节点，来存放session信息。</li></ol><h1 id="7-没有cookie是否可以使用session？"><a href="#7-没有cookie是否可以使用session？" class="headerlink" title="7. 没有cookie是否可以使用session？"></a>7. 没有cookie是否可以使用session？</h1><p> 当然是可以的，可以将sessionID直接封装到请求的url里面。当然需要加密。</p><h1 id="8-cookie-不可以防止csrf攻击，而token可以？"><a href="#8-cookie-不可以防止csrf攻击，而token可以？" class="headerlink" title="8. cookie 不可以防止csrf攻击，而token可以？"></a>8. cookie 不可以防止csrf攻击，而token可以？</h1><p>csrf攻击： 跨站请求伪造，就是通过盗取用户的cookie中的sissionId来进行发送一些消息。</p><p>因为cookie会保存sessionId，服务端是用过这个sessionId来识别用户的，服务端只要拿到sessionID就认为是正确的用户登录。</p><p>但是token不会，token存放在locaStorage中，然后我们在前端通过某些方式会发给每个到后端的请求上添加这个token，这样就不会出现csrf的问题，因为即使点击了非法请求发送了请求到服务端，请求不会携带token。</p><h1 id="9-JWT"><a href="#9-JWT" class="headerlink" title="9. JWT"></a>9. JWT</h1><p>Jwt令牌是一种无状态认证的，用户的信息是放在jwt中进行传递，服务端不予要保存session，减轻了服务端的压力。</p><h2 id="9-0-jwt的优势"><a href="#9-0-jwt的优势" class="headerlink" title="9.0 jwt的优势"></a>9.0 jwt的优势</h2><ul><li><p>简洁(Compact): 可以通过URL，POST参数或者在HTTP header发送，因为数据量小，传输速度也很快</p></li><li><p>自包含(Self-contained)：负载中包含了所有用户所需要的信息，避免了多次查询数据库</p></li><li><p>因为Token是以JSON加密的形式保存在客户端的，所以JWT是跨语言的，原则上任何web形式都支持。</p></li><li><p>不需要在服务端保存会话信息，特别适用于分布式微服务</p></li><li><p>单点登录友好：使用 Session 进行身份认证的话，实现单点登录，需要我们把用户的 Session 信息保存在一台电脑上，并且还会遇到常见的 Cookie 跨域的问题。但是，使用 JWT 进行认证的话， JWT 被保存在客户端，不会存在这些问题。</p></li></ul><h2 id="9-1-JWT的组成部分"><a href="#9-1-JWT的组成部分" class="headerlink" title="9.1 JWT的组成部分"></a>9.1 JWT的组成部分</h2><p><img src="https://raw.githubusercontent.com/guduxingzheplus/blogPic/main/imgs/20230419104948.png" alt="20230419104948"></p><p>三部分，头，负载，签名</p><ul><li>头：定义算法的生成签名的方法以及token的类型</li><li>负载： 存放实际需要传递的数据（比如用户id，此处不要存放密码，容易被反向解密）</li><li>签名： 防止篡改</li></ul><h2 id="9-2-基于JWT进行身份验证"><a href="#9-2-基于JWT进行身份验证" class="headerlink" title="9.2 基于JWT进行身份验证"></a>9.2 基于JWT进行身份验证</h2><p>在基于 JWT 进行身份验证的的应用程序中，服务器通过 Payload、Header 和 Secret(密钥)创建 JWT 并将 JWT 发送给客户端。客户端接收到 JWT 之后，会将其保存在 Cookie 或者 localStorage 里面，以后客户端发出的所有请求都会携带这个令牌。<br><img src="https://raw.githubusercontent.com/guduxingzheplus/blogPic/main/imgs/20230419105546.png" alt="20230419105546"></p><ol><li><p>首先，前端通过Web表单将自己的用户名和密码发送到后端的接口。这一过程一般是一个HTTP POST请求。建议的方式是通过SSL加密的传输（https协议），从而避免敏感信息被嗅探。</p></li><li><p>后端核对用户名和密码成功后，将用户的id等其他信息作为JWT Payload（负载），将其与头部分别进行Base64编码拼接后签名，形成一个JWT(Token)。形成的JWT就是一个形同lll.zzz.xxx的字符串。 token head.payload.singurater</p></li><li><p>后端将JWT字符串作为登录成功的返回结果返回给前端。前端可以将返回的结果保存在localStorage或sessionStorage上，退出登录时前端删除保存的JWT即可。</p></li><li><p>前端在每次请求时将JWT放入HTTP Header中的Authorization位。(解决XSS和XSRF问题) HEADER</p></li><li><p>后端检查是否存在，如存在验证JWT的有效性。例如，检查签名是否正确；检查Token是否过期；检查Token的接收方是否是自己（可选）。</p></li><li><p>验证通过后后端使用JWT中包含的用户信息进行其他逻辑操作，返回相应结果。</p></li></ol><h2 id="9-3-如何防止-JWT-被篡改？"><a href="#9-3-如何防止-JWT-被篡改？" class="headerlink" title="9.3 如何防止 JWT 被篡改？"></a>9.3 如何防止 JWT 被篡改？</h2><p>有了签名之后，即使 JWT 被泄露或者截获，黑客也没办法同时篡改 Signature 、Header 、Payload。这是为什么呢？因为服务端拿到 JWT 之后，会解析出其中包含的 Header、Payload 以及 Signature 。服务端会根据 Header、Payload、密钥再次生成一个 Signature。拿新生成的 Signature 和 JWT 中的 Signature 作对比，如果一样就说明 Header 和 Payload 没有被修改。</p><h2 id="9-4-那为什么-JWT-不会存在csrf攻击问题？"><a href="#9-4-那为什么-JWT-不会存在csrf攻击问题？" class="headerlink" title="9.4 那为什么 JWT 不会存在csrf攻击问题？"></a>9.4 那为什么 JWT 不会存在csrf攻击问题？</h2><p>一般情况下我们使用 JWT 的话，在我们登录成功获得 JWT 之后，一般会选择存放在 localStorage 中。前端的每一个请求后续都会附带上这个 JWT，整个过程压根不会涉及到 Cookie。因此，即使你点击了非法链接发送了请求到服务端，这个非法请求也是不会携带 JWT 的，所以这个请求将是非法的。总结来说就一句话：使用 JWT 进行身份验证不需要依赖 Cookie ，因此可以避免 CSRF 攻击。不过，这样也会存在 XSS 攻击的风险。为了避免 XSS 攻击，你可以选择将 JWT 存储在标记为httpOnly 的 Cookie 中。但是，这样又导致了你必须自己提供 CSRF 保护，因此，实际项目中我们通常也不会这么做。常见的避免 XSS 攻击的方式是过滤掉请求中存在 XSS 攻击风险的可疑字符串。</p><h2 id="9-5-token和jwt区别"><a href="#9-5-token和jwt区别" class="headerlink" title="9.5 token和jwt区别"></a>9.5 token和jwt区别</h2><p>由客户端发送的token到服务端需要进行检验，需要查询数据库获取用户信息。而jwt不需要，只要对jwt进行解密，然后验证签名就行。省去了查库的这一步。</p><h2 id="9-6-JWT身份认证常见问题及解决办法"><a href="#9-6-JWT身份认证常见问题及解决办法" class="headerlink" title="9.6 JWT身份认证常见问题及解决办法"></a>9.6 JWT身份认证常见问题及解决办法</h2><h3 id="1-注销登录场景下JWT还有效"><a href="#1-注销登录场景下JWT还有效" class="headerlink" title="1. 注销登录场景下JWT还有效"></a>1. 注销登录场景下JWT还有效</h3><p>与之类似的场景：</p><ul><li>退出登录;</li><li>修改密码;</li><li>服务端修改了某个用户具有的权限或者角色；</li><li>用户的帐户被封禁&#x2F;删除；</li><li>用户被服务端强制注销；</li><li>用户被踢下线</li></ul><p>四种解决方案： </p><h4 id="1-将JWT存入内存数据库"><a href="#1-将JWT存入内存数据库" class="headerlink" title="1. 将JWT存入内存数据库"></a>1. 将JWT存入内存数据库</h4><p>原因：想让某个JWT失效就直接从redis中删除这个令牌值就可以了，但是这样会导致每次使用JWT都会从redis中先查询是否存在，违背了无状态的原则</p><h4 id="2-黑名单机制"><a href="#2-黑名单机制" class="headerlink" title="2. 黑名单机制"></a>2. 黑名单机制</h4><p>用redis维护一个黑名单，想让谁失效就在黑明单中加入。</p><h4 id="3-修改秘钥"><a href="#3-修改秘钥" class="headerlink" title="3. 修改秘钥"></a>3. 修改秘钥</h4><p>为每个用户都创建一个专属秘钥，如果我们想让某个jwt失效，就直接修改对应的秘钥，但是危害更大</p><ul><li>分布式： 需要每次都同步全部的秘钥，为此需要将秘钥存储在数据节点上，这样和session没区别了</li><li>如果用户在两个浏览器打开账号，那么需要退出一个，这个用户体验不友好</li></ul><h4 id="4-保证令牌的短期有效，并进行续签"><a href="#4-保证令牌的短期有效，并进行续签" class="headerlink" title="4.保证令牌的短期有效，并进行续签"></a>4.保证令牌的短期有效，并进行续签</h4><p>但是需要用户经常登录。可以联想下token的续签。</p><p>另外，对于修改密码后 JWT 还有效问题的解决还是比较容易的。说一种我觉得比较好的方式：使用用户的密码的哈希值对 JWT 进行签名。因此，如果密码更改，则任何先前的令牌将自动无法验证。</p><h3 id="2-JWT续签问题"><a href="#2-JWT续签问题" class="headerlink" title="2. JWT续签问题"></a>2. JWT续签问题</h3><p>一般短期有效，然后不断的刷新，只要用户有活跃，就延长有效期</p><ol><li>类似于session认证做法：<br> 设置30分钟有效期，服务端每次校验，发现快过期了就发送新的jwt，<strong>客户端</strong>每次请求都检查新旧jwt，如果不一致，就更新本地jwt，这种做法的问题是仅仅在快过期的时候请求才会更新JWT，对客户端不是很友好。</li><li>每次请求都返回新 JWT这种方案的的思路很简单，但是，开销会比较大，尤其是在服务端要存储维护 JWT 的情况下。</li><li>JWT 有效期设置到半夜这种方案是一种折衷的方案，保证了大部分用户白天可以正常登录，适用于对安全性要求不高的系统。</li><li>用户登录返回两个jwt。第一个是 accessJWT ，它的过期时间 JWT 本身的过期时间比如半个小时，另外一个是 refreshJWT 它的过期时间更长一点比如为 1 天。客户端登录后，将 accessJWT 和 refreshJWT 保存在本地，每次访问将 accessJWT 传给服务端。服务端校验 accessJWT 的有效性，如果过期的话，就将 refreshJWT 传给服务端。如果有效，服务端就生成新的 accessJWT 给客户端。否则，客户端就重新登录即可。<ul><li>存在的问题：</li><li>需要客户端来配合；用户注销的时候需要同时保证两个 JWT 都无效</li><li>重新请求获取 JWT 的过程中会有短暂 JWT 不可用的情况（可以通过在客户端设置定时器，当 accessJWT 快过期的时候，提前去通过 refreshJWT 获取新的 accessJWT）;</li><li>存在安全问题，只要拿到了未过期的 refreshJWT 就一直可以获取到 accessJWT。</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 认证授权 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全 </tag>
            
            <tag> 认证授权基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RocketMQ笔记</title>
      <link href="/2023/04/18/rocketmq-bi-ji/"/>
      <url>/2023/04/18/rocketmq-bi-ji/</url>
      
        <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E4%BD%9C%E7%94%A8">消息队列的作用</a><ul><li><a href="#%E5%BC%82%E6%AD%A5">异步</a></li><li><a href="#%E8%A7%A3%E8%80%A6">解耦</a></li><li><a href="#%E5%89%8A%E5%B3%B0">削峰</a></li></ul></li><li><a href="#%E9%98%9F%E5%88%97%E6%A8%A1%E5%9E%8B%E5%92%8C%E4%B8%BB%E9%A2%98%E6%A8%A1%E5%9E%8B">队列模型和主题模型</a><ul><li><a href="#%E9%98%9F%E5%88%97%E6%A8%A1%E5%9E%8B">队列模型</a></li><li><a href="#%E4%B8%BB%E9%A2%98%E6%A8%A1%E5%9E%8Btopic">主题模型（topic）</a></li><li><a href="#rocketmq%E4%B8%AD%E7%9A%84%E6%B6%88%E6%81%AF%E6%A8%A1%E5%9E%8B">RocketMQ中的消息模型</a><ul><li><a href="#producer-group-topic-consumer-group">Producer Group 、Topic 、Consumer Group</a></li><li><a href="#%E6%AF%8F%E4%B8%AA%E6%B6%88%E8%B4%B9%E7%BB%84%E5%9C%A8%E6%AF%8F%E4%B8%AA%E9%98%9F%E5%88%97%E4%B8%8A%E7%BB%B4%E6%8A%A4%E4%B8%80%E4%B8%AA%E6%B6%88%E8%B4%B9%E4%BD%8D%E7%BD%AE%E4%B8%BA%E4%BB%80%E4%B9%88">每个消费组在每个队列上维护一个消费位置，为什么？</a></li><li><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%80%E4%B8%AA%E4%B8%BB%E9%A2%98%E4%B8%AD%E8%A6%81%E7%BB%B4%E6%8A%A4%E5%A4%9A%E4%B8%AA%E9%98%9F%E5%88%97">为什么一个主题中要维护多个队列？</a></li></ul></li></ul></li><li><a href="#rocketmq%E6%9E%B6%E6%9E%84">RocketMQ架构</a><ul><li><a href="#broker">Broker</a></li><li><a href="#nameserver">NameServer</a></li><li><a href="#producerconsumer">Producer，Consumer</a></li><li><a href="#nameserver%E6%98%AF%E5%90%A6%E5%A4%9A%E4%BD%99">NameServer是否多余？</a></li><li><a href="#%E5%AE%98%E7%BD%91%E6%9E%B6%E6%9E%84%E5%9B%BE">官网架构图</a></li></ul></li><li><a href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E9%A1%BA%E5%BA%8F%E6%B6%88%E8%B4%B9%E7%9A%84%E9%97%AE%E9%A2%98">如何解决顺序消费的问题？</a></li><li><a href="#%E6%99%AE%E9%80%9A%E9%A1%BA%E5%BA%8F%E5%92%8C%E4%B8%A5%E6%A0%BC%E9%A1%BA%E5%BA%8F">普通顺序和严格顺序</a></li><li><a href="#%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3">怎么解决？？</a></li><li><a href="#%E9%87%8D%E5%A4%8D%E6%B6%88%E8%B4%B9%E9%97%AE%E9%A2%98%E9%A2%98">重复消费问题题</a></li><li><a href="#%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E5%8A%A1">分布式事务务</a><ul><li><a href="#%E5%8D%8A%E6%B6%88%E6%81%AFhalf-%E6%B6%88%E6%81%AF">半消息（half 消息））</a></li><li><a href="#%E4%BA%8B%E5%8A%A1%E5%8F%8D%E6%9F%A5%E6%9C%BA%E5%88%B6%E5%88%B6">事务反查机制制</a></li></ul></li><li><a href="#%E6%B6%88%E6%81%AF%E5%A0%86%E7%A7%AF%E9%97%AE%E9%A2%98">消息堆积问题</a></li><li><a href="#%E5%9B%9E%E6%BA%AF%E6%B6%88%E8%B4%B9">回溯消费</a></li><li><a href="#rocketmq-%E7%9A%84%E5%88%B7%E7%9B%98%E6%9C%BA%E5%88%B6">RocketMQ 的刷盘机制</a><ul><li><a href="#%E5%90%8C%E6%AD%A5%E5%88%B7%E7%9B%98%E5%92%8C%E5%BC%82%E6%AD%A5%E5%88%B7%E7%9B%98">同步刷盘和异步刷盘</a></li></ul></li><li><a href="#%E5%90%8C%E6%AD%A5%E5%A4%8D%E5%88%B6%E5%92%8C%E5%BC%82%E6%AD%A5%E5%A4%8D%E5%88%B6">同步复制和异步复制</a><ul><li><a href="#%E5%BC%82%E6%AD%A5%E5%A4%8D%E5%88%B6%E4%BC%9A%E4%B8%8D%E4%BC%9A%E5%83%8F%E5%BC%82%E6%AD%A5%E5%88%B7%E7%9B%98%E4%B8%80%E6%A0%B7%E5%BD%B1%E5%93%8D%E6%B6%88%E6%81%AF%E7%9A%84%E5%8F%AF%E9%9D%A0%E6%80%A7">异步复制会不会像异步刷盘一样影响消息的可靠性？</a></li></ul></li><li><a href="#%E5%AD%98%E5%82%A8%E6%9C%BA%E5%88%B6">存储机制</a><ul><li><a href="#commitlog-consumequeue-%E5%92%8C-indexfile">CommitLog 、ConsumeQueue 和 IndexFile</a></li></ul></li><li><a href="#%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E4%B8%8E%E8%A7%A3%E5%86%B3">常见问题与解决</a><ul><li><a href="#%E6%B6%88%E6%81%AF%E4%B8%A2%E5%A4%B1%E7%9A%84%E9%97%AE%E9%A2%98">消息丢失的问题</a></li><li><a href="#%E5%90%8C%E6%AD%A5%E8%90%BD%E7%9B%98">同步落盘</a></li><li><a href="#%E6%B6%88%E6%81%AF%E5%A0%86%E7%A7%AF%E7%9A%84%E9%97%AE%E9%A2%98">消息堆积的问题</a></li><li><a href="#%E5%AE%9A%E6%97%B6%E6%B6%88%E6%81%AF%E7%9A%84%E5%AE%9E%E7%8E%B0">定时消息的实现</a></li><li><a href="#%E9%A1%BA%E5%BA%8F%E6%B6%88%E6%81%AF%E7%9A%84%E5%AE%9E%E7%8E%B0">顺序消息的实现</a></li><li><a href="#%E5%88%86%E5%B8%83%E5%BC%8F%E6%B6%88%E6%81%AF%E7%9A%84%E5%AE%9E%E7%8E%B0">分布式消息的实现</a></li><li><a href="#%E6%B6%88%E6%81%AF%E7%9A%84push%E5%AE%9E%E7%8E%B0">消息的push实现</a></li><li><a href="#%E6%B6%88%E6%81%AF%E9%87%8D%E5%A4%8D%E5%8F%91%E9%80%81">消息重复发送</a></li><li><a href="#%E5%B9%BF%E6%92%AD%E6%B6%88%E8%B4%B9%E4%B8%8E%E9%9B%86%E7%BE%A4%E6%B6%88%E8%B4%B9">广播消费与集群消费</a></li><li><a href="#rmq%E4%B8%8D%E4%BD%BF%E7%94%A8zookeeper%E4%BD%9C%E4%B8%BA%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E7%9A%84%E5%8E%9F%E5%9B%A0%E4%BB%A5%E5%8F%8A%E8%87%AA%E5%88%B6%E7%9A%84nameserver%E7%9A%84%E7%BC%BA%E7%82%B9">RMQ不使用ZooKeeper作为注册中心的原因，以及自制的nameServer的缺点？</a></li></ul></li></ul><!-- /TOC --><h1 id="消息队列的作用"><a href="#消息队列的作用" class="headerlink" title="消息队列的作用"></a>消息队列的作用</h1><p>消息队列能用来解决如下问题：</p><h2 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h2><p>也是就是说，将消息交个其他的系统去处理，不再关心。<br><img src="https://raw.githubusercontent.com/guduxingzheplus/blogPic/main/imgs/20230418093045.png" alt="20230418093045"></p><h2 id="解耦"><a href="#解耦" class="headerlink" title="解耦"></a>解耦</h2><p>比如我们要在发送短信的功能后添加一个发送邮件，发送积分的功能，那么我们需要不断的修改整个服务，如果采用消息队列的形式，我们只需要将消息发送给消息队列，而不需要修改原来的代码的架构。消息者去订阅某个特定的主题即可、然后我们将购买系统作为生产者，当产生购买的动作的时候，将这条消息送入到消息队列中。而消费者因为订阅了这个主题，会从消息队列中拉去消息并进行消费。<br><img src="https://raw.githubusercontent.com/guduxingzheplus/blogPic/main/imgs/20230418093603.png" alt="20230418093603"></p><blockquote><p>如果没有消息队列，每当一个新的业务接入，我们都要在主系统调用新接口、或者当我们取消某些业务，我们也得在主系统删除某些接口调用。有了消息队列，我们只需要关心消息是否送达了队列，至于谁希望订阅，接下来收到消息如何处理，是下游的事情，无疑极大地减少了开发和联调的工作量。</p></blockquote><h2 id="削峰"><a href="#削峰" class="headerlink" title="削峰"></a>削峰</h2><p>如果大量的请求打到服务器，那么对于非主要业务，我们就可以延迟处理这些任务。比如我们需要发送订购成功的短信，我们的首要目的是保证订购这个行为不出现问题，所以可以把购买成功的消息发送到消息队列中，而让短信系统自己去尽己所能的处理短信请求，这样不会导致整体服务的崩溃。</p><h1 id="队列模型和主题模型"><a href="#队列模型和主题模型" class="headerlink" title="队列模型和主题模型"></a>队列模型和主题模型</h1><h2 id="队列模型"><a href="#队列模型" class="headerlink" title="队列模型"></a>队列模型</h2><p>真的只是个队列，但是队列模型是不能满足广播机制的，我们当然可以用队列模型实现简单的生产者消费者的模型。但是不能让生产者生产消息放入多个队列中，然后每个队列去对应每个消费者，问题是可以解决（不满足广播机制的问题）但是这样会导致性能受到影响。同样，需要生产者知道消费者的数量然后去复制对应的份数，这就违反了解耦的原则。</p><h2 id="主题模型（topic）"><a href="#主题模型（topic）" class="headerlink" title="主题模型（topic）"></a>主题模型（topic）</h2><p>在主题模型中，消息的生产者称为 发布者(Publisher) ，消息的消费者称为 订阅者(Subscriber) ，存放消息的容器称为 主题(Topic) 。其中，发布者将消息发送到指定主题中，订阅者需要 提前订阅主题 才能接受特定主题的消息。<img src="https://raw.githubusercontent.com/guduxingzheplus/blogPic/main/imgs/20230418094448.png" alt="20230418094448"></p><h2 id="RocketMQ中的消息模型"><a href="#RocketMQ中的消息模型" class="headerlink" title="RocketMQ中的消息模型"></a>RocketMQ中的消息模型</h2><p>采用的主题模型的形式实现的，每个消息中间件的底层实现都是不同的，卡夫卡是分区，rocketMQ是队列，而RabbitMq是Exchange。我们可以理解<strong>主题模型&#x2F;发布订阅模型</strong>就是一个标准，只不过大家都按照自己的想法去实现。</p><p><img src="https://raw.githubusercontent.com/guduxingzheplus/blogPic/main/imgs/20230418094701.png" alt="20230418094701"></p><h3 id="Producer-Group-、Topic-、Consumer-Group"><a href="#Producer-Group-、Topic-、Consumer-Group" class="headerlink" title="Producer Group 、Topic 、Consumer Group"></a>Producer Group 、Topic 、Consumer Group</h3><p>我们可以看到在整个图中有 Producer Group 、Topic 、Consumer Group 三个角色，我来分别介绍一下他们。</p><ul><li>Producer Group 生产者组。代表某一类生产者，比如多个秒杀系统作为生产者，这多个合在一起就是Producer Group生产者组，他们一般生产相同的消息。</li><li>Consumer Grouop消费者组。代表某一类消费者，比如我们有多个短信系统作为消费者，这多个合在一起就是一个consumer group消费者组，他们一般消费相同的信息。</li><li>Topic 主题： 代表一类消息，比如订单，物流。</li></ul><p>图中生产者组会向topic发送许多消息，而主题（topic）中存在多个队列，生产者每次生产消息后，会指定向其中某个队列发送消息。</p><p>每个主题都有多个队列（分布在不同的broker）中，集群消费模式下，一个消费者集群共同消费一个topic的多个队列，<strong>一个队列只会被一个消费者消费</strong> 。如果某个消费者挂掉，分组内其他的消费者会接替挂掉的消费者继续消费。就像上图中 Consumer1 和 Consumer2 分别对应着两个队列，而 Consumer3 是没有队列对应的，所以一般来讲要控制 消费者组中的消费者个数和主题中队列个数相同 。</p><p>当然也可以消费者个数小于队列个数，只不过不太建议。如下图。<br><img src="https://raw.githubusercontent.com/guduxingzheplus/blogPic/main/imgs/20230418095339.png" alt="20230418095339"></p><h3 id="每个消费组在每个队列上维护一个消费位置，为什么？"><a href="#每个消费组在每个队列上维护一个消费位置，为什么？" class="headerlink" title="每个消费组在每个队列上维护一个消费位置，为什么？"></a>每个消费组在每个队列上维护一个消费位置，为什么？</h3><p>在发布订阅模式下会涉及到多个消费者组，每个消费者组在每个队列中的消费位置都是不一样的，如果此时有多个消费者组，在一个消费者组消费玩成之后是不会删除消息的，因为其他消费者也是需要的。它仅仅会维护一个偏移量，每次消费成功后，会将消费位加一，这样就不会出现刚刚消费过的消息再次被消费了。<br><img src="https://raw.githubusercontent.com/guduxingzheplus/blogPic/main/imgs/20230418095815.png" alt="20230418095815"></p><h3 id="为什么一个主题中要维护多个队列？"><a href="#为什么一个主题中要维护多个队列？" class="headerlink" title="为什么一个主题中要维护多个队列？"></a>为什么一个主题中要维护多个队列？</h3><p>为了高并发。因为如果只在topic中维护一个队列的话，那么由于生产者只能向一个队列发送消息（生产者生产的消息是相同类型的，所以会发往相同的队列）又因为需要维护消费位置，所提一个队列只能对应一个消费者组中的消费者。其他consumer就不能使用了。</p><p>所以总结来说，RocketMQ 通过使用在一个 Topic 中配置多个队列并且每个队列维护每个消费者组的消费位置 实现了 主题模式&#x2F;发布订阅模式 。</p><h1 id="RocketMQ架构"><a href="#RocketMQ架构" class="headerlink" title="RocketMQ架构"></a>RocketMQ架构</h1><p><img src="https://raw.githubusercontent.com/guduxingzheplus/blogPic/main/imgs/20230418100356.png" alt="20230418100356"></p><h2 id="Broker"><a href="#Broker" class="headerlink" title="Broker"></a>Broker</h2><p>主要负责消息的存储，投递，查询以及保证高可用性。其实就是消息队列服务器。</p><p>一个topic放在多个broker上，一个broker可以配置多个topic，二者是多对多的关系。如果某个topic的消息量很大，那么就应该多配置几个队列，并分布在不同的broker上，减轻broker的压力。</p><h2 id="NameServer"><a href="#NameServer" class="headerlink" title="NameServer"></a>NameServer</h2><p>主要存放的就broker的信息，消费者和生产者去从NameServer获取路由表然后照着路由表的信息和对应的broker进行通信。</p><h2 id="Producer，Consumer"><a href="#Producer，Consumer" class="headerlink" title="Producer，Consumer"></a>Producer，Consumer</h2><p>producer就是生产者支持分布式集群的方式部署。 consumer支持分布式集群的方式部署，支持以push推，pull拉两种模式的对消息进行消费。同时也支持对集群的方式进行消息的广播，以及广播的方式进行消息的消费。</p><p><img src="https://raw.githubusercontent.com/guduxingzheplus/blogPic/main/imgs/20230418102510.png" alt="20230418102510"></p><h2 id="NameServer是否多余？"><a href="#NameServer是否多余？" class="headerlink" title="NameServer是否多余？"></a>NameServer是否多余？</h2><p>当然不是，如果不采用NameServer的形式，消费者和生产者直接和多个broker相连接，如果broker修改，那么许多消费者和生产者也需要跟着修改，产生了耦合问题。</p><h2 id="官网架构图"><a href="#官网架构图" class="headerlink" title="官网架构图"></a>官网架构图</h2><p><img src="https://raw.githubusercontent.com/guduxingzheplus/blogPic/main/imgs/20230418102705.png" alt="20230418102705"></p><ol><li>broker做了集群并且进行了主从部署，当主节点挂掉之后，生产者不能再发送消息，但是消费者可以进行消费。由于消息是分布在不同的broker上的，一旦某个broker宕机，则该broker上的消息读写都会受到影响，所以才采用主从模式，从节点定期同步（同步刷盘或者一步刷盘）。</li><li>保证HA，Namespace是进行了集群部署，但是他是去中心化的，也就意味着他没有主节点。具体采用的方法是，单个的broker和所有的nameserver保持长链接，并且每隔30秒进行一次心跳发送，包含了自身的Topic信息，这个步骤对应的是Routing Info</li><li>在生产者需要向broker发送消息的时候，需要先从NameServer获取Broker的路由消息，然后通过轮询的方式来想每个队列的生产数据达到负载均衡的效果。</li><li>消费者通过 NameServer 获取所有 Broker 的路由信息后，向 Broker 发送 Pull 请求来获取消息数据。Consumer 可以以两种模式启动—— 广播（Broadcast）和集群（Cluster）。广播模式下，一条消息会发送给 同一个消费组中的所有消费者 ，集群模式下消息只会发送给一个消费者。</li></ol><h1 id="如何解决顺序消费的问题？"><a href="#如何解决顺序消费的问题？" class="headerlink" title="如何解决顺序消费的问题？"></a>如何解决顺序消费的问题？</h1><h1 id="普通顺序和严格顺序"><a href="#普通顺序和严格顺序" class="headerlink" title="普通顺序和严格顺序"></a>普通顺序和严格顺序</h1><ul><li>普通顺序 ：消费者通过同一个消费队列收到的消息是有顺序的，不同的消息队列收到的消息则可能是无序的。普通消息再broker重启的情况下不会保证消息的顺序性。</li><li>严格顺序：所有收到的消息都是有序的，即使在异常情况下也会保证消息的顺序性。</li></ul><h1 id="怎么解决？？"><a href="#怎么解决？？" class="headerlink" title="怎么解决？？"></a>怎么解决？？</h1><p> 那么，我们现在使用了 普通顺序模式 ，在 Producer 生产消息的时候会进行轮询(取决你的负载均衡策略)来向同一主题的不同消息队列发送消息。那么如果此时我有几个消息分别是同一个订单的创建、支付、发货，在轮询的策略下这 三个消息会被发送到不同队列 ，因为在不同的队列此时就无法使用 RocketMQ 带来的队列有序特性来保证消息有序性了。<br><img src="https://raw.githubusercontent.com/guduxingzheplus/blogPic/main/imgs/20230418110243.png" alt="20230418110243"><br> 将同一语义的消息放入同一个队列中，那么我们就可以通过hash取模法来保证同一个订单在同一个队列中就行了。</p><h1 id="重复消费问题题"><a href="#重复消费问题题" class="headerlink" title="重复消费问题题"></a>重复消费问题题</h1><p> 幂等性。怎么实现幂等？ redis setnx或者mysql的主键唯一性。主要根据场景来选取。什么是重复消费问题，就是在消息传递过程中出现了中断，在重新传递的时候要保证多次传递的效果和一次传递的效果相同。</p><h1 id="分布式事务务"><a href="#分布式事务务" class="headerlink" title="分布式事务务"></a>分布式事务务</h1><p> rocketMQ解决分布式事务的方法是<strong>事务消息加上事务反查机制</strong><br> <img src="https://raw.githubusercontent.com/guduxingzheplus/blogPic/main/imgs/20230418110558.png" alt="20230418110558"></p><h2 id="半消息（half-消息））"><a href="#半消息（half-消息））" class="headerlink" title="半消息（half 消息））"></a>半消息（half 消息））</h2><p> 所谓的半消息，是指对消费者不可见的消息，具体做法是将备份原消息的主体与消息消费队列，然后改变主体为 RMQ_SYS_TRANS_HALF_TOPIC，由于消费队列并没有订阅RMQ_SYS_TRANS_HALF_TOPIC主题，所以不可见。然后rocketMq会开启一个定时队列从RMQ_SYS_TRANS_HALF_TOPIC中拉取消息进行消费。根据生产者组获取一个服务提供者发送回查事务请求，根据事务状态决定是提交还是回顾事务消息。</p><h2 id="事务反查机制制"><a href="#事务反查机制制" class="headerlink" title="事务反查机制制"></a>事务反查机制制</h2><p> 假设没有事务反查机制，那么如果在图中的第四步骤，没有发送成功，那么Mq SERVER就不知道是否执行成功，这样mq就迷糊了。。。在卡夫卡中会直接抛出异常，而在MQ中通过事务反查机制解决这个问题。</p><p> 在 MQ Server 指向系统B的操作已经和系统A不相关了，也就是说在消息队列中的分布式事务是——本地事务和存储消息到消息队列才是同一个事务。这样也就产生了事务的最终一致性，因为整个过程是异步的，每个系统只要保证它自己那一部分的事务就行了。</p><h1 id="消息堆积问题"><a href="#消息堆积问题" class="headerlink" title="消息堆积问题"></a>消息堆积问题</h1><p>消息队列的一个重要功能就是削峰，那么如果这个峰太大了怎么办？<br>根源就是:</p><ul><li>生产者生产的太快</li><li>消费者消费的太慢</li></ul><p>解决办法：</p><ul><li>限流降级</li><li>检查消费者是否出现了问题</li><li>增加多个消费者实例（同时增加每个主题的对列数量，在RMQ中，一个队列只会被一个消费者消费，如果只增加消费者的数量，会出现如下的情况）<br><img src="https://raw.githubusercontent.com/guduxingzheplus/blogPic/main/imgs/20230418111544.png" alt="20230418111544"></li></ul><h1 id="回溯消费"><a href="#回溯消费" class="headerlink" title="回溯消费"></a>回溯消费</h1><p>回溯消费是指 Consumer 已经消费成功的消息，由于业务上需求需要重新消费，在RocketMQ 中， Broker 在向Consumer 投递成功消息后，消息仍然需要保留 。并且重新消费一般是按照时间维度，例如由于 Consumer 系统故障，恢复后需要重新消费1小时前的数据，那么 Broker 要提供一种机制，可以按照时间维度来回退消费进度。RocketMQ 支持按照时间回溯消费，时间维度精确到毫秒。</p><h1 id="RocketMQ-的刷盘机制"><a href="#RocketMQ-的刷盘机制" class="headerlink" title="RocketMQ 的刷盘机制"></a>RocketMQ 的刷盘机制</h1><h2 id="同步刷盘和异步刷盘"><a href="#同步刷盘和异步刷盘" class="headerlink" title="同步刷盘和异步刷盘"></a>同步刷盘和异步刷盘</h2><p><img src="https://raw.githubusercontent.com/guduxingzheplus/blogPic/main/imgs/20230418111724.png" alt="20230418111724"></p><p>同步刷盘需要等待一个刷盘成功的ack，同步刷盘对MQ来说是个不错的保障，但是性能会有较大的影响，一般使用于金融等场景。</p><p>异步刷盘的开启一个线程去异步的执行这个过程，降低了读写延迟，提高了mq的吞吐量和性能。适用于发验证码等对消息保证要求不太高的场景。</p><p>异步刷盘只有在broker意外宕机的时候才会丢失部分数据，可以设置broker的参数来决定刷盘时机。</p><h1 id="同步复制和异步复制"><a href="#同步复制和异步复制" class="headerlink" title="同步复制和异步复制"></a>同步复制和异步复制</h1><ul><li>同步复制：同步双写，只有同时在主从节点都成功才返回成功</li><li>异步复制： 消息写入主节点之后就直接返回成功</li></ul><h2 id="异步复制会不会像异步刷盘一样影响消息的可靠性？"><a href="#异步复制会不会像异步刷盘一样影响消息的可靠性？" class="headerlink" title="异步复制会不会像异步刷盘一样影响消息的可靠性？"></a>异步复制会不会像异步刷盘一样影响消息的可靠性？</h2><p>不会的。两者概念不同，消息的可靠性是通过刷盘的不同策略保证的，而像异步复制策略只影响到了 <strong>可用性</strong> 为什么呢？因为MQ不支持自动的主从切换，当主节点挂掉后，生产者就不能给这个主节点生产消息了。</p><p>比如在异步复制的过程中，主节点未完成发送需要同步的消息就挂了，这个时候从节点就少了一部分消息，但是此时生产者无法给从节点消息，消费者自动切换到从节点进行消费，所以主节点挂掉的时间只会缠身主从节点短暂的消息不一致的情况，降低了可用性，当主节点重启之后，从节点那部分未来的及复制的消息还会继续复制。</p><h1 id="存储机制"><a href="#存储机制" class="headerlink" title="存储机制"></a>存储机制</h1><p>topic中的对列是以什么形式存储的呢？队列中的消息又是怎么持久化的？</p><h2 id="CommitLog-、ConsumeQueue-和-IndexFile"><a href="#CommitLog-、ConsumeQueue-和-IndexFile" class="headerlink" title="CommitLog 、ConsumeQueue 和 IndexFile"></a>CommitLog 、ConsumeQueue 和 IndexFile</h2><ul><li>CommitLog : 消息主体及元数据的存储主体。存储在Producer端的消息主题内容是不定长的，单个文件的大小默认为1G，文件名长度为20位，左边补零，剩余为起始偏移量。比如00000000000000000000代表了第一个文件，起始偏移量为0，文件大小为1G&#x3D;1073741824；当第一个文件写满了，第二个文件为00000000001073741824，起始偏移量为1073741824，以此类推。消息主要是顺序写入日志文件，当文件满了，写入下一个文件。</li><li>ConsumeQueue： 消息消费队列，主要目的是提高消息的消费性能。由于RMQ是基于topic的订阅模式，消息消费是针对主题进行的，如果遍历commitlog那么是非常浪费时间的，consumer可以根据consumerQueue来查找待销费的消息。其中，consumeQue（逻辑消费队列）作为消费消息的索引，保存了指定topic的队列消息在commmitLOG中的起始位置offset大小。消息大小size和消息tag的hashcode值。<strong>consumequeue可以看做事基于topic的commitlog索引文件</strong>。</li><li>IndexFile：提供了一种可以通过key或者时间区间来查询消息的方法。</li></ul><p>总结来说，整个消息存储的结构，最主要的就是 CommitLoq 和 ConsumeQueue 。而 ConsumeQueue 你可以大概理解为 Topic 中的队列。<img src="https://raw.githubusercontent.com/guduxingzheplus/blogPic/main/imgs/20230418113210.png" alt="20230418113210"></p><p>RocketMQ 采用的是 混合型的存储结构 ，即为 Broker 单个实例下所有的队列共用一个日志数据文件来存储消息。有意思的是在同样高并发的 Kafka 中会为每个 Topic 分配一个存储文件。这就有点类似于我们有一大堆书需要装上书架，RockeMQ 是不分书的种类直接成批的塞上去的，而 Kafka 是将书本放入指定的分类区域的。而 RocketMQ 为什么要这么做呢？原因是 提高数据的写入效率 ，不分 Topic 意味着我们有更大的几率获取 成批 的消息进行数据写入，但也会带来一个麻烦就是读取消息的时候需要遍历整个大文件，这是非常耗时的。所以，在 RocketMQ 中又使用了 ConsumeQueue 作为每个队列的索引文件来 提升读取消息的效率。我们可以直接根据队列的消息序号，计算出索引的全局位置（索引序号*索引固定⻓度20），然后直接读取这条索引，再根据索引中记录的消息的全局位置，找到消息。</p><p><img src="https://raw.githubusercontent.com/guduxingzheplus/blogPic/main/imgs/20230418113253.png" alt="20230418113253"></p><p>首先，在最上面的那一块就是我刚刚讲的你现在可以直接 把 ConsumerQueue 理解为 Queue。在图中最左边说明了红色方块代表被写入的消息，虚线方块代表等待被写入的。左边的生产者发送消息会指定 Topic 、QueueId 和具体消息内容，而在 Broker 中管你是哪门子消息，他直接 全部顺序存储到了 CommitLog。而根据生产者指定的 Topic 和 QueueId 将这条消息本身在 CommitLog 的偏移(offset)，消息本身大小，和tag的hash值存入对应的 ConsumeQueue 索引文件中。而在每个队列中都保存了 ConsumeOffset 即每个消费者组的消费位置，而消费者拉取消息进行消费的时候只需要根据 ConsumeOffset 获取下一个未被消费的消息就行了。</p><h1 id="常见问题与解决"><a href="#常见问题与解决" class="headerlink" title="常见问题与解决"></a>常见问题与解决</h1><h2 id="消息丢失的问题"><a href="#消息丢失的问题" class="headerlink" title="消息丢失的问题"></a>消息丢失的问题</h2><ol><li>当系统需要保证消息百分百不丢失的情况下，可以采用生产者每发送一个消息，broker就同步返回一个消息发送成功的通知。</li><li>带来的问题： 同步落盘怎么才能快？</li></ol><h2 id="同步落盘"><a href="#同步落盘" class="headerlink" title="同步落盘"></a>同步落盘</h2><ol><li>使用FileChanel + DirectBuffer 池，使用堆外内存，加快内存拷贝</li><li>当数据和索引分离时，使用commitlog顺序写入数据，当要定位某个数据时，使用index来定位。减少文件随机io的时间消耗。</li></ol><h2 id="消息堆积的问题"><a href="#消息堆积的问题" class="headerlink" title="消息堆积的问题"></a>消息堆积的问题</h2><ol><li>后台任务定期清除消息，没有使用过的消息</li><li>根据不同的业务场景删除相应的数据。</li><li>消息的定时转移，或者对某些重要的消息（支付消息）进行真正落库</li></ol><h2 id="定时消息的实现"><a href="#定时消息的实现" class="headerlink" title="定时消息的实现"></a>定时消息的实现</h2><ol><li>创建特定时间精度的MessageQueue，例如生产者需要定时1s之后被消费，只需要将这个消息发送到特定的topic，例如MessageQueue-1表示MessageQueue这个里面的消息都会延迟一秒被消费。然后Broker会在1s后发送消息到消费者，使用newSingleThreadScheduledExecuytor实现。</li></ol><h2 id="顺序消息的实现"><a href="#顺序消息的实现" class="headerlink" title="顺序消息的实现"></a>顺序消息的实现</h2><ol><li>与定时消息同原理，生产者生产消息指定特定的MessageQueue，消费者消费的时候，消费特定的MessageQueue，单机版本的RMQ天然支持顺序消费</li><li>在同一个MessageQueue中保证消息是顺序消费的前提下，消费者是串行的消费该MessageQueue,因为就算是MessageQueue是顺序的，但是并发的条件下，也不能保证顺序问题。<blockquote><pre><code>串行消费引入的两个问题</code></pre><blockquote><ul><li>引入锁来实现串行消费</li><li>前一个消费者阻塞，后面的都会被阻塞</li></ul></blockquote></blockquote></li></ol><h2 id="分布式消息的实现"><a href="#分布式消息的实现" class="headerlink" title="分布式消息的实现"></a>分布式消息的实现</h2><ol><li>事务反查机制。</li><li>具体如下：<br>生产者发送事务消息，假设该事务消息 Topic 为 Topic1-Trans，Broker 得到后首先更改该消息的 Topic 为 Topic1-Prepared，该 Topic1-Prepared 对消费者不可见。然后定时回调生产者的本地事务A执行状态，根据本地事务A执行状态，来是否将该消息修改为 Topic1-Commit 或 Topic1-Rollback，消费者就可以正常找到该事务消息或者不执行等</li></ol><h2 id="消息的push实现"><a href="#消息的push实现" class="headerlink" title="消息的push实现"></a>消息的push实现</h2><ol><li>RMQ中其实并没有真正的Push方法，实际是依赖于Pull来实现的</li><li>并不是真的将消息推送到消费者，而是broker隔5s将消息推送到消费者。</li><li>Pull模式中，需要手动的调用consumer来实现数据的消费，而push则是需要提供 一个listerer就可以实现对消息的监听</li><li>这个listerer实际上，就是把consumer的轮询过程的封装，并注册为监听器，取到消息之后，唤醒MessageListerer的consumerMessage（）来消费，对于用户来说，就感觉消息是被推送过来的。</li></ol><h2 id="消息重复发送"><a href="#消息重复发送" class="headerlink" title="消息重复发送"></a>消息重复发送</h2><ol><li>解决问题的一方： <strong>consumer</strong> 消费者在消费消息时，要支持幂等性的消费消息。</li><li>如何幂等？ 每条消息加一个字段，记录是否消费，根据这个消费字段来判断是否消费，或者使用一个集中的表，来存储所有的消息的消费状态，避免重复消费</li></ol><h2 id="广播消费与集群消费"><a href="#广播消费与集群消费" class="headerlink" title="广播消费与集群消费"></a>广播消费与集群消费</h2><ol><li>广播消费会让消息被许多消费者（订阅了该topic的消费者）消费，而集群消费则只会被一个消费者消费。</li><li>消息落盘区别：具体表现在消息的消费进度的保存上。<ul><li>广播消费： 每个消费者各自保存自己的消费进度</li><li>集群消费： Broker集中管理</li></ul></li></ol><h2 id="RMQ不使用ZooKeeper作为注册中心的原因，以及自制的nameServer的缺点？"><a href="#RMQ不使用ZooKeeper作为注册中心的原因，以及自制的nameServer的缺点？" class="headerlink" title="RMQ不使用ZooKeeper作为注册中心的原因，以及自制的nameServer的缺点？"></a>RMQ不使用ZooKeeper作为注册中心的原因，以及自制的nameServer的缺点？</h2><ol><li>不使用Zookeeper的原因：<br>ZooKeper是保证顺序一致性的组件，而为了满足一致性，会丢失一定的可用性。RMQ需要注册中心，仅仅是为了发现消费者和提供者，也就是说组件地址，在某些情况下，允许出现不一致的数据。这也是nameSever的缺点</li><li>缺点： 当有新的服务器加入的时候，已有的服务器不会马上知道这个新加入的服务器，Producer需要定时请求nameSever来获取相应的组件信息。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 消息队列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 消息队列基础知识 </tag>
            
            <tag> RocketMq </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字符串dp</title>
      <link href="/2023/04/17/zi-fu-chuan-dp/"/>
      <url>/2023/04/17/zi-fu-chuan-dp/</url>
      
        <content type="html"><![CDATA[<h1 id="通配符匹配"><a href="#通配符匹配" class="headerlink" title="通配符匹配"></a>通配符匹配</h1><h1 id="力扣44题"><a href="#力扣44题" class="headerlink" title="力扣44题"></a>力扣44题</h1><p>给你一个输入字符串 (s) 和一个字符模式 (p) ，请你实现一个支持 ‘?’ 和 ‘*’ 匹配规则的通配符匹配：</p><ul><li>‘?’ 可以匹配任何单个字符。</li><li>‘*’ 可以匹配任意字符序列（包括空字符序列）。</li></ul><p>判定匹配成功的充要条件是：字符模式必须能够 完全匹配 输入字符串（而不是部分匹配）。</p><p>示例：</p><blockquote><p>输入：s &#x3D; “aa”, p &#x3D; “a”</p></blockquote><blockquote><p>输出：false</p></blockquote><blockquote><p>解释：”a” 无法匹配 “aa” 整个字符串。</p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>可以采用dp来解题。dp定义如下：</p><blockquote><p>dp[i][j] 表示s[i]与p[j]是否匹配</p></blockquote><p>主要遇到以下几种情况</p><ol><li><p>如果是普通字符，只需要比较当前字符是否相等，并和dp[i-1][j-1]相与。</p></li><li><p>如果是 <strong>？</strong> 那么秩序判断dp[i-1][j-1]即可，因为是可以匹配任意单个字符。</p></li><li><p>如果是 <strong>*</strong> 号比较复杂，因为可以选择是否使用*号，</p><ul><li>如果使用，则dp[i][j] &#x3D; dp[i-1][j],比如 abc, ab*。</li><li>如果不使用，则dp[i][j] &#x3D; dp[i][j-1], 比如ab， ab*</li></ul></li></ol><p>所以代码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isMatch</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">,</span> <span class="token class-name">String</span> p<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> m <span class="token operator">=</span> p<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">boolean</span><span class="token punctuation">[</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>m <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        s <span class="token operator">=</span> <span class="token string">" "</span> <span class="token operator">+</span> s<span class="token punctuation">;</span>        p <span class="token operator">=</span> <span class="token string">" "</span> <span class="token operator">+</span> p<span class="token punctuation">;</span>        <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> sc <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> pc <span class="token operator">=</span> p<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> m<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>pc<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token char">'*'</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">||</span><span class="token punctuation">(</span>i<span class="token operator">-</span><span class="token number">1</span> <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token operator">-</span><span class="token number">1</span><span class="token operator">>=</span><span class="token number">0</span> <span class="token operator">&amp;&amp;</span> dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>sc<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> pc<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">||</span> pc<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token char">'?'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>为了方便，在两个字符串的开头加了哨兵，省去了初始化的过程。<br>动图在这<br><a href="https://leetcode.cn/problems/wildcard-matching/solutions/80942/dong-tai-gui-hua-dai-zhu-shi-by-tangweiqun/">https://leetcode.cn/problems/wildcard-matching/solutions/80942/dong-tai-gui-hua-dai-zhu-shi-by-tangweiqun/</a></p><h1 id="牛客上的变形题"><a href="#牛客上的变形题" class="headerlink" title="牛客上的变形题"></a>牛客上的变形题</h1><p><img src="https://raw.githubusercontent.com/guduxingzheplus/blogPic/main/imgs/20230417203252.png" alt="20230417203252"></p><p>这个题要注意的是，*只能匹配字母和数字，不能匹配特殊字符比如 # ，那么我们就需要特殊处理一下。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">Scanner</span></span><span class="token punctuation">;</span><span class="token comment">// 注意类名必须为 Main, 不要有任何 package xxx 信息</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Scanner</span> in <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Scanner</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 注意 hasNext 和 hasNextLine 的区别</span>        <span class="token class-name">String</span>  p <span class="token operator">=</span> in<span class="token punctuation">.</span><span class="token function">nextLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toLowerCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">String</span>  s <span class="token operator">=</span> in<span class="token punctuation">.</span><span class="token function">nextLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toLowerCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> m <span class="token operator">=</span> p<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> n <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">boolean</span><span class="token punctuation">[</span>n <span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>m <span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        p <span class="token operator">=</span> <span class="token string">" "</span> <span class="token operator">+</span> p<span class="token punctuation">;</span>        s <span class="token operator">=</span> <span class="token string">" "</span> <span class="token operator">+</span> s<span class="token punctuation">;</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> pc <span class="token operator">=</span> p<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> sc <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> m<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>pc<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token char">'*'</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>sc<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">>=</span><span class="token char">'0'</span> <span class="token operator">&amp;&amp;</span> sc<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> <span class="token char">'9'</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token punctuation">(</span>sc<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">>=</span><span class="token char">'a'</span> <span class="token operator">&amp;&amp;</span> sc<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span><span class="token char">'z'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                        dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">||</span> <span class="token punctuation">(</span>i<span class="token operator">-</span><span class="token number">1</span> <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">&#125;</span>                    <span class="token keyword">else</span><span class="token punctuation">&#123;</span>                        <span class="token comment">//他不能匹配特殊符号，所以匹配0位</span>                        dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                    <span class="token punctuation">&#125;</span>                <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>                     <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>sc<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">>=</span><span class="token char">'0'</span> <span class="token operator">&amp;&amp;</span> sc<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> <span class="token char">'9'</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token punctuation">(</span>sc<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">>=</span><span class="token char">'a'</span> <span class="token operator">&amp;&amp;</span> sc<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span><span class="token char">'z'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                       dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token operator">-</span><span class="token number">1</span><span class="token operator">>=</span><span class="token number">0</span> <span class="token operator">&amp;&amp;</span> dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>sc<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> pc<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">||</span> pc<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token char">'?'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>                        dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token operator">-</span><span class="token number">1</span><span class="token operator">>=</span><span class="token number">0</span> <span class="token operator">&amp;&amp;</span> dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> sc<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> pc<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                    <span class="token punctuation">&#125;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意这里处理* 与特殊字符的方法</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>我们不能简单的将dp[i][j]设置为flase，因为*可以不匹配，举例如下</p><blockquote><p>123*#  与 123#是可以匹配的。</p></blockquote><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这种dp问题主要是缕清情况，分类讨论，刚开始做的时候误区在于忽略内层的循环操作。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 力扣刷题 </tag>
            
            <tag> dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring面试-循环依赖</title>
      <link href="/2023/04/17/spring-mian-shi-xun-huan-yi-lai/"/>
      <url>/2023/04/17/spring-mian-shi-xun-huan-yi-lai/</url>
      
        <content type="html"><![CDATA[<h1 id="Spring是如何解决的循环依赖？"><a href="#Spring是如何解决的循环依赖？" class="headerlink" title="Spring是如何解决的循环依赖？"></a>Spring是如何解决的循环依赖？</h1><p>Spring通过三级缓存解决了循环依赖，其中一级缓存为单例池（singletonObjects）,二级缓存为早期曝光对象earlySingletonObjects，三级缓存为早期曝光对象工厂（singletonFactories）。当A、B两个类发生循环引用时，在A完成实例化后，就使用实例化后的对象去创建一个对象工厂，并添加到三级缓存中，如果A被AOP代理，那么通过这个工厂获取到的就是A代理后的对象，如果A没有被AOP代理，那么这个工厂获取到的就是A实例化的对象。当A进行属性注入时，会去创建B，同时B又依赖了A，所以创建B的同时又会去调用getBean(a)来获取需要的依赖，此时的getBean(a)会从缓存中获取，第一步，先获取到三级缓存中的工厂；第二步，调用对象工工厂的getObject方法来获取到对应的对象，得到这个对象后将其注入到B中。紧接着B会走完它的生命周期流程，包括初始化、后置处理器等。当B创建完后，会将B再注入到A中，此时A再完成它的整个生命周期。至此，循环依赖结束！</p><h1 id="为什么要使用三级缓存呢？二级缓存能解决循环依赖吗"><a href="#为什么要使用三级缓存呢？二级缓存能解决循环依赖吗" class="headerlink" title="为什么要使用三级缓存呢？二级缓存能解决循环依赖吗"></a>为什么要使用三级缓存呢？二级缓存能解决循环依赖吗</h1><p>如果要使用二级缓存解决循环依赖，意味着所有Bean在实例化后就要完成AOP代理，这样违背了Spring设计的原则，Spring在设计之初就是通过AnnotationAwareAspectJAutoProxyCreator这个后置处理器来在Bean生命周期的最后一步来完成AOP代理，而不是在实例化后就立马进行AOP代理。</p><h1 id="什么情况下循环依赖可以被处理？"><a href="#什么情况下循环依赖可以被处理？" class="headerlink" title="什么情况下循环依赖可以被处理？"></a>什么情况下循环依赖可以被处理？</h1><p>在回答这个问题之前首先要明确一点，Spring解决循环依赖是有前置条件的</p><ol><li>出现循环依赖的Bean必须要是单例</li><li>依赖注入的方式不能全是构造器注入的方式（很多博客上说，只能解决setter方法的循环依赖，这是错误的）</li></ol><p>其中第一点应该很好理解，第二点：不能全是构造器注入是什么意思呢？我们还是用代码说话</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Component</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">&#123;</span><span class="token comment">//    @Autowired</span><span class="token comment">//    private B b;</span>    <span class="token keyword">public</span> <span class="token class-name">A</span><span class="token punctuation">(</span><span class="token class-name">B</span> b<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token annotation punctuation">@Component</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token punctuation">&#123;</span><span class="token comment">//    @Autowired</span><span class="token comment">//    private A a;</span>    <span class="token keyword">public</span> <span class="token class-name">B</span><span class="token punctuation">(</span><span class="token class-name">A</span> a<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在上面的例子中，A中注入B的方式是通过构造器，B中注入A的方式也是通过构造器，这个时候循环依赖是无法被解决</p><p><a href="https://developer.aliyun.com/article/766880">https://developer.aliyun.com/article/766880</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> spring </tag>
            
            <tag> 循环依赖 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>消息队列基础知识</title>
      <link href="/2023/04/10/xiao-xi-dui-lie-ji-chu-zhi-shi/"/>
      <url>/2023/04/10/xiao-xi-dui-lie-ji-chu-zhi-shi/</url>
      
        <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8">消息队列有什么用？</a><ul><li><a href="#%E9%80%9A%E8%BF%87%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86%E6%8F%90%E9%AB%98%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%80%A7%E8%83%BD%E5%87%8F%E5%B0%91%E7%9B%B8%E5%BA%94%E6%89%80%E9%9C%80%E7%9A%84%E6%97%B6%E9%97%B4">通过异步处理提高系统的性能（减少相应所需的时间）</a></li><li><a href="#%E5%89%8A%E5%B3%B0--%E9%99%90%E6%B5%81">削峰 &#x2F; 限流</a></li><li><a href="#%E9%99%8D%E4%BD%8E%E7%B3%BB%E7%BB%9F%E8%80%A6%E5%90%88%E6%80%A7">降低系统耦合性</a></li></ul></li><li><a href="#%E4%BD%BF%E7%94%A8%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%B8%A6%E6%9D%A5%E5%93%AA%E4%BA%9B%E9%97%AE%E9%A2%98">使用消息队列带来哪些问题</a></li><li><a href="#rpc%E6%9E%B6%E6%9E%84%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84">RPC架构的基本结构</a></li><li><a href="#rpc-%E5%92%8C%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E5%8C%BA%E5%88%AB">RPC 和消息队列的区别</a></li></ul><!-- /TOC --><h1 id="1-消息队列有什么用？"><a href="#1-消息队列有什么用？" class="headerlink" title="1. 消息队列有什么用？"></a>1. 消息队列有什么用？</h1><ol><li>通过异步处理提高系统的性能（减少相应所需的时间）</li><li>削峰 &#x2F; 限流</li><li>降低系统耦合性</li></ol><h2 id="1-1-通过异步处理提高系统的性能（减少相应所需的时间）"><a href="#1-1-通过异步处理提高系统的性能（减少相应所需的时间）" class="headerlink" title="1.1 通过异步处理提高系统的性能（减少相应所需的时间）"></a>1.1 通过异步处理提高系统的性能（减少相应所需的时间）</h2><p>主要原理就是将请求打到消息队列后，立即返回相应的结果，由消息队列消化这些消息，由于可能涉及到数据库的操作等诸多行为，所以可能存在失败的风险，在执行成功后，通知用户。类似下单买火车票，会告诉你正在下单中，然后会返回短信提醒你下单成功。<br><img src="https://raw.githubusercontent.com/guduxingzheplus/blogPic/main/imgs/20230410095226.png" alt="20230410095226"></p><h2 id="1-2-削峰-x2F-限流"><a href="#1-2-削峰-x2F-限流" class="headerlink" title="1.2 削峰 &#x2F; 限流"></a>1.2 削峰 &#x2F; 限流</h2><p>先将短时间的高并发事务产生的事务消息存储在消息队列中，然后后端服务再慢慢根据自己的能力去消费这些信息，这样就避免了直接将后端服务打垮掉。</p><p><img src="https://raw.githubusercontent.com/guduxingzheplus/blogPic/main/imgs/20230410095446.png" alt="20230410095446"></p><h2 id="1-3-降低系统耦合性"><a href="#1-3-降低系统耦合性" class="headerlink" title="1.3 降低系统耦合性"></a>1.3 降低系统耦合性</h2><p>消息队列的主要形式就是订阅-发布模式，但是并不是唯一的一种模式，只是说比较常用，还有点对点的一些模式。这两种模型由JMS提供。降低耦合性的具体体现在于。生产者在将消息发送出去之后，不再管理消息，但是发送之后会记录这条消息，直到消息被消费者成功消费了以后在从发送者的服务器上删除这条记录（主要是为了避免服务器宕机造成的消息的丢失问题），在消息队列宕机后，生产者会选择分布式消息队列服务器集群中的其他服务发布消息。<br>生产者（客户端）发送消息到消息队列中去，接受者（服务端）处理消息，需要消费的系统直接去消息队列取消息进行消费即可而不需要和其他系统有耦合，这显然也提高了系统的扩展性。对于新增的业务，只要对消息队列中的内容感兴趣就可以订阅该消息队列。对原有的系统没有任何影响。<br><img src="https://raw.githubusercontent.com/guduxingzheplus/blogPic/main/imgs/20230410101108.png" alt="20230410101108"></p><h1 id="2-使用消息队列带来哪些问题"><a href="#2-使用消息队列带来哪些问题" class="headerlink" title="2.使用消息队列带来哪些问题"></a>2.使用消息队列带来哪些问题</h1><ul><li>系统可用性降低： 因为加入了新的MQ模块，需要考虑消息丢失或者挂掉 的风险。</li><li>系统复杂性的提高： 要保证消息没有被重复消费，消息丢失等情况，保证消息传递的顺序性问题。</li><li>一致性问题： 异步模式导致的消息真正的消费者并没有正确消费消息。</li></ul><h1 id="3-RPC架构的基本结构"><a href="#3-RPC架构的基本结构" class="headerlink" title="3. RPC架构的基本结构"></a>3. RPC架构的基本结构</h1><p>构建分布式系统的时候的服务与服务之间的调用。</p><p>首先，我们通常把发生调用关系的两个服务分别称为服务的提供者（Provider）和消费者（Consumer）。所以，简单来说，RPC 就是服务的消费者向提供者发起远程调用并获取结果的过程，这是 RPC 最简单的一种表现形式。<img src="https://raw.githubusercontent.com/guduxingzheplus/blogPic/main/imgs/20230410102857.png" alt="20230410102857"></p><p>如果想要实现服务提供者和消费者之间的有效交互，那么两者之间就需要确立与网络通信相关的网络协议以及通信通道。同时，服务的提供者需要把自己的服务调用入口暴露出来，并时刻准备接收来自消费者的请求。<br>这里，我们把通信通道和网络协议分别命名为 RpcChannel 和 RpcProtocol，而把服务提供者接收请求的组件称为 RpcAcceptor，把消费者发起请求的组件称为 RpcConnector。这样，RPC 架构就演变成了这个样子：<br><img src="https://raw.githubusercontent.com/guduxingzheplus/blogPic/main/imgs/20230410102932.png" alt="20230410102932"></p><p>然后，对于服务提供者和消费者而言，为了双方能够正常识别所发送的请求和所接收到的响应结果，需要定义统一的契约。我们把这种契约称为远程 API（Remote API），以便与本地 API 加以区别。如此一来，基于同一套远程 API 的定义，RPC 架构就具备了根据业务来定义通信契约的能力。</p><h1 id="4-RPC-和消息队列的区别"><a href="#4-RPC-和消息队列的区别" class="headerlink" title="4. RPC 和消息队列的区别"></a>4. RPC 和消息队列的区别</h1><ul><li>从用途看： RPC主要解决的是远程调用api的问题，并不需要了解底层网络的通信机制，通过RPC调用远程方法就像调用本地方法一样简单。消息队列主要用来降低系统的耦合性，实现任务异步，有效的进行流量削峰。</li><li>从通信方式来看： RPC是直接双向网络通讯，消息队列是单向的引入中间载体的网络通讯。</li><li>从架构上来看： 消息队列为了防止消息的丢失，需要将消息存储起来，而RPC则不需要，因为是双向直接网络通讯。</li><li>从处理请求的时效性上来看： 通过RPC发出的调用一般会立即被处理，而消息队列则不会。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 消息队列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> 消息队列基础知识 </tag>
            
            <tag> 消息队列通用知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络常见面试题--基础</title>
      <link href="/2023/04/03/ji-suan-ji-wang-luo-chang-jian-mian-shi-ti/"/>
      <url>/2023/04/03/ji-suan-ji-wang-luo-chang-jian-mian-shi-ti/</url>
      
        <content type="html"><![CDATA[<h1 id="1-基础"><a href="#1-基础" class="headerlink" title="1. 基础"></a>1. 基础</h1><hr><h2 id="1-1-发送网络数据的时候，涉及几次内存拷贝操作？"><a href="#1-1-发送网络数据的时候，涉及几次内存拷贝操作？" class="headerlink" title="1.1 发送网络数据的时候，涉及几次内存拷贝操作？"></a>1.1 发送网络数据的时候，涉及几次内存拷贝操作？</h2><p>第一次，调用发送数据的系统调用的时候，内核会申请一个内核态的 sk_buff 内存，将用户待发送的数据拷贝到 sk_buff 内存，并将其加入到发送缓冲区。</p><p>第二次，在使用 TCP 传输协议的情况下，从传输层进入网络层的时候，每一个 sk_buff 都会被克隆一个新的副本出来。副本 sk_buff 会被送往网络层，等它发送完的时候就会释放掉，然后原始的 sk_buff 还保留在传输层，目的是为了实现 TCP 的可靠传输，等收到这个数据包的 ACK 时，才会释放原始的 sk_buff 。</p><p>第三次，当 IP 层发现 sk_buff 大于 MTU 时才需要进行。会再申请额外的 sk_buff，并将原来的 sk_buff 拷贝为多个小的 sk_buff。</p><h1 id="2-Linux-发送网络包的流程"><a href="#2-Linux-发送网络包的流程" class="headerlink" title="2. Linux 发送网络包的流程"></a>2. Linux 发送网络包的流程</h1><hr><p><img src="https://raw.githubusercontent.com/guduxingzheplus/blogPic/main/imgs/20230403100138.png" alt="20230403100138"><br>先，应用程序会调用 Socket 发送数据包的接口，由于这个是系统调用，所以会从用户态陷入到内核态中的 Socket 层，内核会申请一个内核态的 sk_buff 内存，将用户待发送的数据拷贝到 sk_buff 内存，并将其加入到发送缓冲区。</p><p>接下来，网络协议栈从 Socket 发送缓冲区中取出 sk_buff，并按照 TCP&#x2F;IP 协议栈从上到下逐层处理。</p><p>如果使用的是 TCP 传输协议发送数据，那么先拷贝一个新的 sk_buff 副本 ，这是因为 sk_buff 后续在调用网络层，最后到达网卡发送完成的时候，这个 sk_buff 会被释放掉。而 TCP 协议是支持丢失重传的，在收到对方的 ACK 之前，这个 sk_buff 不能被删除。所以内核的做法就是每次调用网卡发送的时候，实际上传递出去的是 sk_buff 的一个拷贝，等收到 ACK 再真正删除。</p><p>接着，对 sk_buff 填充 TCP 头。这里提一下，sk_buff 可以表示各个层的数据包，在应用层数据包叫 data，在 TCP 层我们称为 segment，在 IP 层我们叫 packet，在数据链路层称为 frame。</p><p>你可能会好奇，为什么全部数据包只用一个结构体来描述呢？协议栈采用的是分层结构，上层向下层传递数据时需要增加包头，下层向上层数据时又需要去掉包头，如果每一层都用一个结构体，那在层之间传递数据的时候，就要发生多次拷贝，这将大大降低 CPU 效率。</p><p>于是，为了在层级之间传递数据时，不发生拷贝，只用 sk_buff 一个结构体来描述所有的网络包，那它是如何做到的呢？是通过调整 sk_buff 中 data 的指针，比如：</p><p>当接收报文时，从网卡驱动开始，通过协议栈层层往上传送数据报，通过增加 skb-&gt;data 的值，来逐步剥离协议首部。<br>当要发送报文时，创建 sk_buff 结构体，数据缓存区的头部预留足够的空间，用来填充各层首部，在经过各下层协议时，通过减少 skb-&gt;data 的值来增加协议首部。<br>你可以从下面这张图看到，当发送报文时，data 指针的移动过程。<br><img src="https://raw.githubusercontent.com/guduxingzheplus/blogPic/main/imgs/20230403100107.png" alt="20230403100107"></p><h1 id="3-Linux-接收网络包的流程"><a href="#3-Linux-接收网络包的流程" class="headerlink" title="3. Linux 接收网络包的流程"></a>3. Linux 接收网络包的流程</h1><hr><p>网卡是计算机里的一个硬件，专门负责接收和发送网络包，当网卡接收到一个网络包后，会通过 DMA 技术，将网络包写入到指定的内存地址，也就是写入到 Ring Buffer ，这个是一个环形缓冲区，接着就会告诉操作系统这个网络包已经到达。</p><p>那应该怎么告诉操作系统这个网络包已经到达了呢？</p><p>最简单的一种方式就是触发中断，也就是每当网卡收到一个网络包，就触发一个中断告诉操作系统。</p><p>但是，这存在一个问题，在高性能网络场景下，网络包的数量会非常多，那么就会触发非常多的中断，要知道当 CPU 收到了中断，就会停下手里的事情，而去处理这些网络包，处理完毕后，才会回去继续其他事情，那么频繁地触发中断，则会导致 CPU 一直没完没了的处理中断，而导致其他任务可能无法继续前进，从而影响系统的整体效率。</p><p>所以为了解决频繁中断带来的性能开销，Linux 内核在 2.6 版本中引入了 NAPI 机制，它是混合「中断和轮询」的方式来接收网络包，它的核心概念就是不采用中断的方式读取数据，而是首先采用中断唤醒数据接收的服务程序，然后 poll 的方法来轮询数据。</p><p>因此，当有网络包到达时，会通过 DMA 技术，将网络包写入到指定的内存地址，接着网卡向 CPU 发起硬件中断，当 CPU 收到硬件中断请求后，根据中断表，调用已经注册的中断处理函数。</p><p>硬件中断处理函数会做如下的事情：</p><p>需要先「暂时屏蔽中断」，表示已经知道内存中有数据了，告诉网卡下次再收到数据包直接写内存就可以了，不要再通知 CPU 了，这样可以提高效率，避免 CPU 不停的被中断。<br>接着，发起「软中断」，然后恢复刚才屏蔽的中断。<br>至此，硬件中断处理函数的工作就已经完成。</p><p>硬件中断处理函数做的事情很少，主要耗时的工作都交给软中断处理函数了。</p><p>软中断的处理</p><p>内核中的 ksoftirqd 线程专门负责软中断的处理，当 ksoftirqd 内核线程收到软中断后，就会来轮询处理数据。</p><p>ksoftirqd 线程会从 Ring Buffer 中获取一个数据帧，用 sk_buff 表示，从而可以作为一个网络包交给网络协议栈进行逐层处理。</p><p>网络协议栈</p><p>首先，会先进入到网络接口层，在这一层会检查报文的合法性，如果不合法则丢弃，合法则会找出该网络包的上层协议的类型，比如是 IPv4，还是 IPv6，接着再去掉帧头和帧尾，然后交给网络层。</p><p>到了网络层，则取出 IP 包，判断网络包下一步的走向，比如是交给上层处理还是转发出去。当确认这个网络包要发送给本机后，就会从 IP 头里看看上一层协议的类型是 TCP 还是 UDP，接着去掉 IP 头，然后交给传输层。</p><p>传输层取出 TCP 头或 UDP 头，根据四元组「源 IP、源端口、目的 IP、目的端口」 作为标识，找出对应的 Socket，并把数据放到 Socket 的接收缓冲区。</p><p>最后，应用层程序调用 Socket 接口，将内核的 Socket 接收缓冲区的数据「拷贝」到应用层的缓冲区，然后唤醒用户进程。</p><p>至此，一个网络包的接收过程就已经结束了，你也可以从下图左边部分看到网络包接收的流程，右边部分刚好反过来，它是网络包发送的流程。</p><h1 id="4-TCP-与-UDP-的区别（重要）"><a href="#4-TCP-与-UDP-的区别（重要）" class="headerlink" title="4. TCP 与 UDP 的区别（重要）"></a>4. TCP 与 UDP 的区别（重要）</h1><hr><ul><li>是否面向连接 ：UDP 在传送数据之前不需要先建立连接。而 TCP 提供面向连接的服务，在传送数据之前必须先建立连接，数据传送结束后要释放连接。</li><li>是否是可靠传输：远地主机在收到 UDP 报文后，不需要给出任何确认，并且不保证数据不丢失，不保证是否顺序到达。TCP 提供可靠的传输服务，TCP 在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制。通过 TCP 连接传输的数据，无差错、不丢失、不重复、并且按序到达。</li><li>是否有状态 ：这个和上面的“是否可靠传输”相对应。TCP 传输是有状态的，这个有状态说的是 TCP 会去记录自己发送消息的状态比如消息是否发送了、是否被接收了等等。为此 ，TCP 需要维持复杂的连接状态表。而 UDP 是无状态服务，简单来说就是不管发出去之后的事情了（这很渣男！）。</li><li>传输效率 ：由于使用 TCP 进行传输的时候多了连接、确认、重传等机制，所以 TCP 的传输效率要比 UDP 低很多。</li><li>传输形式 ： TCP 是面向字节流的，UDP 是面向报文的。</li><li>首部开销 ：TCP 首部开销（20 ～ 60 字节）比 UDP 首部开销（8 字节）要大。</li><li>是否提供广播或多播服务 ：TCP 只支持点对点通信，UDP 支持一对一、一对多、多对一、多对多；</li></ul><p><img src="https://raw.githubusercontent.com/guduxingzheplus/blogPic/main/imgs/20230403100531.png" alt="20230403100531"></p><h2 id="4-1-HTTP-基于-TCP-还是-UDP？"><a href="#4-1-HTTP-基于-TCP-还是-UDP？" class="headerlink" title="4.1 HTTP 基于 TCP 还是 UDP？"></a>4.1 HTTP 基于 TCP 还是 UDP？</h2><p>HTTP 3.0 之前是基于 TCP 协议的，而 HTTP3.0 将弃用 TCP，改用 基于 UDP 的 QUIC 协议 。此变化主要为了解决 HTTP&#x2F;2 中存在的队头阻塞问题。由于 HTTP&#x2F;2 在单个 TCP 连接上使用了多路复用，受到 TCP 拥塞控制的影响，少量的丢包就可能导致整个 TCP 连接上的所有流被阻塞。</p><h2 id="4-2-使用-TCP-的协议有哪些-使用-UDP-的协议有哪些"><a href="#4-2-使用-TCP-的协议有哪些-使用-UDP-的协议有哪些" class="headerlink" title="4.2 使用 TCP 的协议有哪些?使用 UDP 的协议有哪些?"></a>4.2 使用 TCP 的协议有哪些?使用 UDP 的协议有哪些?</h2><p>运行于 TCP 协议之上的协议 ：</p><ol><li>HTTP 协议 ：超文本传输协议（HTTP，HyperText Transfer Protocol)主要是为 Web 浏览器与 Web 服务器之间的通信而设计的。当我们使用浏览器浏览网页的时候，我们网页就是通过 HTTP 请求进行加载的。</li><li>HTTPS 协议 ：更安全的超文本传输协议(HTTPS,Hypertext Transfer Protocol Secure)，身披 SSL 外衣的 HTTP 协议</li><li>FTP 协议：文件传输协议 FTP（File Transfer Protocol），提供文件传输服务，基于 TCP 实现可靠的传输。使用 FTP 传输文件的好处是可以屏蔽操作系统和文件存储方式。</li><li>SMTP 协议：简单邮件传输协议（SMTP，Simple Mail Transfer Protocol）的缩写，基于 TCP 协议，用来发送电子邮件。注意 ⚠️：接受邮件的协议不是 SMTP 而是 POP3 协议。</li><li>POP3&#x2F;IMAP 协议： POP3 和 IMAP 两者都是负责邮件接收的协议。</li><li>Telnet 协议：远程登陆协议，通过一个终端登陆到其他服务器。被一种称为 SSH 的非常安全的协议所取代。</li><li>SSH 协议 : SSH（ Secure Shell）是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题。SSH 建立在可靠的传输协议 TCP 之上。</li><li>……</li></ol><p><strong>运行于 UDP 协议之上的协议 ：</strong></p><ol><li>DHCP 协议：动态主机配置协议，动态配置 IP </li><li>地址DNS ： 域名系统（DNS，Domain Name System）将人类可读的域名 (例如，<a href="http://www.baidu.com/">www.baidu.com</a>) 转换为机器可读的 IP 地址 (例如，220.181.38.148)。 我们可以将其理解为专为互联网设计的电话薄。实际上 DNS 同时支持 UDP 和 TCP 协议。</li></ol><h1 id="5-TCP-三次握手和四次挥手（传输层）"><a href="#5-TCP-三次握手和四次挥手（传输层）" class="headerlink" title="5. TCP 三次握手和四次挥手（传输层）"></a>5. TCP 三次握手和四次挥手（传输层）</h1><p><a href="https://javaguide.cn/cs-basics/network/tcp-connection-and-disconnection.html#%E6%96%AD%E5%BC%80%E8%BF%9E%E6%8E%A5-tcp-%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B">https://javaguide.cn/cs-basics/network/tcp-connection-and-disconnection.html#%E6%96%AD%E5%BC%80%E8%BF%9E%E6%8E%A5-tcp-%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B</a></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> 计算机网络 </tag>
            
            <tag> 计网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Springboot 自动装配简介</title>
      <link href="/2023/04/03/springboot-zi-dong-zhuang-pei-jian-jie/"/>
      <url>/2023/04/03/springboot-zi-dong-zhuang-pei-jian-jie/</url>
      
        <content type="html"><![CDATA[<h1 id="1-什么是springBoot自动装配？"><a href="#1-什么是springBoot自动装配？" class="headerlink" title="1. 什么是springBoot自动装配？"></a>1. 什么是springBoot自动装配？</h1><p>实际上自动装配在Spring Framework中早就实现了这个功能。spring boot只是在这个基础上，通过spi的方式，做了进一步优化。</p><blockquote><p>springBoot自己定义了一套接口规范，在启动时会去扫描外部引用的jar包中的META-INF&#x2F;spring.factories文件，将文件中的配置信息的类型信息加载到spring容器中，并执行类中定义的各种操作。对于外部jar来说，只需要按照springboot定义的标准，就能将自己的功能装置加载进springboot。</p></blockquote><p>没有spring boot的情况下，我们需要引入第三方依赖，需要手动配置，但是springboot里，直接引入一个strarter即可。比如想在项目主使用redis，那么引入对应的starter就好了</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-data-redis<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>然后再引入少量的注解和一些简单配置就行了。<br>自动装配可以理解为： <strong>通过注解或者一些简单配置就能在springboot的帮助下，实现某块功能。</strong>  </p><h1 id="2-springBoot是如何实现自动装配的"><a href="#2-springBoot是如何实现自动装配的" class="headerlink" title="2. springBoot是如何实现自动装配的"></a>2. springBoot是如何实现自动装配的</h1><p>核心注解就是@SpringBootApplication，源代码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token class-name">ElementType</span><span class="token punctuation">.</span><span class="token constant">TYPE</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span><span class="token class-name">RetentionPolicy</span><span class="token punctuation">.</span><span class="token constant">RUNTIME</span><span class="token punctuation">)</span><span class="token annotation punctuation">@Documented</span><span class="token annotation punctuation">@Inherited</span><span class="token generics"><span class="token punctuation">&lt;</span>1<span class="token punctuation">.</span><span class="token punctuation">></span></span><span class="token annotation punctuation">@SpringBootConfiguration</span><span class="token generics"><span class="token punctuation">&lt;</span>2<span class="token punctuation">.</span><span class="token punctuation">></span></span><span class="token annotation punctuation">@ComponentScan</span><span class="token generics"><span class="token punctuation">&lt;</span>3<span class="token punctuation">.</span><span class="token punctuation">></span></span><span class="token annotation punctuation">@EnableAutoConfiguration</span><span class="token keyword">public</span> <span class="token annotation punctuation">@interface</span> <span class="token class-name">SpringBootApplication</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token class-name">ElementType</span><span class="token punctuation">.</span><span class="token constant">TYPE</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span><span class="token class-name">RetentionPolicy</span><span class="token punctuation">.</span><span class="token constant">RUNTIME</span><span class="token punctuation">)</span><span class="token annotation punctuation">@Documented</span><span class="token annotation punctuation">@Configuration</span> <span class="token comment">//实际上它也是一个配置类</span><span class="token keyword">public</span> <span class="token annotation punctuation">@interface</span> <span class="token class-name">SpringBootConfiguration</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，@SpringBootApplication可以理解为@SpringBootConfiguration，@ComponentScan，@EnableAutoConfiguration三者的组合。<br>作用如下：  </p><ul><li>@EnableAutoConfiguration：开启自动装配</li><li>@Configuration: 允许上下文中注册额外的bean或导入其他配置类。</li><li>@ComponentScan： 扫描被@Component修饰的bean，默认会扫描启动类所在的包下的所有类，可以自定义不扫描的某些bean，使用 @ComponentScan（excludeFilters &#x3D; {@Filter(type &#x3D; FilterType.CUSTOM, classes &#x3D; TypeExcluderFilter.class),@Filter(type &#x3D; FilterType.CUSTOM, classes &#x3D; AutoConfigurationExcludeFilter.class)}<br>容器中将排除TypeExcludeFilter和AutoConfigurationExcludeFilter。</li></ul><h2 id="2-1-EnableAutoConfiguration-实现自动装配的核心注解"><a href="#2-1-EnableAutoConfiguration-实现自动装配的核心注解" class="headerlink" title="2.1@EnableAutoConfiguration:实现自动装配的核心注解"></a>2.1@EnableAutoConfiguration:实现自动装配的核心注解</h2><p>EnableAutoConfiguration 只是一个简单地注解，自动装配核心功能的实现实际是通过 AutoConfigurationImportSelector类。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token class-name">ElementType</span><span class="token punctuation">.</span><span class="token constant">TYPE</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span><span class="token class-name">RetentionPolicy</span><span class="token punctuation">.</span><span class="token constant">RUNTIME</span><span class="token punctuation">)</span><span class="token annotation punctuation">@Documented</span><span class="token annotation punctuation">@Inherited</span><span class="token annotation punctuation">@AutoConfigurationPackage</span> <span class="token comment">//作用：将main包下的所有组件注册到容器中</span><span class="token annotation punctuation">@Import</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token class-name">AutoConfigurationImportSelector</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span> <span class="token comment">//加载自动装配类 xxxAutoconfiguration</span><span class="token keyword">public</span> <span class="token annotation punctuation">@interface</span> <span class="token class-name">EnableAutoConfiguration</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">String</span> <span class="token constant">ENABLED_OVERRIDE_PROPERTY</span> <span class="token operator">=</span> <span class="token string">"spring.boot.enableautoconfiguration"</span><span class="token punctuation">;</span>    <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">exclude</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">excludeName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们现在重点分析下AutoConfigurationImportSelector 类到底做了什么？</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AutoConfigurationImportSelector</span> <span class="token keyword">implements</span> <span class="token class-name">DeferredImportSelector</span><span class="token punctuation">,</span> <span class="token class-name">BeanClassLoaderAware</span><span class="token punctuation">,</span> <span class="token class-name">ResourceLoaderAware</span><span class="token punctuation">,</span> <span class="token class-name">BeanFactoryAware</span><span class="token punctuation">,</span> <span class="token class-name">EnvironmentAware</span><span class="token punctuation">,</span> <span class="token class-name">Ordered</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">DeferredImportSelector</span> <span class="token keyword">extends</span> <span class="token class-name">ImportSelector</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">ImportSelector</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">selectImports</span><span class="token punctuation">(</span><span class="token class-name">AnnotationMetadata</span> var1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看出，AutoConfigurationImportSelector 类实现了 ImportSelector接口，也就实现了这个接口中的 selectImports方法，该方法主要用于获取所有符合条件的类的全限定类名，这些类需要被加载到 IoC 容器中。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token constant">NO_IMPORTS</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">selectImports</span><span class="token punctuation">(</span><span class="token class-name">AnnotationMetadata</span> annotationMetadata<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// &lt;1>.判断自动装配开关是否打开</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">isEnabled</span><span class="token punctuation">(</span>annotationMetadata<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> <span class="token constant">NO_IMPORTS</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>          <span class="token comment">//&lt;2>.获取所有需要装配的bean</span>            <span class="token class-name">AutoConfigurationMetadata</span> autoConfigurationMetadata <span class="token operator">=</span> <span class="token class-name">AutoConfigurationMetadataLoader</span><span class="token punctuation">.</span><span class="token function">loadMetadata</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>beanClassLoader<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">AutoConfigurationImportSelector<span class="token punctuation">.</span>AutoConfigurationEntry</span> autoConfigurationEntry <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getAutoConfigurationEntry</span><span class="token punctuation">(</span>autoConfigurationMetadata<span class="token punctuation">,</span> annotationMetadata<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token class-name">StringUtils</span><span class="token punctuation">.</span><span class="token function">toStringArray</span><span class="token punctuation">(</span>autoConfigurationEntry<span class="token punctuation">.</span><span class="token function">getConfigurations</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里我们需要重点关注一下getAutoConfigurationEntry()方法，这个方法主要负责加载自动配置类的。<br><img src="https://raw.githubusercontent.com/guduxingzheplus/blogPic/main/imgs/20230403084719.png" alt="20230403084719"></p><p>现在我们结合getAutoConfigurationEntry()的源码来详细分析一下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">AutoConfigurationEntry</span> <span class="token constant">EMPTY_ENTRY</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AutoConfigurationEntry</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">AutoConfigurationEntry</span> <span class="token function">getAutoConfigurationEntry</span><span class="token punctuation">(</span><span class="token class-name">AutoConfigurationMetadata</span> autoConfigurationMetadata<span class="token punctuation">,</span> <span class="token class-name">AnnotationMetadata</span> annotationMetadata<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">//&lt;1>.</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">isEnabled</span><span class="token punctuation">(</span>annotationMetadata<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> <span class="token constant">EMPTY_ENTRY</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            <span class="token comment">//&lt;2>.</span>            <span class="token class-name">AnnotationAttributes</span> attributes <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getAttributes</span><span class="token punctuation">(</span>annotationMetadata<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">//&lt;3>.</span>            <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> configurations <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getCandidateConfigurations</span><span class="token punctuation">(</span>annotationMetadata<span class="token punctuation">,</span> attributes<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">//&lt;4>.</span>            configurations <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">removeDuplicates</span><span class="token punctuation">(</span>configurations<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> exclusions <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getExclusions</span><span class="token punctuation">(</span>annotationMetadata<span class="token punctuation">,</span> attributes<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">checkExcludedClasses</span><span class="token punctuation">(</span>configurations<span class="token punctuation">,</span> exclusions<span class="token punctuation">)</span><span class="token punctuation">;</span>            configurations<span class="token punctuation">.</span><span class="token function">removeAll</span><span class="token punctuation">(</span>exclusions<span class="token punctuation">)</span><span class="token punctuation">;</span>            configurations <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>configurations<span class="token punctuation">,</span> autoConfigurationMetadata<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">fireAutoConfigurationImportEvents</span><span class="token punctuation">(</span>configurations<span class="token punctuation">,</span> exclusions<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">AutoConfigurationImportSelector<span class="token punctuation">.</span>AutoConfigurationEntry</span><span class="token punctuation">(</span>configurations<span class="token punctuation">,</span> exclusions<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>第 1 步:<br>判断自动装配开关是否打开。默认spring.boot.enableautoconfiguration&#x3D;true，可在 application.properties 或 application.yml 中设置<br><img src="https://raw.githubusercontent.com/guduxingzheplus/blogPic/main/imgs/20230403084903.png" alt="20230403084903"></p><p>第 2 步 ：</p><p>用于获取EnableAutoConfiguration注解中的 exclude 和 excludeName。<br><img src="https://raw.githubusercontent.com/guduxingzheplus/blogPic/main/imgs/20230403084927.png" alt="20230403084927"></p><p>第 3 步:</p><p>获取需要自动装配的所有配置类，读取META-INF&#x2F;spring.factories</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">spring-boot/spring-boot-project/spring-boot-autoconfigure/src/main/resources/META-INF/spring.factories<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/guduxingzheplus/blogPic/main/imgs/20230403085022.png" alt="20230403085022"></p><p>从下图可以看到这个文件的配置内容都被我们读取到了。XXXAutoConfiguration的作用就是按需加载组件。<br><img src="https://raw.githubusercontent.com/guduxingzheplus/blogPic/main/imgs/20230403085048.png" alt="20230403085048"><br>不光是这个依赖下的META-INF&#x2F;spring.factories被读取到，所有 Spring Boot Starter 下的META-INF&#x2F;spring.factories都会被读取到。所以，你可以清楚滴看到， druid 数据库连接池的 Spring Boot Starter 就创建了META-INF&#x2F;spring.factories文件。<br><img src="https://raw.githubusercontent.com/guduxingzheplus/blogPic/main/imgs/20230403090605.png" alt="20230403090605"></p><p>第 4 步 ：<br>到这里可能面试官会问你:“spring.factories中这么多配置，每次启动都要全部加载么？”。很明显，这是不现实的。我们 debug 到后面你会发现，configurations 的值变小了。</p><p>因为，这一步有经历了一遍筛选，@ConditionalOnXXX 中的所有条件都满足，该类才会生效。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span><span class="token comment">// 检查相关的类：RabbitTemplate 和 Channel是否存在</span><span class="token comment">// 存在才会加载</span><span class="token annotation punctuation">@ConditionalOnClass</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span> <span class="token class-name">RabbitTemplate</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> <span class="token class-name">Channel</span><span class="token punctuation">.</span><span class="token keyword">class</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token annotation punctuation">@EnableConfigurationProperties</span><span class="token punctuation">(</span><span class="token class-name">RabbitProperties</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token annotation punctuation">@Import</span><span class="token punctuation">(</span><span class="token class-name">RabbitAnnotationDrivenConfiguration</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RabbitAutoConfiguration</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> spring面试 </category>
          
          <category> springBoot原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot </tag>
            
            <tag> 自动装配 </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Trie 前缀树（字典树）</title>
      <link href="/2023/04/02/trie-qian-zhui-shu/"/>
      <url>/2023/04/02/trie-qian-zhui-shu/</url>
      
        <content type="html"><![CDATA[<h1 id="1-什么是前缀树？"><a href="#1-什么是前缀树？" class="headerlink" title="1. 什么是前缀树？"></a>1. 什么是前缀树？</h1><p>字典树是一种树形结构，典型应用是用于统计，排序和大量字符串的索引工作，比如查询要插入的数据是否已经存在于数据结构之中，查询已有数据中是否有以要插入的字段开头的数据。</p><p>他的图形化表示如下所示：<br><img src="https://raw.githubusercontent.com/guduxingzheplus/blogPic/main/imgs/20230402182559.png" alt="20230402182559"></p><p><a  href ="https://www.bilibili.com/video/BV1yA4y1Z74t/?spm_id_from=333.337.search-card.all.click&vd_source=ecd5c866d6cf8dc2ca7670889ecca2f4">图片出处</a></p><p>从图中我们可以看到，其实前缀树就是不断地将具有相同前缀的数据结构合并。比如对于car和cat，他们同样的是“ca”，所以在左侧第二颗前缀树中，最后一层有两个分叉。前缀树中，边表示字符，同时每个节点会额外添加一个数组，表示以节点P结尾的单词的插入次数。这里注意，节点的序号没有什么实际的意义。</p><h1 id="2-前缀树定义题"><a href="#2-前缀树定义题" class="headerlink" title="2. 前缀树定义题"></a>2. 前缀树定义题</h1><p>力扣上的前缀树定义题如下：<br><a  href ="https://leetcode.cn/problems/implement-trie-prefix-tree/description/">208. 实现 Trie (前缀树)</a><br>，简单的题目描述如下：</p><blockquote><p>Trie（发音类似 “try”）或者说 前缀树 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补完和拼写检查。</p></blockquote><p>请你实现 Trie 类：</p><ul><li>Trie() 初始化前缀树对象。</li><li>void insert(String word) 向前缀树中插入字符串 word 。</li><li>boolean search(String word) 如果字符串 word 在前缀树中，返回 true（即，在检索之前已经插入）；否则，返回 false 。</li><li>boolean startsWith(String prefix) 如果之前已经插入的字符串 word 的前缀之一为 prefix ，返回 true ；否则，返回 false 。<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Trie</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token class-name">Trie</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token punctuation">&#125;</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">insert</span><span class="token punctuation">(</span><span class="token class-name">String</span> word<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token punctuation">&#125;</span>        <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">search</span><span class="token punctuation">(</span><span class="token class-name">String</span> word<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token punctuation">&#125;</span>        <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">startsWith</span><span class="token punctuation">(</span><span class="token class-name">String</span> prefix<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p>解题的代码如下，思路和上文中提到的一样：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Trie</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> <span class="token class-name">N</span> <span class="token operator">=</span> <span class="token number">100009</span><span class="token punctuation">;</span> <span class="token comment">// 直接设置为十万级</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> trie<span class="token punctuation">;</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> count<span class="token punctuation">;</span>    <span class="token keyword">int</span> index<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">Trie</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        trie <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">26</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//因为有26个字母，所以有26个分叉</span>        count <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//初试的节点下标（根节点）</span>    <span class="token punctuation">&#125;</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">insert</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> p <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> u <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token char">'a'</span><span class="token punctuation">;</span>            <span class="token comment">//如果没有这个节点，就创建这个节点，index要增加</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>trie<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> trie<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">++</span>index<span class="token punctuation">;</span>            p <span class="token operator">=</span> trie<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        count<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">search</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> p <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> u <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token char">'a'</span><span class="token punctuation">;</span>            <span class="token comment">//不存在这条路径，就返回false</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>trie<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            p <span class="token operator">=</span> trie<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> count<span class="token punctuation">[</span>p<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">startsWith</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> p <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> u <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token char">'a'</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>trie<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            p <span class="token operator">=</span> trie<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="3-变形题"><a href="#3-变形题" class="headerlink" title="3. 变形题"></a>3. 变形题</h1><p><a  href ="https://leetcode.cn/problems/maximum-xor-of-two-numbers-in-an-array/description/">421. 数组中两个数的最大异或值</a></p><blockquote><p>给你一个整数数组 nums ，返回 nums[i] XOR nums[j] 的最大运算结果，其中 0 ≤ i ≤ j &lt; n 。</p></blockquote><p>示例 1：</p><blockquote><p>输入：nums &#x3D; [3,10,5,25,2,8]<br>输出：28<br>解释：最大运算结果是 5 XOR 25 &#x3D; 28.</p></blockquote><p>示例 2：</p><blockquote><p>输入：nums &#x3D; [14,70,53,83,49,91,36,80,92,51,66,70]<br>输出：127</p></blockquote><p>这道问题我们采用的是前缀树加上贪心的思路。我们将遍历到i之前的所有数字全加入到Trie树中，同时将第i个数也加入。此时我们有个贪心的思路，就是说在Trie树中，我们对于nums[i]，由于是异或，所以我们要寻找和nums[i]当前位不一样的，比如nums[i]当前位是1，我们就要找是0的数字。</p><p>具体实现代码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">class</span> <span class="token class-name">Node</span><span class="token punctuation">&#123;</span>        <span class="token class-name">Node</span><span class="token punctuation">[</span><span class="token punctuation">]</span> ns <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//因为只有0/1，所以大小为2</span>    <span class="token punctuation">&#125;</span>    <span class="token class-name">Node</span> root <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token class-name">Node</span> p <span class="token operator">=</span> root<span class="token punctuation">;</span>        <span class="token comment">//int位数为32位，全部遍历，从高到低</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">31</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> u <span class="token operator">=</span> <span class="token punctuation">(</span>x <span class="token operator">>></span> i<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token comment">//没有这个节点，就创建</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>ns<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> p<span class="token punctuation">.</span>ns<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            p <span class="token operator">=</span> p<span class="token punctuation">.</span>ns<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">int</span> <span class="token function">getVal</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token class-name">Node</span> p <span class="token operator">=</span> root<span class="token punctuation">;</span>        <span class="token keyword">int</span> ans <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">31</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token comment">//我们期望b是a不一样的</span>            <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token punctuation">(</span>x <span class="token operator">>></span> i<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">-</span> a<span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>ns<span class="token punctuation">[</span>b<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token comment">//此时b存在，符合期望，我们就把b按照位数还原</span>                ans <span class="token operator">|=</span> <span class="token punctuation">(</span>b <span class="token operator">&lt;&lt;</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>                p <span class="token operator">=</span> p<span class="token punctuation">.</span>ns<span class="token punctuation">[</span>b<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>                <span class="token comment">//不存在期望的b，我们只能走a的路线</span>                <span class="token comment">//记得最后将p指向我们移动后的位置</span>                ans <span class="token operator">|=</span> <span class="token punctuation">(</span>a <span class="token operator">&lt;&lt;</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>                p <span class="token operator">=</span> p<span class="token punctuation">.</span>ns<span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>         <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">findMaximumXOR</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> ans <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">:</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">add</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token function">getVal</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>            ans <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>ans<span class="token punctuation">,</span> i <span class="token operator">^</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h1><p>学了一下午，做了两个题，但是还是很有收获的。Trie的基本性质通过这两个题有所了解，继续更新这个Trie的会。<br><img src="https://raw.githubusercontent.com/guduxingzheplus/blogPic/main/imgs/IMG_4879.jpg" alt="IMG_4879"></p>]]></content>
      
      
      <categories>
          
          <category> 力扣刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 力扣刷题 </tag>
            
            <tag> Trie </tag>
            
            <tag> 前缀树 </tag>
            
            <tag> 字典树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring面试-事务</title>
      <link href="/2023/03/31/spring-mian-shi-shi-wu/"/>
      <url>/2023/03/31/spring-mian-shi-shi-wu/</url>
      
        <content type="html"><![CDATA[<p>spring 能否支持事务，取决去使用的数据库是否支持事务，比如对于MySQL来说，如果采用MyISAM，由于Myisam自身不支持事务，那么无论是否开启spring自身的事务，都是不能实现的。</p><h1 id="Spring事务"><a href="#Spring事务" class="headerlink" title="Spring事务"></a>Spring事务</h1><h2 id="1-spring支持的两种事务管理方式"><a href="#1-spring支持的两种事务管理方式" class="headerlink" title="1. spring支持的两种事务管理方式"></a>1. spring支持的两种事务管理方式</h2><h3 id="1-1-编程式事务管理"><a href="#1-1-编程式事务管理" class="headerlink" title="1.1 编程式事务管理"></a>1.1 编程式事务管理</h3><p>通过TransactionTemplate或者TransactionManager手动管理事务，实际中很少使用。<br>使用TransactionTrmplate进行编程式事务管理的实例代码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Autowired</span><span class="token keyword">private</span> <span class="token class-name">TransactionTemplate</span> transactionTemplate<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testTransaction</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        transactionTemplate<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">TransactionCallbackWithoutResult</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">doInTransactionWithoutResult</span><span class="token punctuation">(</span><span class="token class-name">TransactionStatus</span> transactionStatus<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>                    <span class="token comment">// ....  业务代码</span>                <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                    <span class="token comment">//回滚</span>                    transactionStatus<span class="token punctuation">.</span><span class="token function">setRollbackOnly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用 TransactionManager 进行编程式事务管理的示例代码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Autowired</span><span class="token keyword">private</span> <span class="token class-name">PlatformTransactionManager</span> transactionManager<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testTransaction</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token class-name">TransactionStatus</span> status <span class="token operator">=</span> transactionManager<span class="token punctuation">.</span><span class="token function">getTransaction</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">DefaultTransactionDefinition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>               <span class="token comment">// ....  业务代码</span>              transactionManager<span class="token punctuation">.</span><span class="token function">commit</span><span class="token punctuation">(</span>status<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>              transactionManager<span class="token punctuation">.</span><span class="token function">rollback</span><span class="token punctuation">(</span>status<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-2-声明式事务"><a href="#1-2-声明式事务" class="headerlink" title="1.2 声明式事务"></a>1.2 声明式事务</h3><p>实际是通过AOP实现的，这种方式对代码的侵入性比较小。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Transactional</span><span class="token punctuation">(</span>propagation <span class="token operator">=</span> <span class="token class-name">Propagation</span><span class="token punctuation">.</span><span class="token constant">REQUIRED</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">void</span> aMethod <span class="token punctuation">&#123;</span>  <span class="token comment">//do something</span>  <span class="token class-name">B</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token class-name">C</span> c <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">C</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  b<span class="token punctuation">.</span><span class="token function">bMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  c<span class="token punctuation">.</span><span class="token function">cMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-3-Spring事务管理接口介绍"><a href="#1-3-Spring事务管理接口介绍" class="headerlink" title="1.3 Spring事务管理接口介绍"></a>1.3 Spring事务管理接口介绍</h3><ul><li>PlatformTransactionManager: 事务管理器，Spring事务策略的核心</li><li>TransactionDefination： 事务定义信息（事务的回滚，隔离级别，传播行为，只读，超时）</li><li>TransactionalStatus： 事务运行的状态</li></ul><h4 id="1-3-1-PlatformTransactionManager"><a href="#1-3-1-PlatformTransactionManager" class="headerlink" title="1.3.1 PlatformTransactionManager"></a>1.3.1 PlatformTransactionManager</h4><p>Spring并不直接管理实务而是提供了许多的事务管理器。PlatformTransactionManager就是spring的重要管理器。通过这个接口，spring为各个平台：JDBC，JPA等等，都提供了对应的事务管理器，但是具体的实现就是各个平台自己的事情了。<br>PlatformTransactionManager接口中定义的方法:</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>transaction</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>lang<span class="token punctuation">.</span></span><span class="token class-name">Nullable</span></span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">PlatformTransactionManager</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//获得事务</span>    <span class="token class-name">TransactionStatus</span> <span class="token function">getTransaction</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Nullable</span> <span class="token class-name">TransactionDefinition</span> var1<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">TransactionException</span><span class="token punctuation">;</span>    <span class="token comment">//提交事务</span>    <span class="token keyword">void</span> <span class="token function">commit</span><span class="token punctuation">(</span><span class="token class-name">TransactionStatus</span> var1<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">TransactionException</span><span class="token punctuation">;</span>    <span class="token comment">//回滚事务</span>    <span class="token keyword">void</span> <span class="token function">rollback</span><span class="token punctuation">(</span><span class="token class-name">TransactionStatus</span> var1<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">TransactionException</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-3-2为什么要定义或者抽象出来这个接口"><a href="#1-3-2为什么要定义或者抽象出来这个接口" class="headerlink" title="1.3.2为什么要定义或者抽象出来这个接口"></a>1.3.2为什么要定义或者抽象出来这个接口</h3><p>主要是为了方便扩展，因为这样一来，不同平台的实现就可以自行设计，但是暴露给外部的接口是不变的，也就是说，提供给外部的行为是不变的，方便扩展。</p><blockquote><p>就如同我们为什么使用接口一样，比如我们要实现一个发送短信的代码，我们抽象出来一个接口，接口中有两个方法，发送短信，处理发送结果。如果我们刚开始是使用的阿里云发送，而后我们要改成其他的短信服务平台实现发送的功能，那么很显然，如果我们没有定义接口，那么需要重构调用发送代码的代码，而采用接口则只需要修改具体的短息发送代码。</p></blockquote><h3 id="1-3-3-事务属性"><a href="#1-3-3-事务属性" class="headerlink" title="1.3.3 事务属性"></a>1.3.3 事务属性</h3><p>事务管理器接口PlatformTransactionManager通过getTransaction(TransactionDefinition definition)方法来得到一个事务，而TransactionDefinition就是一个定义事务的基本属性的类。</p><p><strong>什么是事务属性？</strong></p><ul><li>隔离级别</li><li>传播行为</li><li>回滚规则</li><li>是否只读</li><li>是否超时</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>transaction</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>lang<span class="token punctuation">.</span></span><span class="token class-name">Nullable</span></span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">TransactionDefinition</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> <span class="token constant">PROPAGATION_REQUIRED</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token constant">PROPAGATION_SUPPORTS</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token constant">PROPAGATION_MANDATORY</span> <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token constant">PROPAGATION_REQUIRES_NEW</span> <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token constant">PROPAGATION_NOT_SUPPORTED</span> <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token constant">PROPAGATION_NEVER</span> <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token constant">PROPAGATION_NESTED</span> <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token constant">ISOLATION_DEFAULT</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token constant">ISOLATION_READ_UNCOMMITTED</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token constant">ISOLATION_READ_COMMITTED</span> <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token constant">ISOLATION_REPEATABLE_READ</span> <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token constant">ISOLATION_SERIALIZABLE</span> <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token constant">TIMEOUT_DEFAULT</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment">// 返回事务的传播行为，默认值为 REQUIRED。</span>    <span class="token keyword">int</span> <span class="token function">getPropagationBehavior</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//返回事务的隔离级别，默认值是 DEFAULT</span>    <span class="token keyword">int</span> <span class="token function">getIsolationLevel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 返回事务的超时时间，默认值为-1。如果超过该时间限制但事务还没有完成，则自动回滚事务。</span>    <span class="token keyword">int</span> <span class="token function">getTimeout</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 返回是否为只读事务，默认值为 false</span>    <span class="token keyword">boolean</span> <span class="token function">isReadOnly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Nullable</span>    <span class="token class-name">String</span> <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-3-4-事务状态"><a href="#1-3-4-事务状态" class="headerlink" title="1.3.4 事务状态"></a>1.3.4 事务状态</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">TransactionStatus</span><span class="token punctuation">&#123;</span>    <span class="token keyword">boolean</span> <span class="token function">isNewTransaction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 是否是新的事务</span>    <span class="token keyword">boolean</span> <span class="token function">hasSavepoint</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 是否有恢复点</span>    <span class="token keyword">void</span> <span class="token function">setRollbackOnly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 设置为只回滚</span>    <span class="token keyword">boolean</span> <span class="token function">isRollbackOnly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 是否为只回滚</span>    <span class="token keyword">boolean</span> isCompleted<span class="token punctuation">;</span> <span class="token comment">// 是否已完成</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="Spring事务详解"><a href="#Spring事务详解" class="headerlink" title="Spring事务详解"></a>Spring事务详解</h1><h2 id="2-事务传播行为"><a href="#2-事务传播行为" class="headerlink" title="2. 事务传播行为"></a>2. 事务传播行为</h2><p>事务传播行为是为了解决业务层方法之间相互调用的事务问题。<br>比如非事务方法去调用事务方法，那么事务方法会发生事务失效的问题。</p><p>当事务方法被另一个事务方法调用的时候我们必须指定事务该如何传播，比如如何回滚的问题。</p><h3 id="2-1-正确的事务传播行为可能的值"><a href="#2-1-正确的事务传播行为可能的值" class="headerlink" title="2.1 正确的事务传播行为可能的值"></a>2.1 正确的事务传播行为可能的值</h3><h4 id="1-TransactionDefinition-PROPAGATION-REQUIRED"><a href="#1-TransactionDefinition-PROPAGATION-REQUIRED" class="headerlink" title="1. TransactionDefinition.PROPAGATION_REQUIRED"></a>1. TransactionDefinition.PROPAGATION_REQUIRED</h4><p>使用最多的事务传播行为，也是<font style="background: violet"> 默认</font>的传播行为。</p><ul><li>如果当前外部方法没有开启事务，则当前事务会开启一个自己的新的事务，而且事务之间相互独立，不干扰</li><li>如果当前事务的外部事物开启了事务，并且被Progation.Required修饰的话，，那么当前的事务因为也开启了同样的Progation.Required，所以会被视为一个事务，只要一个方法发生了回滚，那么就会发生整体的回滚</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Service</span><span class="token class-name">Class</span> <span class="token class-name">A</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token class-name">B</span> b<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Transactional</span><span class="token punctuation">(</span>propagation <span class="token operator">=</span> <span class="token class-name">Propagation</span><span class="token punctuation">.</span><span class="token constant">REQUIRED</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> aMethod <span class="token punctuation">&#123;</span>        <span class="token comment">//do something</span>        b<span class="token punctuation">.</span><span class="token function">bMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token annotation punctuation">@Service</span><span class="token class-name">Class</span> <span class="token class-name">B</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Transactional</span><span class="token punctuation">(</span>propagation <span class="token operator">=</span> <span class="token class-name">Propagation</span><span class="token punctuation">.</span><span class="token constant">REQUIRED</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> bMethod <span class="token punctuation">&#123;</span>       <span class="token comment">//do something</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>只要B发生了回滚，那么因为A开启了Progation.REQUIRED，所以A也会回滚</p><h4 id="2-TransactionDefinanition-PROPAGATION-RTEQUIRES-NEW"><a href="#2-TransactionDefinanition-PROPAGATION-RTEQUIRES-NEW" class="headerlink" title="2. TransactionDefinanition.PROPAGATION_RTEQUIRES_NEW"></a>2. TransactionDefinanition.PROPAGATION_RTEQUIRES_NEW</h4><p>创建一个新的事务，如果当前存在事务，则会把当前的事务挂起，就是说不管外部是否存在事务，都会自行创建一个新的事务。且开启的事务相互独立，不户型干扰。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"> <span class="token annotation punctuation">@Service</span><span class="token class-name">Class</span> <span class="token class-name">A</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token class-name">B</span> b<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Transactional</span><span class="token punctuation">(</span>propagation <span class="token operator">=</span> <span class="token class-name">Propagation</span><span class="token punctuation">.</span><span class="token constant">REQUIRED</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> aMethod <span class="token punctuation">&#123;</span>        <span class="token comment">//do something</span>        b<span class="token punctuation">.</span><span class="token function">bMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token annotation punctuation">@Service</span><span class="token class-name">Class</span> <span class="token class-name">B</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Transactional</span><span class="token punctuation">(</span>propagation <span class="token operator">=</span> <span class="token class-name">Propagation</span><span class="token punctuation">.</span><span class="token constant">REQUIRES_NEW</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> bMethod <span class="token punctuation">&#123;</span>       <span class="token comment">//do something</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>如果A发生异常回滚，那么B不会回滚，因为B开启的是独立的事务，不会加入到A的事务之中</li><li>如果B发生异常回滚，<font style="background: violet"> A会回滚！</font>因为A是REQUIRED级别的事务，他会将上下文的事务统一成一个来看，所以一旦其中一个事务出现回滚，他也会回滚。</li></ul><h4 id="3-TransactioDefinition-PROPAGATION-NESTED"><a href="#3-TransactioDefinition-PROPAGATION-NESTED" class="headerlink" title="3. TransactioDefinition.PROPAGATION_NESTED:"></a>3. TransactioDefinition.PROPAGATION_NESTED:</h4><p>如果当前存在事务就在当前的事务内部嵌套执行事务，如果当前没有事务，就执行与 REQUIRED类似的事务。</p><ul><li><p>在外部方法开启事务的情况下，在内部开启一个新的事务，作为嵌套的存在。</p></li><li><p>在外部事物无方法的情况下，则单独开启一个事务。</p></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Service</span><span class="token class-name">Class</span> <span class="token class-name">A</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token class-name">B</span> b<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Transactional</span><span class="token punctuation">(</span>propagation <span class="token operator">=</span> <span class="token class-name">Propagation</span><span class="token punctuation">.</span><span class="token constant">REQUIRED</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> aMethod <span class="token punctuation">&#123;</span>        <span class="token comment">//do something</span>        b<span class="token punctuation">.</span><span class="token function">bMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token annotation punctuation">@Service</span><span class="token class-name">Class</span> <span class="token class-name">B</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Transactional</span><span class="token punctuation">(</span>propagation <span class="token operator">=</span> <span class="token class-name">Propagation</span><span class="token punctuation">.</span><span class="token constant">NESTED</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> bMethod <span class="token punctuation">&#123;</span>       <span class="token comment">//do something</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>B回滚，跟着回滚</p><h4 id="4-TransactionDefinition-PROPAGATION-MANDATORY"><a href="#4-TransactionDefinition-PROPAGATION-MANDATORY" class="headerlink" title="4. TransactionDefinition.PROPAGATION_MANDATORY"></a>4. TransactionDefinition.PROPAGATION_MANDATORY</h4><p>如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。（mandatory：强制性）这个使用的很少，就不举例子来说了</p><h3 id="2-2-事务的隔离级别"><a href="#2-2-事务的隔离级别" class="headerlink" title="2.2 事务的隔离级别"></a>2.2 事务的隔离级别</h3><p>一共5个隔离级别</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">TransactionDefinition</span> <span class="token punctuation">&#123;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">int</span> <span class="token constant">ISOLATION_DEFAULT</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token constant">ISOLATION_READ_UNCOMMITTED</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token constant">ISOLATION_READ_COMMITTED</span> <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token constant">ISOLATION_REPEATABLE_READ</span> <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token constant">ISOLATION_SERIALIZABLE</span> <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>逐一介绍（和MySQL类似。。。）</p><ul><li><p>TransactionDefinition.ISOLATION_DEFAULT：使用后端数据库默认的隔离级别，Mysql默认的级别是RR（可重复读），Oracle默认的是RC（读取已提交）</p></li><li><p>TransactionDefinition.ISOLATION_READ_UNCOMMITTED：读取未提交，会有脏读，幻读，不可重复读</p></li><li><p>TransactionDefinition.ISOLATION_READ_COMMITTED : 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生</p></li><li><p>TransactionDefinition.ISOLATION_REPEATABLE_READ : 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。</p></li><li><p>TransactionDefinition.ISOLATION_SERIALIZABLE : 最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。但是这将严重影响程序的性能。通常情况下也不会用到该级别。</p></li></ul><h3 id="2-3-事务超时属性"><a href="#2-3-事务超时属性" class="headerlink" title="2.3 事务超时属性"></a>2.3 事务超时属性</h3><p>如果超过最长执行时限，还没有完成，则自动回滚，在TransDefination中以init的值来表示超时时间。默认是-1；</p><h3 id="2-4-事务的只读属性"><a href="#2-4-事务的只读属性" class="headerlink" title="2.4 事务的只读属性"></a>2.4 事务的只读属性</h3><p>对于只要读取数据的事务，可以开启readonly，数据库会去优化。为什么数据查询操作还要开启事务支持？</p><blockquote><p>因为MySQL默认对每一个新建立的链接都启用了autocomit模式，在这个模式下，每一个发送到Mysql的sql语句都会在一个单独的事务中进行处理，执行结束后会自动提交事务，并开启一个新的事务。所欲我们可以看到，如果我们给方法加上了Transactional注解的话，这个方法的全部sql会被放入到一个事务之中，如果声明了只读事物的话数据库同样会去优化她的执行过程。缩短了执行时间。如果不加Transactional，那么每条sql会单独开启一个独立事务，这样耗时长，但是也会在实时的读取到最新的值。</p></blockquote><h3 id="2-5-事务回滚原则"><a href="#2-5-事务回滚原则" class="headerlink" title="2.5 事务回滚原则"></a>2.5 事务回滚原则</h3><p>可以自定义事务回滚的特定异常类型</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Transactional</span><span class="token punctuation">(</span>rollbackFor<span class="token operator">=</span> <span class="token class-name">MyException</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="3-Transactional-注解使用详解"><a href="#3-Transactional-注解使用详解" class="headerlink" title="3. @Transactional 注解使用详解"></a>3. @Transactional 注解使用详解</h2><h3 id="3-1-Transactional-的作用范围"><a href="#3-1-Transactional-的作用范围" class="headerlink" title="3.1 @Transactional 的作用范围"></a>3.1 @Transactional 的作用范围</h3><ol><li>方法：推荐使用在方法上，不过需要注意的是这个注解只能用到public方法上，否则不生效。</li><li>类： 如果这个注解使用在类上，表明该注解对类上的所有public方法都有效。</li><li>接口：不推荐在接口上使用</li></ol><p>@Transactional 的常用配置参数总结（只列出了 5 个平时比较常用的）：</p><p><img src="https://raw.githubusercontent.com/guduxingzheplus/blogPic/main/imgs/20230401093008.png" alt="20230401093008"></p><p>@Transactional 事务注解原理：<br>AOP实现的，AOP基于动态代理，如果目标实现了接口，默认情况下会采用jdk动态代理，否则采用cglib的代理。<br>createAopProxy（）方法决定了使用什么代理</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DefaultAopProxyFactory</span> <span class="token keyword">implements</span> <span class="token class-name">AopProxyFactory</span><span class="token punctuation">,</span> <span class="token class-name">Serializable</span> <span class="token punctuation">&#123;</span><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token class-name">AopProxy</span> <span class="token function">createAopProxy</span><span class="token punctuation">(</span><span class="token class-name">AdvisedSupport</span> config<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">AopConfigException</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>config<span class="token punctuation">.</span><span class="token function">isOptimize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> config<span class="token punctuation">.</span><span class="token function">isProxyTargetClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token function">hasNoUserSuppliedProxyInterfaces</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> targetClass <span class="token operator">=</span> config<span class="token punctuation">.</span><span class="token function">getTargetClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>targetClass <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">AopConfigException</span><span class="token punctuation">(</span><span class="token string">"TargetSource cannot determine target class: "</span> <span class="token operator">+</span><span class="token string">"Either an interface or a target is required for proxy creation."</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>targetClass<span class="token punctuation">.</span><span class="token function">isInterface</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token class-name">Proxy</span><span class="token punctuation">.</span><span class="token function">isProxyClass</span><span class="token punctuation">(</span>targetClass<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">JdkDynamicAopProxy</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ObjenesisCglibAopProxy</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">JdkDynamicAopProxy</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果一个类或者一个类中的public方法被标注了@Transactional注解，那么spring容器在启动的时候会为其创建一个代理类，在调用@Transactional注解的public方法的时候，实际调用的是TransactionInterceptor 类中的 invoke()方法。这个方法的作用就是在目标方法之前开启事务，方法执行过程中如果遇到异常的时候回滚事务，方法调用完成之后提交事务。</p><h3 id="3-2-Transactional-的使用注意事项总结"><a href="#3-2-Transactional-的使用注意事项总结" class="headerlink" title="3.2 @Transactional 的使用注意事项总结"></a>3.2 @Transactional 的使用注意事项总结</h3><ul><li>@Transactional 注解只有作用到 public 方法上事务才生效，不推荐在接口上使用；</li><li>避免同一个类中调用@Transactional 注解的方法，这样会导致事务失效；</li><li>正确的设置 @Transactional 的 rollbackFor 和 propagation 属性，否则事务可能会回滚失败;</li><li>被 @Transactional 注解的方法所在的类必须被 Spring 管理，否则不生效；底层使用的数据库必须支持事务机制，否则不生效</li></ul>]]></content>
      
      
      <categories>
          
          <category> spring面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
            <tag> 事务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring面试--IoC/Aop</title>
      <link href="/2023/03/30/spring-mian-shi-ioc-aop/"/>
      <url>/2023/03/30/spring-mian-shi-ioc-aop/</url>
      
        <content type="html"><![CDATA[<h1 id="Spring-IoC"><a href="#Spring-IoC" class="headerlink" title="Spring IoC"></a>Spring IoC</h1><h2 id="1-谈谈对SpringIoc的理解"><a href="#1-谈谈对SpringIoc的理解" class="headerlink" title="1.谈谈对SpringIoc的理解"></a>1.谈谈对SpringIoc的理解</h2><h3 id="1-1-控制反转来源"><a href="#1-1-控制反转来源" class="headerlink" title="1.1 控制反转来源"></a>1.1 控制反转来源</h3><p>-控制指的是对象创建（实例化，管理的权利）<br>-反转：指的是将控制权交给外部环境（Spring框架，Ioc容器）<br><img src="https://raw.githubusercontent.com/guduxingzheplus/blogPic/main/imgs/20230330101109.png"></p><p>将对象之间的相互依赖关系交给IoC容器来管理，并由容器完成对象的注入，这样可以很大程度上简化应用的开发过程。<br>这样的好处是两方之间（调用方和被调用方）之间不再相互依赖</p><ul><li>降低对象之间的耦合度  </li><li>资源变得容易管理，比如用Spring容器提供的话，很容易实现一个单例。</li></ul><p><strong>IoC最常见的最合理的实践方式是依赖注入（DI）</strong></p><h3 id="1-2-DI"><a href="#1-2-DI" class="headerlink" title="1.2 DI"></a>1.2 DI</h3><p>DI即依赖注入：组件之间依赖关系由容器在运行时决定，形象的说，即由容器动态的将某个依赖注入到组件之中，依赖注入的目的并非为软件带来更多的功能，而是为了提升组件重用的频率，并未系统搭建一个灵活，可扩展的平台。</p><p>理解DI的关键是理解如下四个点：</p><ul><li>谁依赖谁 当然是程序依赖于IOC容器</li><li>为什么需要依赖：需要容器提供对象需要的外部资源</li><li>谁注入了谁： 很明显是IoC容器注入应用程序某个对象，应用程序依赖的对象。</li><li>注入了什么：就是注入某个对象所需要的外部资源</li></ul><h4 id="1-2-1-对于IoC的理解"><a href="#1-2-1-对于IoC的理解" class="headerlink" title="1.2.1 对于IoC的理解"></a>1.2.1 对于IoC的理解</h4><p>Spring所倡导的开发方式就是如此，所有的类都会在spring容器中登记，告诉spring你是个什么东西，你需要什么东西，然后spring会在系统运行到适当的时候，把你要的东西主动给你，同时也把你交给其他需要你的东西。所有的类的创建、销毁都由 spring来控制，也就是说控制对象生存周期的不再是引用它的对象，而是spring。对于某个具体的对象而言，以前是它控制其他对象，现在是所有对象都被spring控制，所以这叫控制反转。</p><h4 id="1-2-2-对于DI的理解"><a href="#1-2-2-对于DI的理解" class="headerlink" title="1.2.2 对于DI的理解"></a>1.2.2 对于DI的理解</h4><p>IoC的一个重点是在运行的时候，动态的向某个对象提供他所需要的对象，这一点是通过DI来实现的。</p><p>比如A对象需要操作数据库，他会向spring报告这个需求，而spring会在合适的时候创建这个数据库驱动，具体怎么创建A不知道，创建完毕之后注入A中，这就是DI。DI通常通过使用反射实现，他允许程序在运行的时候动态的生成对象，执行对象的方法，改变对象的属性。</p><h3 id="1-3-什么是AOP"><a href="#1-3-什么是AOP" class="headerlink" title="1.3 什么是AOP"></a>1.3 什么是AOP</h3><p>传统的OPP编程是不能解决横切逻辑代码的，所谓横切逻辑代码指的是代码在多个纵向顺序流程中出现的相同子流程代码，我们称之为横切逻辑代码。</p><p>例如：现有三个类，Horse、Pig、Dog，这三个类中都有 eat 和 run 两个方法。</p><p>通过 OOP 思想中的继承，我们可以提取出一个 Animal 的父类，然后将 eat 和 run 方法放入父类中，Horse、Pig、Dog通过继承Animal类即可自动获得 eat() 和 run() 方法。这样将会少些很多重复的代码。</p><p><img src="https://raw.githubusercontent.com/guduxingzheplus/blogPic/main/imgs/20230330102109.png"></p><p>OOP的代码如下：  </p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token punctuation">&#123;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Animal</span> <span class="token punctuation">&#123;</span>    <span class="token comment">/** 身高 */</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> height<span class="token punctuation">;</span>    <span class="token comment">/** 体重 */</span>    <span class="token keyword">private</span> <span class="token keyword">double</span> weight<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 性能监控代码</span>        <span class="token keyword">long</span> start <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 业务逻辑代码</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"I can eat..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 性能监控代码</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"执行时长："</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> start<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">1000f</span> <span class="token operator">+</span> <span class="token string">"s"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 性能监控代码</span>        <span class="token keyword">long</span> start <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 业务逻辑代码</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"I can run..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 性能监控代码</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"执行时长："</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> start<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">1000f</span> <span class="token operator">+</span> <span class="token string">"s"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://raw.githubusercontent.com/guduxingzheplus/blogPic/main/imgs/20230330102246.png"></p><p>横切代码存在的逻辑问题：</p><ul><li>代码重复</li><li>横切代码逻辑代码和业务代码混合在一起，代码臃肿，维护不方便</li></ul><p>AOP另辟蹊径，将横切代码抽离出来<br><img src="https://raw.githubusercontent.com/guduxingzheplus/blogPic/main/imgs/20230330102433.png"><br>代码拆分容易，难的是如何在不改变原有业务逻辑的情况下，达到一致的效果。</p><p><strong>AOP 为什么叫面向切片编程</strong></p><p>切：指的是横切逻辑，又有业务逻辑代码不懂，只能操作横切逻辑代码，所以面向横切逻辑</p><p>面：横切逻辑代码往往要影响很多个方法，每个方法如同一个点，多个点构成一个面。</p><h1 id="2-什么是Spring-Bean"><a href="#2-什么是Spring-Bean" class="headerlink" title="2. 什么是Spring Bean"></a>2. 什么是Spring Bean</h1><p>简单说，就是背那些Ioc容器管理的对象<br>我们需要告诉ioc容器要帮我们管理哪些对象，这个是通过元数据定义的。配置文件可以是XML文件，注解或者java配置类</p><h2 id="2-1-将类声明为Bean的注解"><a href="#2-1-将类声明为Bean的注解" class="headerlink" title="2.1 将类声明为Bean的注解"></a>2.1 将类声明为Bean的注解</h2><ul><li>@Componenet：通用注解，可以理解为Spring组件，不知道属于哪层的时候可以用。</li><li>@Repository：对应持久层的Dao层，主要用于数据库操作</li><li>@Service ：服务层，主要涉及一些复杂的逻辑，需要用到Dao</li><li>@Controller ：控制层，接受用户的调用，并请求Service层返回数据给前端。</li></ul><h2 id="2-2-Component-和-Bean区别"><a href="#2-2-Component-和-Bean区别" class="headerlink" title="2.2 @Component 和 @Bean区别"></a>2.2 @Component 和 @Bean区别</h2><ul><li>@Componenet 主要用于类的注解。 @Bean主要用于方法</li><li>@Componnet 主要是通过类路径扫描获得的，比如@ComponentScan，但是@Bean是在标有该注解的方法中定义产生这个bean，@Bean告诉了Spring，这个是某个类的实例，当我需要的时候，要还给我。</li><li>@Bean比@Component更加灵活，很多时候我们只能通过@Bean来注册bean，比如引用第三方库的时候。</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AppConfig</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> <span class="token class-name">TransferService</span> <span class="token function">transferService</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">TransferServiceImpl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的代码相当于如下的xml文件</p><pre class="line-numbers language-XML" data-language="XML"><code class="language-XML">&lt;beans&gt;    &lt;bean id&#x3D;&quot;transferService&quot; class&#x3D;&quot;com.acme.TransferServiceImpl&quot;&#x2F;&gt;&lt;&#x2F;beans&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>下面这个例子是通过 @Component 无法实现的。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Bean</span><span class="token keyword">public</span> <span class="token class-name">OneService</span> <span class="token function">getService</span><span class="token punctuation">(</span>status<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">case</span> <span class="token punctuation">(</span>status<span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>        when <span class="token number">1</span><span class="token operator">:</span>                <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token function">serviceImpl1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        when <span class="token number">2</span><span class="token operator">:</span>                <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token function">serviceImpl2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        when <span class="token number">3</span><span class="token operator">:</span>                <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token function">serviceImpl3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-3-Autowired和-Resource区别是什么？"><a href="#2-3-Autowired和-Resource区别是什么？" class="headerlink" title="2.3 @Autowired和@Resource区别是什么？"></a>2.3 @Autowired和@Resource区别是什么？</h2><p><font style="background: gray">Autowired</font><br>属于spring内置的注解，默认注入的方式为byType，也就是说会优先按照类型去匹配，但是存在如下的问题</p><ul><li><p>一个接口可能会出现同类型有很多个不同的实现类，这样就会造成byType混乱，找不到对应的实现类。这种情况下的实现办法如下：  </p><ul><li>spring会采用byName的形式来进行匹配，也就是根据类名的小写首字母的形式来进行匹配。举例  <pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Autowired</span><span class="token keyword">private</span> <span class="token class-name">SmService</span> smService<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul><p>  再比如：Sms有两个实现类，<font style="background:ddd gray">SmsServiceImpl1</font>和 <font style="background: gray">SmsServiceImpl2</font>此时都已经被spring容器管理，我们应该这样使用<br>  <pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 报错，byName 和 byType 都无法匹配到 bean</span><span class="token annotation punctuation">@Autowired</span><span class="token keyword">private</span> <span class="token class-name">SmsService</span> smsService<span class="token punctuation">;</span><span class="token comment">// 正确注入 SmsServiceImpl1 对象对应的 bean</span><span class="token annotation punctuation">@Autowired</span><span class="token keyword">private</span> <span class="token class-name">SmsService</span> smsServiceImpl1<span class="token punctuation">;</span><span class="token comment">// 正确注入  SmsServiceImpl1 对象对应的 bean</span><span class="token comment">// smsServiceImpl1 就是我们上面所说的名称</span><span class="token annotation punctuation">@Autowired</span><span class="token annotation punctuation">@Qualifier</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"smsServiceImpl1"</span><span class="token punctuation">)</span><span class="token keyword">private</span> <span class="token class-name">SmsService</span> smsService<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>  这里推荐使用@Qualifier来指定使用的类。</p><p>  <strong>@Resource</strong> 是jdk提供的注解，默认的注入方式为byName，如果无法通过byName注入，那么久通过byType进行注入。<br>  Resource有两个比较重要的属性：</p><ul><li>Name：名称</li><li>type：类型</li></ul></li></ul><p>总结一下：</p><ul><li>@Autowired 是 Spring 提供的注解，@Resource 是 JDK 提供的注解。</li><li>Autowired 默认的注入方式为byType（根据类型进行匹配），@Resource默认注入方式为 byName（根据名称进行匹配）。</li><li>在一个接口存在多个实现类的时候，二者都需要通过名称才能正确匹配到对应的bean，Autowired可以通过@Qualifer类显示的指定名称，@Resourse可以通过name属性来显示指定名称。</li></ul><h1 id="3-对SpringAoP的理解"><a href="#3-对SpringAoP的理解" class="headerlink" title="3.对SpringAoP的理解"></a>3.对SpringAoP的理解</h1><p>基于动态代理的，如果被代理的对象实现了某个接口，那么会用JDK Proxy代理，对于没有实现接口的对象，就使用cglib代理。</p><h2 id="3-1-Spring-AOP-和-AspectJ-AOP-有什么区别？"><a href="#3-1-Spring-AOP-和-AspectJ-AOP-有什么区别？" class="headerlink" title="3.1 Spring AOP 和 AspectJ AOP 有什么区别？"></a>3.1 Spring AOP 和 AspectJ AOP 有什么区别？</h2><p>也可以用AspectJ，这个是最完整的aop框架。Spring AOP属于是<strong>运行时增强</strong>而AspectJ是<strong>编译时增强</strong>，AOP是基于字节码操作。目前AOP已经集成了AspetJ但是，在切面比较少的情况下，两者差异不大，多的时候就用AspectJ，她的速度快很多。</p><h2 id="3-2-多个切面之间的执行顺序？"><a href="#3-2-多个切面之间的执行顺序？" class="headerlink" title="3.2 多个切面之间的执行顺序？"></a>3.2 多个切面之间的执行顺序？</h2><p>通过@Order来进行控制，通过实现Orderd接口重写getOrder方法</p><h1 id="4-Spring-mvc"><a href="#4-Spring-mvc" class="headerlink" title="4. Spring mvc"></a>4. Spring mvc</h1><h2 id="4-1-核心组件"><a href="#4-1-核心组件" class="headerlink" title="4.1 核心组件"></a>4.1 核心组件</h2><ul><li><font style="background:ddd gray">DispatcherServlet</font>： 核心的中央处理器，负责接受请求，分发，并给予客户端响应</li><li>HandlerMapping： 处理器映射器，根据uri去匹配查找能处理的Handler，并会将设计到的拦截器和Handler一起封装。</li><li>HandlerAdapter： 处理器适配器，根据上一步找到的Handler，适配对应执行的Handler</li><li>Handler: 请求处理器，处理实际请求的处理器。</li><li>ViewResolver：视图解析器，根据Handler返回的逻辑视图，解析并渲染真正的视图，并传递给DispatcherServlet。</li></ul><h2 id="4-2-工作原理"><a href="#4-2-工作原理" class="headerlink" title="4.2 工作原理"></a>4.2 工作原理</h2><p><img src="https://raw.githubusercontent.com/guduxingzheplus/blogPic/main/imgs/20230331081801.png" alt="20230331081801"></p><p><font style="background: gray">流程说明（important）：</font></p><ol><li>客户端浏览器发送请求到DispatchServlet</li><li>DispatcherServlet调用HandlerMapping，根据uri寻找合适的Handler（也就是Controller），并且会将请求涉及的拦截器和Handler一起封装返回。</li><li>DispatcherServlet调用HandlerAdapter适配执行Handler</li><li>Handler完成对用户请求的处理后，返回一个ModelAndView对象给DispathcerServlet，ModelAndView就是包含了数据模型以及相应的视图信息。Model是返回的数据对象，View是逻辑上的View</li><li>ViewResolver会根据逻辑View查找实际的view</li><li>DispatcherServlet将返回的Model传给View（视图渲染）</li><li>把view返回给请求者。</li></ol><h2 id="4-3-统一异常处理怎么做"><a href="#4-3-统一异常处理怎么做" class="headerlink" title="4.3 统一异常处理怎么做"></a>4.3 统一异常处理怎么做</h2><p>使用@ControllerAdvice + @ExceptionHandler来处理</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@ControllerAdvice</span><span class="token annotation punctuation">@ResponseBody</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">GlobalExceptionHandler</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@ExceptionHandler</span><span class="token punctuation">(</span><span class="token class-name">BaseException</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token class-name">ResponseEntity</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> <span class="token function">handleAppException</span><span class="token punctuation">(</span><span class="token class-name">BaseException</span> ex<span class="token punctuation">,</span> <span class="token class-name">HttpServletRequest</span> request<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token comment">//......</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@ExceptionHandler</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token class-name">ResourceNotFoundException</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token class-name">ResponseEntity</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">ErrorReponse</span><span class="token punctuation">></span></span> <span class="token function">handleResourceNotFoundException</span><span class="token punctuation">(</span><span class="token class-name">ResourceNotFoundException</span> ex<span class="token punctuation">,</span> <span class="token class-name">HttpServletRequest</span> request<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token comment">//......</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>@ControllerAdvice是controller增强器，主要三个作用，全局异常处理，全局数据绑定，全局数据预处理</p><p>这种异常处理方式下，会给所有或者指定的 Controller 织入异常处理的逻辑（AOP），当 Controller 中的方法抛出异常的时候，由被@ExceptionHandler 注解修饰的方法进行处理。</p><h1 id="5-Spring-Data-JPA"><a href="#5-Spring-Data-JPA" class="headerlink" title="5. Spring Data JPA"></a>5. Spring Data JPA</h1><h2 id="5-1-如何用JPA对数据库中的某个字段非持久化"><a href="#5-1-如何用JPA对数据库中的某个字段非持久化" class="headerlink" title="5.1 如何用JPA对数据库中的某个字段非持久化"></a>5.1 如何用JPA对数据库中的某个字段非持久化</h2><p>所谓非持久化，就是在实体类中，让某个字段不被数据库存储。<br>可以采用如下方法</p><ul><li><p>static String s1; &#x2F;&#x2F;加了static</p></li><li><p>final String s1 &#x3D; “ss”;  &#x2F;&#x2F;final修饰</p></li><li><p>transient String s1; &#x2F;&#x2F;trainsient修饰</p></li><li><p>@Transient &#x2F;&#x2F;加了注解<br>String s1;</p><p>主要使用后两种比较多</p></li></ul><h2 id="5-2-PA-的审计功能是做什么的？有什么用？"><a href="#5-2-PA-的审计功能是做什么的？有什么用？" class="headerlink" title="5.2 PA 的审计功能是做什么的？有什么用？"></a>5.2 PA 的审计功能是做什么的？有什么用？</h2><p>审计功能主要是帮助我们记录数据库操作的具体行为比如某条记录是谁创建的、什么时间创建的、最后修改人是谁、最后修改时间是什么时候。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Data</span><span class="token annotation punctuation">@AllArgsConstructor</span><span class="token annotation punctuation">@NoArgsConstructor</span><span class="token annotation punctuation">@MappedSuperclass</span><span class="token annotation punctuation">@EntityListeners</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token class-name">AuditingEntityListener</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">AbstractAuditBase</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@CreatedDate</span>    <span class="token annotation punctuation">@Column</span><span class="token punctuation">(</span>updatable <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">)</span>    <span class="token annotation punctuation">@JsonIgnore</span>    <span class="token keyword">private</span> <span class="token class-name">Instant</span> createdAt<span class="token punctuation">;</span>    <span class="token annotation punctuation">@LastModifiedDate</span>    <span class="token annotation punctuation">@JsonIgnore</span>    <span class="token keyword">private</span> <span class="token class-name">Instant</span> updatedAt<span class="token punctuation">;</span>    <span class="token annotation punctuation">@CreatedBy</span>    <span class="token annotation punctuation">@Column</span><span class="token punctuation">(</span>updatable <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">)</span>    <span class="token annotation punctuation">@JsonIgnore</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> createdBy<span class="token punctuation">;</span>    <span class="token annotation punctuation">@LastModifiedBy</span>    <span class="token annotation punctuation">@JsonIgnore</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> updatedBy<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>@CreatedDate: 表示该字段为创建时间字段，在这个实体被 insert 的时候，会设置值</li><li>@CreatedBy :表示该字段为创建人，在这个实体被 insert 的时候，会设置值@LastModifiedDate、@LastModifiedBy同理。</li></ul><h1 id="6-Spring-Security"><a href="#6-Spring-Security" class="headerlink" title="6. Spring Security"></a>6. Spring Security</h1><h2 id="6-1-有哪些请求权限的方法"><a href="#6-1-有哪些请求权限的方法" class="headerlink" title="6.1 有哪些请求权限的方法"></a>6.1 有哪些请求权限的方法</h2><ul><li>permitAll() ：无条件允许任何形式访问，不管你登录还是没有登录。</li><li>anonymous() ：允许匿名访问，也就是没有登录才可以访问。</li><li>denyAll() ：无条件决绝任何形式的访问。</li><li>authenticated()：只允许已认证的用户访问。</li><li>fullyAuthenticated() ：只允许已经登录或者通过 </li><li>remember-me 登录的用户访问。</li><li>hasRole(String) : 只允许指定的角色访问。</li><li>hasAnyRole(String)  : 指定一个或者多个角色，满足其一的用户即可访问。</li><li>hasAuthority(String) ：只允许具有指定权限的用户访问</li><li>hasAnyAuthority(String) ：指定一个或者多个权限，满足其一的用户即可访问。</li><li>hasIpAddress(String) : 只允许指定 ip 的用户访问。</li></ul><h2 id="6-2-hasRole-和-hasAuthority-有区别吗？"><a href="#6-2-hasRole-和-hasAuthority-有区别吗？" class="headerlink" title="6.2 hasRole 和 hasAuthority 有区别吗？"></a>6.2 hasRole 和 hasAuthority 有区别吗？</h2><p>二者是存在区别的，hasRole会要求数据库中的权限字段加上ROLE_前缀，而hasAuthority并不要求。从设计层面上讲，hasRole是角色表，而角色是权限的集合。也就是说，使用 hasAuthority 更具有一致性，你不用考虑要不要加 ROLE_ 前缀，数据库什么样这里就是什么样！而 hasRole 则不同，代码里如果写的是 admin，框架会自动加上 ROLE_ 前缀，所以数据库就必须是 ROLE_admin。</p><h2 id="6-3-对密码加密？"><a href="#6-3-对密码加密？" class="headerlink" title="6.3 对密码加密？"></a>6.3 对密码加密？</h2><p>使用bcrypt，当然也可以自己设计加密算法，继承PasswordEncoder类</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">PasswordEncoder</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 加密也就是对原始密码进行编码</span>    <span class="token class-name">String</span> <span class="token function">encode</span><span class="token punctuation">(</span><span class="token class-name">CharSequence</span> var1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 比对原始密码和数据库中保存的密码</span>    <span class="token keyword">boolean</span> <span class="token function">matches</span><span class="token punctuation">(</span><span class="token class-name">CharSequence</span> var1<span class="token punctuation">,</span> <span class="token class-name">String</span> var2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 判断加密密码是否需要再次进行加密，默认返回 false</span>    <span class="token keyword">default</span> <span class="token keyword">boolean</span> <span class="token function">upgradeEncoding</span><span class="token punctuation">(</span><span class="token class-name">String</span> encodedPassword<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="6-4-更换密码加密算法"><a href="#6-4-更换密码加密算法" class="headerlink" title="6.4 更换密码加密算法"></a>6.4 更换密码加密算法</h2><p>使用DelegatingPasswordEncoder兼容多种不同的加密方案。这其实是个代理类，并非全新的加密算法，他做的事情就是代理加密算法实现类。</p>]]></content>
      
      
      <categories>
          
          <category> spring面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
